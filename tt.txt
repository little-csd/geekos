
project2/build/geekos/kernel.exe:     file format elf32-i386


Disassembly of section .text:

00010000 <Init_Interrupt_Gate>:
 * Initialize an interrupt gate with given handler address
 * and descriptor privilege level.
 */
void Init_Interrupt_Gate(union IDT_Descriptor* desc, ulong_t addr,
	int dpl)
{
   10000:	53                   	push   %ebx
   10001:	8b 54 24 08          	mov    0x8(%esp),%edx
   10005:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    desc->ig.offsetLow = addr & 0xffff;
   10009:	66 89 0a             	mov    %cx,(%edx)
    desc->ig.segmentSelector = KERNEL_CS;
   1000c:	66 c7 42 02 08 00    	movw   $0x8,0x2(%edx)
    desc->ig.reserved = 0;
   10012:	80 62 04 e0          	andb   $0xe0,0x4(%edx)
    desc->ig.signature = 0x70;  /* == 01110000b */
   10016:	0f b7 42 04          	movzwl 0x4(%edx),%eax
   1001a:	66 25 1f e0          	and    $0xe01f,%ax
   1001e:	80 cc 0e             	or     $0xe,%ah
   10021:	66 89 42 04          	mov    %ax,0x4(%edx)
    desc->ig.dpl = dpl;
   10025:	0f b6 5c 24 10       	movzbl 0x10(%esp),%ebx
   1002a:	83 e3 03             	and    $0x3,%ebx
   1002d:	c1 e3 05             	shl    $0x5,%ebx
   10030:	0f b6 c4             	movzbl %ah,%eax
   10033:	83 e0 9f             	and    $0xffffff9f,%eax
   10036:	09 d8                	or     %ebx,%eax
    desc->ig.present = 1;
   10038:	83 c8 80             	or     $0xffffff80,%eax
   1003b:	88 42 05             	mov    %al,0x5(%edx)
    desc->ig.offsetHigh = addr >> 16;
   1003e:	c1 e9 10             	shr    $0x10,%ecx
   10041:	66 89 4a 06          	mov    %cx,0x6(%edx)
}
   10045:	5b                   	pop    %ebx
   10046:	c3                   	ret    

00010047 <Init_IDT>:
{
   10047:	55                   	push   %ebp
   10048:	57                   	push   %edi
   10049:	56                   	push   %esi
   1004a:	53                   	push   %ebx
   1004b:	83 ec 38             	sub    $0x38,%esp
   1004e:	e8 bf 01 00 00       	call   10212 <__x86.get_pc_thunk.bx>
   10053:	81 c3 ad 5f 01 00    	add    $0x15fad,%ebx
    Print("Initializing IDT...\n");
   10059:	8d 83 00 70 ff ff    	lea    -0x9000(%ebx),%eax
   1005f:	50                   	push   %eax
   10060:	e8 75 0f 00 00       	call   10fda <Print>
    KASSERT(g_handlerSizeNoErr == g_handlerSizeErr);
   10065:	c7 c0 f8 60 02 00    	mov    $0x260f8,%eax
   1006b:	8b 00                	mov    (%eax),%eax
   1006d:	83 c4 10             	add    $0x10,%esp
   10070:	c7 c2 fc 60 02 00    	mov    $0x260fc,%edx
   10076:	3b 02                	cmp    (%edx),%eax
   10078:	75 31                	jne    100ab <Init_IDT+0x64>
    KASSERT((&g_entryPointTableEnd - &g_entryPointTableStart) ==
   1007a:	c1 e0 08             	shl    $0x8,%eax
   1007d:	c7 c2 18 bf 01 00    	mov    $0x1bf18,%edx
   10083:	81 ea 18 af 01 00    	sub    $0x1af18,%edx
   10089:	39 d0                	cmp    %edx,%eax
   1008b:	75 5f                	jne    100ec <Init_IDT+0xa5>
    ulong_t tableBaseAddr = (ulong_t) &g_entryPointTableStart;
   1008d:	c7 c7 18 af 01 00    	mov    $0x1af18,%edi
   10093:	be 00 00 00 00       	mov    $0x0,%esi
	addr += g_handlerSizeNoErr;
   10098:	c7 c0 f8 60 02 00    	mov    $0x260f8,%eax
   1009e:	89 44 24 0c          	mov    %eax,0xc(%esp)
   100a2:	89 44 24 08          	mov    %eax,0x8(%esp)
   100a6:	e9 a0 00 00 00       	jmp    1014b <Init_IDT+0x104>
    KASSERT(g_handlerSizeNoErr == g_handlerSizeErr);
   100ab:	83 ec 0c             	sub    $0xc,%esp
   100ae:	6a 4f                	push   $0x4f
   100b0:	e8 74 10 00 00       	call   11129 <Set_Current_Attr>
   100b5:	83 c4 0c             	add    $0xc,%esp
   100b8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   100be:	ff 30                	pushl  (%eax)
   100c0:	ff 74 24 44          	pushl  0x44(%esp)
   100c4:	6a 3d                	push   $0x3d
   100c6:	8d 83 15 70 ff ff    	lea    -0x8feb(%ebx),%eax
   100cc:	50                   	push   %eax
   100cd:	8d 83 2c 70 ff ff    	lea    -0x8fd4(%ebx),%eax
   100d3:	50                   	push   %eax
   100d4:	8d 83 3c 71 ff ff    	lea    -0x8ec4(%ebx),%eax
   100da:	50                   	push   %eax
   100db:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   100e1:	50                   	push   %eax
   100e2:	e8 f3 0e 00 00       	call   10fda <Print>
   100e7:	83 c4 20             	add    $0x20,%esp
   100ea:	eb fe                	jmp    100ea <Init_IDT+0xa3>
    KASSERT((&g_entryPointTableEnd - &g_entryPointTableStart) ==
   100ec:	83 ec 0c             	sub    $0xc,%esp
   100ef:	6a 4f                	push   $0x4f
   100f1:	e8 33 10 00 00       	call   11129 <Set_Current_Attr>
   100f6:	83 c4 0c             	add    $0xc,%esp
   100f9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   100ff:	ff 30                	pushl  (%eax)
   10101:	ff 74 24 44          	pushl  0x44(%esp)
   10105:	6a 3e                	push   $0x3e
   10107:	8d 83 15 70 ff ff    	lea    -0x8feb(%ebx),%eax
   1010d:	50                   	push   %eax
   1010e:	8d 83 94 70 ff ff    	lea    -0x8f6c(%ebx),%eax
   10114:	50                   	push   %eax
   10115:	8d 83 3c 71 ff ff    	lea    -0x8ec4(%ebx),%eax
   1011b:	50                   	push   %eax
   1011c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10122:	50                   	push   %eax
   10123:	e8 b2 0e 00 00       	call   10fda <Print>
   10128:	83 c4 20             	add    $0x20,%esp
   1012b:	eb fe                	jmp    1012b <Init_IDT+0xe4>
	Init_Interrupt_Gate(&s_IDT[i], addr, dpl);
   1012d:	83 ec 04             	sub    $0x4,%esp
   10130:	6a 03                	push   $0x3
   10132:	57                   	push   %edi
   10133:	8d 83 80 05 00 00    	lea    0x580(%ebx),%eax
   10139:	50                   	push   %eax
   1013a:	e8 c1 fe ff ff       	call   10000 <Init_Interrupt_Gate>
	addr += g_handlerSizeNoErr;
   1013f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10143:	03 38                	add    (%eax),%edi
   10145:	83 c4 10             	add    $0x10,%esp
   10148:	83 c6 01             	add    $0x1,%esi
	int dpl = (i == SYSCALL_INT) ? USER_PRIVILEGE : KERNEL_PRIVILEGE;
   1014b:	81 fe 90 00 00 00    	cmp    $0x90,%esi
   10151:	74 da                	je     1012d <Init_IDT+0xe6>
	Init_Interrupt_Gate(&s_IDT[i], addr, dpl);
   10153:	8d ab 00 01 00 00    	lea    0x100(%ebx),%ebp
   10159:	83 ec 04             	sub    $0x4,%esp
   1015c:	6a 00                	push   $0x0
   1015e:	57                   	push   %edi
   1015f:	8d 44 f5 00          	lea    0x0(%ebp,%esi,8),%eax
   10163:	50                   	push   %eax
   10164:	e8 97 fe ff ff       	call   10000 <Init_Interrupt_Gate>
	addr += g_handlerSizeNoErr;
   10169:	8b 44 24 18          	mov    0x18(%esp),%eax
   1016d:	03 38                	add    (%eax),%edi
    for (i = 0, addr = tableBaseAddr; i < NUM_IDT_ENTRIES; ++i) {
   1016f:	8d 46 01             	lea    0x1(%esi),%eax
   10172:	83 c4 10             	add    $0x10,%esp
   10175:	3d ff 00 00 00       	cmp    $0xff,%eax
   1017a:	7e cc                	jle    10148 <Init_IDT+0x101>
    limitAndBase[0] = 8 * NUM_IDT_ENTRIES;
   1017c:	66 c7 44 24 1a 00 08 	movw   $0x800,0x1a(%esp)
    limitAndBase[1] = idtBaseAddr & 0xffff;
   10183:	66 89 6c 24 1c       	mov    %bp,0x1c(%esp)
    limitAndBase[2] = idtBaseAddr >> 16;
   10188:	c1 ed 10             	shr    $0x10,%ebp
   1018b:	66 89 6c 24 1e       	mov    %bp,0x1e(%esp)
    Load_IDTR(limitAndBase);
   10190:	83 ec 0c             	sub    $0xc,%esp
   10193:	8d 44 24 26          	lea    0x26(%esp),%eax
   10197:	50                   	push   %eax
   10198:	e8 23 ac 00 00       	call   1adc0 <Load_IDTR>
}
   1019d:	83 c4 3c             	add    $0x3c,%esp
   101a0:	5b                   	pop    %ebx
   101a1:	5e                   	pop    %esi
   101a2:	5f                   	pop    %edi
   101a3:	5d                   	pop    %ebp
   101a4:	c3                   	ret    

000101a5 <Install_Interrupt_Handler>:
 * This is a lower-level notion than an "IRQ", which specifically
 * means an interrupt triggered by external hardware.
 * This function can install a handler for ANY interrupt.
 */
void Install_Interrupt_Handler(int interrupt, Interrupt_Handler handler)
{
   101a5:	53                   	push   %ebx
   101a6:	83 ec 08             	sub    $0x8,%esp
   101a9:	e8 64 00 00 00       	call   10212 <__x86.get_pc_thunk.bx>
   101ae:	81 c3 52 5e 01 00    	add    $0x15e52,%ebx
   101b4:	8b 44 24 10          	mov    0x10(%esp),%eax
    KASSERT(interrupt >= 0 && interrupt < NUM_IDT_ENTRIES);
   101b8:	3d ff 00 00 00       	cmp    $0xff,%eax
   101bd:	77 12                	ja     101d1 <Install_Interrupt_Handler+0x2c>
    g_interruptTable[interrupt] = handler;
   101bf:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   101c3:	c7 c2 80 73 02 00    	mov    $0x27380,%edx
   101c9:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
}
   101cc:	83 c4 08             	add    $0x8,%esp
   101cf:	5b                   	pop    %ebx
   101d0:	c3                   	ret    
    KASSERT(interrupt >= 0 && interrupt < NUM_IDT_ENTRIES);
   101d1:	83 ec 0c             	sub    $0xc,%esp
   101d4:	6a 4f                	push   $0x4f
   101d6:	e8 4e 0f 00 00       	call   11129 <Set_Current_Attr>
   101db:	83 c4 0c             	add    $0xc,%esp
   101de:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   101e4:	ff 30                	pushl  (%eax)
   101e6:	ff 74 24 14          	pushl  0x14(%esp)
   101ea:	6a 75                	push   $0x75
   101ec:	8d 83 15 70 ff ff    	lea    -0x8feb(%ebx),%eax
   101f2:	50                   	push   %eax
   101f3:	8d 83 f0 70 ff ff    	lea    -0x8f10(%ebx),%eax
   101f9:	50                   	push   %eax
   101fa:	8d 83 20 71 ff ff    	lea    -0x8ee0(%ebx),%eax
   10200:	50                   	push   %eax
   10201:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10207:	50                   	push   %eax
   10208:	e8 cd 0d 00 00       	call   10fda <Print>
   1020d:	83 c4 20             	add    $0x20,%esp
   10210:	eb fe                	jmp    10210 <Install_Interrupt_Handler+0x6b>

00010212 <__x86.get_pc_thunk.bx>:
   10212:	8b 1c 24             	mov    (%esp),%ebx
   10215:	c3                   	ret    

00010216 <Print_Selector>:
    Dump_Interrupt_State(state);
    STOP();
}

static void Print_Selector(const char* regName, uint_t value)
{
   10216:	53                   	push   %ebx
   10217:	83 ec 14             	sub    $0x14,%esp
   1021a:	e8 f3 ff ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1021f:	81 c3 e1 5d 01 00    	add    $0x15de1,%ebx
   10225:	89 c1                	mov    %eax,%ecx
    Print("%s: index=%d, ti=%d, rpl=%d\n",
   10227:	89 d0                	mov    %edx,%eax
   10229:	83 e0 03             	and    $0x3,%eax
   1022c:	50                   	push   %eax
	regName, value >> 3, (value >> 2) & 1, value & 3);
   1022d:	89 d0                	mov    %edx,%eax
   1022f:	c1 e8 02             	shr    $0x2,%eax
    Print("%s: index=%d, ti=%d, rpl=%d\n",
   10232:	83 e0 01             	and    $0x1,%eax
   10235:	50                   	push   %eax
   10236:	c1 ea 03             	shr    $0x3,%edx
   10239:	52                   	push   %edx
   1023a:	51                   	push   %ecx
   1023b:	8d 83 45 71 ff ff    	lea    -0x8ebb(%ebx),%eax
   10241:	50                   	push   %eax
   10242:	e8 93 0d 00 00       	call   10fda <Print>
}
   10247:	83 c4 28             	add    $0x28,%esp
   1024a:	5b                   	pop    %ebx
   1024b:	c3                   	ret    

0001024c <Interrupts_Enabled>:

/*
 * Query whether or not interrupts are currently enabled.
 */
bool Interrupts_Enabled(void)
{
   1024c:	53                   	push   %ebx
   1024d:	83 ec 08             	sub    $0x8,%esp
   10250:	e8 bd ff ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10255:	81 c3 ab 5d 01 00    	add    $0x15dab,%ebx
    ulong_t eflags = Get_Current_EFLAGS();
   1025b:	e8 b0 ac 00 00       	call   1af10 <Get_Current_EFLAGS>
    return (eflags & EFLAGS_IF) != 0;
   10260:	c1 e8 09             	shr    $0x9,%eax
   10263:	83 e0 01             	and    $0x1,%eax
}
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	5b                   	pop    %ebx
   1026a:	c3                   	ret    

0001026b <Init_Interrupts>:
{
   1026b:	57                   	push   %edi
   1026c:	56                   	push   %esi
   1026d:	53                   	push   %ebx
   1026e:	e8 9f ff ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10273:	81 c3 8d 5d 01 00    	add    $0x15d8d,%ebx
    Init_IDT();
   10279:	e8 c9 fd ff ff       	call   10047 <Init_IDT>
    for (i = 0; i < NUM_IDT_ENTRIES; ++i) {
   1027e:	be 00 00 00 00       	mov    $0x0,%esi
	Install_Interrupt_Handler(i, Dummy_Interrupt_Handler);
   10283:	8d bb c5 a3 fe ff    	lea    -0x15c3b(%ebx),%edi
   10289:	83 ec 08             	sub    $0x8,%esp
   1028c:	57                   	push   %edi
   1028d:	56                   	push   %esi
   1028e:	e8 12 ff ff ff       	call   101a5 <Install_Interrupt_Handler>
    for (i = 0; i < NUM_IDT_ENTRIES; ++i) {
   10293:	83 c6 01             	add    $0x1,%esi
   10296:	83 c4 10             	add    $0x10,%esp
   10299:	81 fe 00 01 00 00    	cmp    $0x100,%esi
   1029f:	75 e8                	jne    10289 <Init_Interrupts+0x1e>
    Enable_Interrupts();
   102a1:	e8 a6 ff ff ff       	call   1024c <Interrupts_Enabled>
   102a6:	84 c0                	test   %al,%al
   102a8:	75 05                	jne    102af <Init_Interrupts+0x44>
/*
 * Unblock interrupts.
 */
static __inline__ void __Enable_Interrupts(void)
{
    __asm__ __volatile__ ("sti");
   102aa:	fb                   	sti    
}
   102ab:	5b                   	pop    %ebx
   102ac:	5e                   	pop    %esi
   102ad:	5f                   	pop    %edi
   102ae:	c3                   	ret    
    Enable_Interrupts();
   102af:	83 ec 0c             	sub    $0xc,%esp
   102b2:	6a 4f                	push   $0x4f
   102b4:	e8 70 0e 00 00       	call   11129 <Set_Current_Attr>
   102b9:	83 c4 0c             	add    $0xc,%esp
   102bc:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   102c2:	ff 30                	pushl  (%eax)
   102c4:	ff 74 24 14          	pushl  0x14(%esp)
   102c8:	6a 41                	push   $0x41
   102ca:	8d 83 62 71 ff ff    	lea    -0x8e9e(%ebx),%eax
   102d0:	50                   	push   %eax
   102d1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   102d7:	50                   	push   %eax
   102d8:	8d 83 78 72 ff ff    	lea    -0x8d88(%ebx),%eax
   102de:	50                   	push   %eax
   102df:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   102e5:	50                   	push   %eax
   102e6:	e8 ef 0c 00 00       	call   10fda <Print>
   102eb:	83 c4 20             	add    $0x20,%esp
   102ee:	eb fe                	jmp    102ee <Init_Interrupts+0x83>

000102f0 <Dump_Interrupt_State>:

/*
 * Dump interrupt state struct to screen
 */
void Dump_Interrupt_State(struct Interrupt_State* state)
{
   102f0:	56                   	push   %esi
   102f1:	53                   	push   %ebx
   102f2:	83 ec 10             	sub    $0x10,%esp
   102f5:	e8 18 ff ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   102fa:	81 c3 06 5d 01 00    	add    $0x15d06,%ebx
   10300:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    uint_t errorCode = state->errorCode;
   10304:	8b 46 30             	mov    0x30(%esi),%eax

    Print("eax=%08x ebx=%08x ecx=%08x edx=%08x\n"
   10307:	89 c2                	mov    %eax,%edx
   10309:	83 e2 01             	and    $0x1,%edx
   1030c:	52                   	push   %edx
	   "index=%d, TI=%d, IDT=%d, EXT=%d\n",
	state->eax, state->ebx, state->ecx, state->edx,
	state->esi, state->edi, state->ebp,
	state->eip, state->cs, state->eflags,
	state->intNum, errorCode,
	errorCode >> 3, (errorCode >> 2) & 1, (errorCode >> 1) & 1, errorCode & 1
   1030d:	89 c2                	mov    %eax,%edx
   1030f:	d1 ea                	shr    %edx
    Print("eax=%08x ebx=%08x ecx=%08x edx=%08x\n"
   10311:	83 e2 01             	and    $0x1,%edx
   10314:	52                   	push   %edx
	errorCode >> 3, (errorCode >> 2) & 1, (errorCode >> 1) & 1, errorCode & 1
   10315:	89 c2                	mov    %eax,%edx
   10317:	c1 ea 02             	shr    $0x2,%edx
    Print("eax=%08x ebx=%08x ecx=%08x edx=%08x\n"
   1031a:	83 e2 01             	and    $0x1,%edx
   1031d:	52                   	push   %edx
   1031e:	89 c2                	mov    %eax,%edx
   10320:	c1 ea 03             	shr    $0x3,%edx
   10323:	52                   	push   %edx
   10324:	50                   	push   %eax
   10325:	ff 76 2c             	pushl  0x2c(%esi)
   10328:	ff 76 3c             	pushl  0x3c(%esi)
   1032b:	ff 76 38             	pushl  0x38(%esi)
   1032e:	ff 76 34             	pushl  0x34(%esi)
   10331:	ff 76 10             	pushl  0x10(%esi)
   10334:	ff 76 14             	pushl  0x14(%esi)
   10337:	ff 76 18             	pushl  0x18(%esi)
   1033a:	ff 76 1c             	pushl  0x1c(%esi)
   1033d:	ff 76 20             	pushl  0x20(%esi)
   10340:	ff 76 24             	pushl  0x24(%esi)
   10343:	ff 76 28             	pushl  0x28(%esi)
   10346:	8d 83 b8 71 ff ff    	lea    -0x8e48(%ebx),%eax
   1034c:	50                   	push   %eax
   1034d:	e8 88 0c 00 00       	call   10fda <Print>
    return (state->cs & 3) == USER_PRIVILEGE;
   10352:	8b 46 38             	mov    0x38(%esi),%eax
   10355:	83 e0 03             	and    $0x3,%eax
    );
    if (Is_User_Interrupt(state)) {
   10358:	83 c4 50             	add    $0x50,%esp
   1035b:	83 f8 03             	cmp    $0x3,%eax
   1035e:	74 4b                	je     103ab <Dump_Interrupt_State+0xbb>
	struct User_Interrupt_State *ustate = (struct User_Interrupt_State*) state;
	Print("user esp=%08x, user ss=%08x\n", ustate->espUser, ustate->ssUser);
    }
    Print_Selector("cs", state->cs);
   10360:	8b 56 38             	mov    0x38(%esi),%edx
   10363:	8d 83 a9 71 ff ff    	lea    -0x8e57(%ebx),%eax
   10369:	e8 a8 fe ff ff       	call   10216 <Print_Selector>
    Print_Selector("ds", state->ds);
   1036e:	8b 56 0c             	mov    0xc(%esi),%edx
   10371:	8d 83 ac 71 ff ff    	lea    -0x8e54(%ebx),%eax
   10377:	e8 9a fe ff ff       	call   10216 <Print_Selector>
    Print_Selector("es", state->es);
   1037c:	8b 56 08             	mov    0x8(%esi),%edx
   1037f:	8d 83 af 71 ff ff    	lea    -0x8e51(%ebx),%eax
   10385:	e8 8c fe ff ff       	call   10216 <Print_Selector>
    Print_Selector("fs", state->fs);
   1038a:	8b 56 04             	mov    0x4(%esi),%edx
   1038d:	8d 83 b2 71 ff ff    	lea    -0x8e4e(%ebx),%eax
   10393:	e8 7e fe ff ff       	call   10216 <Print_Selector>
    Print_Selector("gs", state->gs);
   10398:	8b 16                	mov    (%esi),%edx
   1039a:	8d 83 b5 71 ff ff    	lea    -0x8e4b(%ebx),%eax
   103a0:	e8 71 fe ff ff       	call   10216 <Print_Selector>
}
   103a5:	83 c4 04             	add    $0x4,%esp
   103a8:	5b                   	pop    %ebx
   103a9:	5e                   	pop    %esi
   103aa:	c3                   	ret    
	Print("user esp=%08x, user ss=%08x\n", ustate->espUser, ustate->ssUser);
   103ab:	83 ec 04             	sub    $0x4,%esp
   103ae:	ff 76 44             	pushl  0x44(%esi)
   103b1:	ff 76 40             	pushl  0x40(%esi)
   103b4:	8d 83 8c 71 ff ff    	lea    -0x8e74(%ebx),%eax
   103ba:	50                   	push   %eax
   103bb:	e8 1a 0c 00 00       	call   10fda <Print>
   103c0:	83 c4 10             	add    $0x10,%esp
   103c3:	eb 9b                	jmp    10360 <Dump_Interrupt_State+0x70>

000103c5 <Dummy_Interrupt_Handler>:
{
   103c5:	53                   	push   %ebx
   103c6:	83 ec 14             	sub    $0x14,%esp
   103c9:	e8 44 fe ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   103ce:	81 c3 32 5c 01 00    	add    $0x15c32,%ebx
    Print("*** Unexpected interrupt! ***\n");
   103d4:	8d 93 58 72 ff ff    	lea    -0x8da8(%ebx),%edx
   103da:	52                   	push   %edx
   103db:	e8 fa 0b 00 00       	call   10fda <Print>
    Dump_Interrupt_State(state);
   103e0:	83 c4 04             	add    $0x4,%esp
   103e3:	ff 74 24 1c          	pushl  0x1c(%esp)
   103e7:	e8 04 ff ff ff       	call   102f0 <Dump_Interrupt_State>
   103ec:	83 c4 10             	add    $0x10,%esp
    STOP();
   103ef:	eb fe                	jmp    103ef <Dummy_Interrupt_Handler+0x2a>

000103f1 <Syscall_Handler>:

/*
 * System call handler.
 */
static void Syscall_Handler(struct Interrupt_State* state)
{
   103f1:	56                   	push   %esi
   103f2:	53                   	push   %ebx
   103f3:	83 ec 04             	sub    $0x4,%esp
   103f6:	e8 d8 00 00 00       	call   104d3 <__x86.get_pc_thunk.si>
   103fb:	81 c6 05 5c 01 00    	add    $0x15c05,%esi
   10401:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    /* The system call number is specified in the eax register. */
    uint_t syscallNum = state->eax;
   10405:	8b 43 28             	mov    0x28(%ebx),%eax

    /* Make sure the the system call number refers to a legal value. */
    if (syscallNum < 0 || syscallNum >= g_numSyscalls) {
   10408:	c7 c2 50 e3 01 00    	mov    $0x1e350,%edx
   1040e:	39 02                	cmp    %eax,(%edx)
   10410:	76 16                	jbe    10428 <Syscall_Handler+0x37>

    /*
     * Call the appropriate syscall function.
     * Return code of system call is returned in EAX.
     */
    state->eax = g_syscallTable[syscallNum](state);
   10412:	83 ec 0c             	sub    $0xc,%esp
   10415:	53                   	push   %ebx
   10416:	c7 c2 c0 5f 02 00    	mov    $0x25fc0,%edx
   1041c:	ff 14 82             	call   *(%edx,%eax,4)
   1041f:	89 43 28             	mov    %eax,0x28(%ebx)
}
   10422:	83 c4 14             	add    $0x14,%esp
   10425:	5b                   	pop    %ebx
   10426:	5e                   	pop    %esi
   10427:	c3                   	ret    
	Print("Illegal system call %d by process %d\n",
   10428:	83 ec 04             	sub    $0x4,%esp
   1042b:	c7 c2 90 77 02 00    	mov    $0x27790,%edx
   10431:	8b 12                	mov    (%edx),%edx
   10433:	ff 72 34             	pushl  0x34(%edx)
   10436:	50                   	push   %eax
   10437:	8d 86 88 72 ff ff    	lea    -0x8d78(%esi),%eax
   1043d:	50                   	push   %eax
   1043e:	89 f3                	mov    %esi,%ebx
   10440:	e8 95 0b 00 00       	call   10fda <Print>
	Exit(-1);
   10445:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
   1044c:	e8 33 57 00 00       	call   15b84 <Exit>

00010451 <GPF_Handler>:
{
   10451:	56                   	push   %esi
   10452:	53                   	push   %ebx
   10453:	83 ec 08             	sub    $0x8,%esp
   10456:	e8 b7 fd ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1045b:	81 c3 a5 5b 01 00    	add    $0x15ba5,%ebx
   10461:	8b 74 24 14          	mov    0x14(%esp),%esi
    Print("Exception %d received, killing thread %p\n",
   10465:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1046b:	ff 30                	pushl  (%eax)
   1046d:	ff 76 2c             	pushl  0x2c(%esi)
   10470:	8d 83 b0 72 ff ff    	lea    -0x8d50(%ebx),%eax
   10476:	50                   	push   %eax
   10477:	e8 5e 0b 00 00       	call   10fda <Print>
    Dump_Interrupt_State(state);
   1047c:	89 34 24             	mov    %esi,(%esp)
   1047f:	e8 6c fe ff ff       	call   102f0 <Dump_Interrupt_State>
    Exit(-1);
   10484:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
   1048b:	e8 f4 56 00 00       	call   15b84 <Exit>

00010490 <Init_Traps>:

/*
 * Initialize handlers for processor traps.
 */
void Init_Traps(void)
{
   10490:	56                   	push   %esi
   10491:	53                   	push   %ebx
   10492:	83 ec 0c             	sub    $0xc,%esp
   10495:	e8 78 fd ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1049a:	81 c3 66 5b 01 00    	add    $0x15b66,%ebx
    Install_Interrupt_Handler(12, &GPF_Handler);  /* stack exception */
   104a0:	8d b3 51 a4 fe ff    	lea    -0x15baf(%ebx),%esi
   104a6:	56                   	push   %esi
   104a7:	6a 0c                	push   $0xc
   104a9:	e8 f7 fc ff ff       	call   101a5 <Install_Interrupt_Handler>
    Install_Interrupt_Handler(13, &GPF_Handler);  /* general protection fault */
   104ae:	83 c4 08             	add    $0x8,%esp
   104b1:	56                   	push   %esi
   104b2:	6a 0d                	push   $0xd
   104b4:	e8 ec fc ff ff       	call   101a5 <Install_Interrupt_Handler>
    Install_Interrupt_Handler(SYSCALL_INT, &Syscall_Handler);
   104b9:	83 c4 08             	add    $0x8,%esp
   104bc:	8d 83 f1 a3 fe ff    	lea    -0x15c0f(%ebx),%eax
   104c2:	50                   	push   %eax
   104c3:	68 90 00 00 00       	push   $0x90
   104c8:	e8 d8 fc ff ff       	call   101a5 <Install_Interrupt_Handler>
}
   104cd:	83 c4 14             	add    $0x14,%esp
   104d0:	5b                   	pop    %ebx
   104d1:	5e                   	pop    %esi
   104d2:	c3                   	ret    

000104d3 <__x86.get_pc_thunk.si>:
   104d3:	8b 34 24             	mov    (%esp),%esi
   104d6:	c3                   	ret    

000104d7 <Install_IRQ>:
/*
 * Install a handler for given IRQ.
 * Note that we don't unmask the IRQ.
 */
void Install_IRQ(int irq, Interrupt_Handler handler)
{
   104d7:	53                   	push   %ebx
   104d8:	83 ec 10             	sub    $0x10,%esp
   104db:	e8 32 fd ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   104e0:	81 c3 20 5b 01 00    	add    $0x15b20,%ebx
    Install_Interrupt_Handler(irq + FIRST_EXTERNAL_INT, handler);
   104e6:	ff 74 24 1c          	pushl  0x1c(%esp)
   104ea:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   104ee:	83 c0 20             	add    $0x20,%eax
   104f1:	50                   	push   %eax
   104f2:	e8 ae fc ff ff       	call   101a5 <Install_Interrupt_Handler>
}
   104f7:	83 c4 18             	add    $0x18,%esp
   104fa:	5b                   	pop    %ebx
   104fb:	c3                   	ret    

000104fc <Get_IRQ_Mask>:
/*
 * Get current IRQ mask.  Each bit position represents
 * one of the 16 IRQ lines.
 */
ushort_t Get_IRQ_Mask(void)
{
   104fc:	e8 c5 03 00 00       	call   108c6 <__x86.get_pc_thunk.ax>
   10501:	05 ff 5a 01 00       	add    $0x15aff,%eax
    return s_irqMask;
   10506:	0f b7 80 20 00 00 00 	movzwl 0x20(%eax),%eax
}
   1050d:	c3                   	ret    

0001050e <Set_IRQ_Mask>:

/*
 * Set the IRQ mask.
 */
void Set_IRQ_Mask(ushort_t mask)
{
   1050e:	56                   	push   %esi
   1050f:	53                   	push   %ebx
   10510:	83 ec 04             	sub    $0x4,%esp
   10513:	e8 fa fc ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10518:	81 c3 e8 5a 01 00    	add    $0x15ae8,%ebx
   1051e:	8b 74 24 10          	mov    0x10(%esp),%esi
    uchar_t oldMask, newMask;

    oldMask = MASTER(s_irqMask);
    newMask = MASTER(mask);
    if (newMask != oldMask) {
   10522:	89 f0                	mov    %esi,%eax
   10524:	38 83 20 00 00 00    	cmp    %al,0x20(%ebx)
   1052a:	75 1a                	jne    10546 <Set_IRQ_Mask+0x38>
	Out_Byte(0x21, newMask);
    }

    oldMask = SLAVE(s_irqMask);
    newMask = SLAVE(mask);
   1052c:	89 f0                	mov    %esi,%eax
   1052e:	0f b6 c4             	movzbl %ah,%eax
    if (newMask != oldMask) {
   10531:	3a 83 21 00 00 00    	cmp    0x21(%ebx),%al
   10537:	75 20                	jne    10559 <Set_IRQ_Mask+0x4b>
	Out_Byte(0xA1, newMask);
    }

    s_irqMask = mask;
   10539:	66 89 b3 20 00 00 00 	mov    %si,0x20(%ebx)
}
   10540:	83 c4 04             	add    $0x4,%esp
   10543:	5b                   	pop    %ebx
   10544:	5e                   	pop    %esi
   10545:	c3                   	ret    
	Out_Byte(0x21, newMask);
   10546:	83 ec 08             	sub    $0x8,%esp
   10549:	0f b6 c0             	movzbl %al,%eax
   1054c:	50                   	push   %eax
   1054d:	6a 21                	push   $0x21
   1054f:	e8 76 03 00 00       	call   108ca <Out_Byte>
   10554:	83 c4 10             	add    $0x10,%esp
   10557:	eb d3                	jmp    1052c <Set_IRQ_Mask+0x1e>
	Out_Byte(0xA1, newMask);
   10559:	83 ec 08             	sub    $0x8,%esp
   1055c:	0f b6 c0             	movzbl %al,%eax
   1055f:	50                   	push   %eax
   10560:	68 a1 00 00 00       	push   $0xa1
   10565:	e8 60 03 00 00       	call   108ca <Out_Byte>
   1056a:	83 c4 10             	add    $0x10,%esp
   1056d:	eb ca                	jmp    10539 <Set_IRQ_Mask+0x2b>

0001056f <Enable_IRQ>:

/*
 * Enable given IRQ.
 */
void Enable_IRQ(int irq)
{
   1056f:	57                   	push   %edi
   10570:	56                   	push   %esi
   10571:	53                   	push   %ebx
   10572:	e8 9b fc ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10577:	81 c3 89 5a 01 00    	add    $0x15a89,%ebx
   1057d:	8b 7c 24 10          	mov    0x10(%esp),%edi
 * @return true if interrupts were enabled at beginning of call,
 * false otherwise.
 */
static __inline__ bool Begin_Int_Atomic(void) 
{
    bool enabled = Interrupts_Enabled();
   10581:	e8 c6 fc ff ff       	call   1024c <Interrupts_Enabled>
   10586:	89 c6                	mov    %eax,%esi
    if (enabled)
   10588:	84 c0                	test   %al,%al
   1058a:	75 4a                	jne    105d6 <Enable_IRQ+0x67>
    bool iflag = Begin_Int_Atomic();

    KASSERT(irq >= 0 && irq < 16);
   1058c:	83 ff 0f             	cmp    $0xf,%edi
   1058f:	0f 86 91 00 00 00    	jbe    10626 <Enable_IRQ+0xb7>
   10595:	83 ec 0c             	sub    $0xc,%esp
   10598:	6a 4f                	push   $0x4f
   1059a:	e8 8a 0b 00 00       	call   11129 <Set_Current_Attr>
   1059f:	83 c4 0c             	add    $0xc,%esp
   105a2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   105a8:	ff 30                	pushl  (%eax)
   105aa:	ff 74 24 14          	pushl  0x14(%esp)
   105ae:	6a 54                	push   $0x54
   105b0:	8d 83 f2 72 ff ff    	lea    -0x8d0e(%ebx),%eax
   105b6:	50                   	push   %eax
   105b7:	8d 83 06 73 ff ff    	lea    -0x8cfa(%ebx),%eax
   105bd:	50                   	push   %eax
   105be:	8d 83 4c 73 ff ff    	lea    -0x8cb4(%ebx),%eax
   105c4:	50                   	push   %eax
   105c5:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   105cb:	50                   	push   %eax
   105cc:	e8 09 0a 00 00       	call   10fda <Print>
   105d1:	83 c4 20             	add    $0x20,%esp
   105d4:	eb fe                	jmp    105d4 <Enable_IRQ+0x65>
	Disable_Interrupts();
   105d6:	e8 71 fc ff ff       	call   1024c <Interrupts_Enabled>
   105db:	84 c0                	test   %al,%al
   105dd:	74 03                	je     105e2 <Enable_IRQ+0x73>
    __asm__ __volatile__ ("cli");
   105df:	fa                   	cli    
}
   105e0:	eb aa                	jmp    1058c <Enable_IRQ+0x1d>
	Disable_Interrupts();
   105e2:	83 ec 0c             	sub    $0xc,%esp
   105e5:	6a 4f                	push   $0x4f
   105e7:	e8 3d 0b 00 00       	call   11129 <Set_Current_Attr>
   105ec:	83 c4 0c             	add    $0xc,%esp
   105ef:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   105f5:	ff 30                	pushl  (%eax)
   105f7:	ff 74 24 14          	pushl  0x14(%esp)
   105fb:	68 8f 00 00 00       	push   $0x8f
   10600:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10606:	50                   	push   %eax
   10607:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1060d:	50                   	push   %eax
   1060e:	8d 83 38 73 ff ff    	lea    -0x8cc8(%ebx),%eax
   10614:	50                   	push   %eax
   10615:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1061b:	50                   	push   %eax
   1061c:	e8 b9 09 00 00       	call   10fda <Print>
   10621:	83 c4 20             	add    $0x20,%esp
   10624:	eb fe                	jmp    10624 <Enable_IRQ+0xb5>
    ushort_t mask = Get_IRQ_Mask();
    mask &= ~(1 << irq);
    Set_IRQ_Mask(mask);
   10626:	83 ec 0c             	sub    $0xc,%esp
    mask &= ~(1 << irq);
   10629:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1062e:	89 f9                	mov    %edi,%ecx
   10630:	d3 c0                	rol    %cl,%eax
   10632:	66 23 83 20 00 00 00 	and    0x20(%ebx),%ax
    Set_IRQ_Mask(mask);
   10639:	0f b7 c0             	movzwl %ax,%eax
   1063c:	50                   	push   %eax
   1063d:	e8 cc fe ff ff       	call   1050e <Set_IRQ_Mask>
 * End interrupt-atomic region.
 * @param iflag the value returned from the original Begin_Int_Atomic() call.
 */
static __inline__ void End_Int_Atomic(bool iflag)
{
    KASSERT(!Interrupts_Enabled());
   10642:	e8 05 fc ff ff       	call   1024c <Interrupts_Enabled>
   10647:	83 c4 10             	add    $0x10,%esp
   1064a:	84 c0                	test   %al,%al
   1064c:	75 0a                	jne    10658 <Enable_IRQ+0xe9>
    if (iflag) {
   1064e:	89 f0                	mov    %esi,%eax
   10650:	84 c0                	test   %al,%al
   10652:	75 48                	jne    1069c <Enable_IRQ+0x12d>

    End_Int_Atomic(iflag);
}
   10654:	5b                   	pop    %ebx
   10655:	5e                   	pop    %esi
   10656:	5f                   	pop    %edi
   10657:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   10658:	83 ec 0c             	sub    $0xc,%esp
   1065b:	6a 4f                	push   $0x4f
   1065d:	e8 c7 0a 00 00       	call   11129 <Set_Current_Attr>
   10662:	83 c4 0c             	add    $0xc,%esp
   10665:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1066b:	ff 30                	pushl  (%eax)
   1066d:	ff 74 24 14          	pushl  0x14(%esp)
   10671:	68 99 00 00 00       	push   $0x99
   10676:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1067c:	50                   	push   %eax
   1067d:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10683:	50                   	push   %eax
   10684:	8d 83 28 73 ff ff    	lea    -0x8cd8(%ebx),%eax
   1068a:	50                   	push   %eax
   1068b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10691:	50                   	push   %eax
   10692:	e8 43 09 00 00       	call   10fda <Print>
   10697:	83 c4 20             	add    $0x20,%esp
   1069a:	eb fe                	jmp    1069a <Enable_IRQ+0x12b>
	/* Interrupts were originally enabled, so turn them back on */
	Enable_Interrupts();
   1069c:	e8 ab fb ff ff       	call   1024c <Interrupts_Enabled>
   106a1:	84 c0                	test   %al,%al
   106a3:	75 03                	jne    106a8 <Enable_IRQ+0x139>
    __asm__ __volatile__ ("sti");
   106a5:	fb                   	sti    
   106a6:	eb ac                	jmp    10654 <Enable_IRQ+0xe5>
	Enable_Interrupts();
   106a8:	83 ec 0c             	sub    $0xc,%esp
   106ab:	6a 4f                	push   $0x4f
   106ad:	e8 77 0a 00 00       	call   11129 <Set_Current_Attr>
   106b2:	83 c4 0c             	add    $0xc,%esp
   106b5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   106bb:	ff 30                	pushl  (%eax)
   106bd:	ff 74 24 14          	pushl  0x14(%esp)
   106c1:	68 9c 00 00 00       	push   $0x9c
   106c6:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   106cc:	50                   	push   %eax
   106cd:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   106d3:	50                   	push   %eax
   106d4:	8d 83 28 73 ff ff    	lea    -0x8cd8(%ebx),%eax
   106da:	50                   	push   %eax
   106db:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   106e1:	50                   	push   %eax
   106e2:	e8 f3 08 00 00       	call   10fda <Print>
   106e7:	83 c4 20             	add    $0x20,%esp
   106ea:	eb fe                	jmp    106ea <Enable_IRQ+0x17b>

000106ec <Disable_IRQ>:

/*
 * Disable given IRQ.
 */
void Disable_IRQ(int irq)
{
   106ec:	57                   	push   %edi
   106ed:	56                   	push   %esi
   106ee:	53                   	push   %ebx
   106ef:	e8 1e fb ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   106f4:	81 c3 0c 59 01 00    	add    $0x1590c,%ebx
   106fa:	8b 7c 24 10          	mov    0x10(%esp),%edi
    bool enabled = Interrupts_Enabled();
   106fe:	e8 49 fb ff ff       	call   1024c <Interrupts_Enabled>
   10703:	89 c6                	mov    %eax,%esi
    if (enabled)
   10705:	84 c0                	test   %al,%al
   10707:	75 4a                	jne    10753 <Disable_IRQ+0x67>
    bool iflag = Begin_Int_Atomic();

    KASSERT(irq >= 0 && irq < 16);
   10709:	83 ff 0f             	cmp    $0xf,%edi
   1070c:	0f 86 91 00 00 00    	jbe    107a3 <Disable_IRQ+0xb7>
   10712:	83 ec 0c             	sub    $0xc,%esp
   10715:	6a 4f                	push   $0x4f
   10717:	e8 0d 0a 00 00       	call   11129 <Set_Current_Attr>
   1071c:	83 c4 0c             	add    $0xc,%esp
   1071f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10725:	ff 30                	pushl  (%eax)
   10727:	ff 74 24 14          	pushl  0x14(%esp)
   1072b:	6a 63                	push   $0x63
   1072d:	8d 83 f2 72 ff ff    	lea    -0x8d0e(%ebx),%eax
   10733:	50                   	push   %eax
   10734:	8d 83 06 73 ff ff    	lea    -0x8cfa(%ebx),%eax
   1073a:	50                   	push   %eax
   1073b:	8d 83 1c 73 ff ff    	lea    -0x8ce4(%ebx),%eax
   10741:	50                   	push   %eax
   10742:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10748:	50                   	push   %eax
   10749:	e8 8c 08 00 00       	call   10fda <Print>
   1074e:	83 c4 20             	add    $0x20,%esp
   10751:	eb fe                	jmp    10751 <Disable_IRQ+0x65>
	Disable_Interrupts();
   10753:	e8 f4 fa ff ff       	call   1024c <Interrupts_Enabled>
   10758:	84 c0                	test   %al,%al
   1075a:	74 03                	je     1075f <Disable_IRQ+0x73>
    __asm__ __volatile__ ("cli");
   1075c:	fa                   	cli    
}
   1075d:	eb aa                	jmp    10709 <Disable_IRQ+0x1d>
	Disable_Interrupts();
   1075f:	83 ec 0c             	sub    $0xc,%esp
   10762:	6a 4f                	push   $0x4f
   10764:	e8 c0 09 00 00       	call   11129 <Set_Current_Attr>
   10769:	83 c4 0c             	add    $0xc,%esp
   1076c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10772:	ff 30                	pushl  (%eax)
   10774:	ff 74 24 14          	pushl  0x14(%esp)
   10778:	68 8f 00 00 00       	push   $0x8f
   1077d:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10783:	50                   	push   %eax
   10784:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1078a:	50                   	push   %eax
   1078b:	8d 83 38 73 ff ff    	lea    -0x8cc8(%ebx),%eax
   10791:	50                   	push   %eax
   10792:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10798:	50                   	push   %eax
   10799:	e8 3c 08 00 00       	call   10fda <Print>
   1079e:	83 c4 20             	add    $0x20,%esp
   107a1:	eb fe                	jmp    107a1 <Disable_IRQ+0xb5>
    ushort_t mask = Get_IRQ_Mask();
    mask |= (1 << irq);
    Set_IRQ_Mask(mask);
   107a3:	83 ec 0c             	sub    $0xc,%esp
    mask |= (1 << irq);
   107a6:	b8 01 00 00 00       	mov    $0x1,%eax
   107ab:	89 f9                	mov    %edi,%ecx
   107ad:	d3 e0                	shl    %cl,%eax
   107af:	66 0b 83 20 00 00 00 	or     0x20(%ebx),%ax
    Set_IRQ_Mask(mask);
   107b6:	0f b7 c0             	movzwl %ax,%eax
   107b9:	50                   	push   %eax
   107ba:	e8 4f fd ff ff       	call   1050e <Set_IRQ_Mask>
    KASSERT(!Interrupts_Enabled());
   107bf:	e8 88 fa ff ff       	call   1024c <Interrupts_Enabled>
   107c4:	83 c4 10             	add    $0x10,%esp
   107c7:	84 c0                	test   %al,%al
   107c9:	75 0a                	jne    107d5 <Disable_IRQ+0xe9>
    if (iflag) {
   107cb:	89 f0                	mov    %esi,%eax
   107cd:	84 c0                	test   %al,%al
   107cf:	75 48                	jne    10819 <Disable_IRQ+0x12d>

    End_Int_Atomic(iflag);
}
   107d1:	5b                   	pop    %ebx
   107d2:	5e                   	pop    %esi
   107d3:	5f                   	pop    %edi
   107d4:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   107d5:	83 ec 0c             	sub    $0xc,%esp
   107d8:	6a 4f                	push   $0x4f
   107da:	e8 4a 09 00 00       	call   11129 <Set_Current_Attr>
   107df:	83 c4 0c             	add    $0xc,%esp
   107e2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   107e8:	ff 30                	pushl  (%eax)
   107ea:	ff 74 24 14          	pushl  0x14(%esp)
   107ee:	68 99 00 00 00       	push   $0x99
   107f3:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   107f9:	50                   	push   %eax
   107fa:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10800:	50                   	push   %eax
   10801:	8d 83 28 73 ff ff    	lea    -0x8cd8(%ebx),%eax
   10807:	50                   	push   %eax
   10808:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1080e:	50                   	push   %eax
   1080f:	e8 c6 07 00 00       	call   10fda <Print>
   10814:	83 c4 20             	add    $0x20,%esp
   10817:	eb fe                	jmp    10817 <Disable_IRQ+0x12b>
	Enable_Interrupts();
   10819:	e8 2e fa ff ff       	call   1024c <Interrupts_Enabled>
   1081e:	84 c0                	test   %al,%al
   10820:	75 03                	jne    10825 <Disable_IRQ+0x139>
    __asm__ __volatile__ ("sti");
   10822:	fb                   	sti    
   10823:	eb ac                	jmp    107d1 <Disable_IRQ+0xe5>
	Enable_Interrupts();
   10825:	83 ec 0c             	sub    $0xc,%esp
   10828:	6a 4f                	push   $0x4f
   1082a:	e8 fa 08 00 00       	call   11129 <Set_Current_Attr>
   1082f:	83 c4 0c             	add    $0xc,%esp
   10832:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10838:	ff 30                	pushl  (%eax)
   1083a:	ff 74 24 14          	pushl  0x14(%esp)
   1083e:	68 9c 00 00 00       	push   $0x9c
   10843:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10849:	50                   	push   %eax
   1084a:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10850:	50                   	push   %eax
   10851:	8d 83 28 73 ff ff    	lea    -0x8cd8(%ebx),%eax
   10857:	50                   	push   %eax
   10858:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1085e:	50                   	push   %eax
   1085f:	e8 76 07 00 00       	call   10fda <Print>
   10864:	83 c4 20             	add    $0x20,%esp
   10867:	eb fe                	jmp    10867 <Disable_IRQ+0x17b>

00010869 <Begin_IRQ>:
 * Called by an IRQ handler to begin the interrupt.
 * Currently a no-op.
 */
void Begin_IRQ(struct Interrupt_State* state)
{
}
   10869:	c3                   	ret    

0001086a <End_IRQ>:
/*
 * Called by an IRQ handler to end the interrupt.
 * Sends an EOI command to the appropriate PIC(s).
 */
void End_IRQ(struct Interrupt_State* state)
{
   1086a:	53                   	push   %ebx
   1086b:	83 ec 08             	sub    $0x8,%esp
   1086e:	e8 9f f9 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10873:	81 c3 8d 57 01 00    	add    $0x1578d,%ebx
    int irq = state->intNum - FIRST_EXTERNAL_INT;
   10879:	8b 44 24 10          	mov    0x10(%esp),%eax
   1087d:	8b 40 2c             	mov    0x2c(%eax),%eax
   10880:	8d 50 e0             	lea    -0x20(%eax),%edx
    uchar_t command = 0x60 | (irq & 0x7);
   10883:	83 e0 07             	and    $0x7,%eax
   10886:	83 c8 60             	or     $0x60,%eax

    if (irq < 8) {
   10889:	83 fa 07             	cmp    $0x7,%edx
   1088c:	7f 16                	jg     108a4 <End_IRQ+0x3a>
	/* Specific EOI to master PIC */
	Out_Byte(0x20, command);
   1088e:	83 ec 08             	sub    $0x8,%esp
   10891:	0f b6 c0             	movzbl %al,%eax
   10894:	50                   	push   %eax
   10895:	6a 20                	push   $0x20
   10897:	e8 2e 00 00 00       	call   108ca <Out_Byte>
   1089c:	83 c4 10             	add    $0x10,%esp
    else {
	/* Specific EOI to slave PIC, then to master (cascade line) */
	Out_Byte(0xA0, command);
	Out_Byte(0x20, 0x62);
    }
}
   1089f:	83 c4 08             	add    $0x8,%esp
   108a2:	5b                   	pop    %ebx
   108a3:	c3                   	ret    
	Out_Byte(0xA0, command);
   108a4:	83 ec 08             	sub    $0x8,%esp
   108a7:	0f b6 c0             	movzbl %al,%eax
   108aa:	50                   	push   %eax
   108ab:	68 a0 00 00 00       	push   $0xa0
   108b0:	e8 15 00 00 00       	call   108ca <Out_Byte>
	Out_Byte(0x20, 0x62);
   108b5:	83 c4 08             	add    $0x8,%esp
   108b8:	6a 62                	push   $0x62
   108ba:	6a 20                	push   $0x20
   108bc:	e8 09 00 00 00       	call   108ca <Out_Byte>
   108c1:	83 c4 10             	add    $0x10,%esp
}
   108c4:	eb d9                	jmp    1089f <End_IRQ+0x35>

000108c6 <__x86.get_pc_thunk.ax>:
   108c6:	8b 04 24             	mov    (%esp),%eax
   108c9:	c3                   	ret    

000108ca <Out_Byte>:
/*
 * Write a byte to an I/O port.
 */
void Out_Byte(ushort_t port, uchar_t value)
{
    __asm__ __volatile__ (
   108ca:	8b 54 24 04          	mov    0x4(%esp),%edx
   108ce:	8b 44 24 08          	mov    0x8(%esp),%eax
   108d2:	ee                   	out    %al,(%dx)
	"outb %b0, %w1"
	:
	: "a" (value), "Nd" (port)
    );
}
   108d3:	c3                   	ret    

000108d4 <In_Byte>:
 */
uchar_t In_Byte(ushort_t port)
{
    uchar_t value;

    __asm__ __volatile__ (
   108d4:	8b 54 24 04          	mov    0x4(%esp),%edx
   108d8:	ec                   	in     (%dx),%al
	: "=a" (value)
	: "Nd" (port)
    );

    return value;
}
   108d9:	c3                   	ret    

000108da <Out_Word>:
/*
 * Write a word to an I/O port.
 */
void Out_Word(ushort_t port, ushort_t value)
{
    __asm__ __volatile__ (
   108da:	8b 54 24 04          	mov    0x4(%esp),%edx
   108de:	8b 44 24 08          	mov    0x8(%esp),%eax
   108e2:	66 ef                	out    %ax,(%dx)
	"outw %w0, %w1"
	:
	: "a" (value), "Nd" (port)
    );
}
   108e4:	c3                   	ret    

000108e5 <In_Word>:
 */
ushort_t In_Word(ushort_t port)
{
    ushort_t value;

    __asm__ __volatile__ (
   108e5:	8b 54 24 04          	mov    0x4(%esp),%edx
   108e9:	66 ed                	in     (%dx),%ax
	: "=a" (value)
	: "Nd" (port)
    );

    return value;
}
   108eb:	c3                   	ret    

000108ec <IO_Delay>:
 * (slow) I/O devices.
 */
void IO_Delay(void)
{
    uchar_t value = 0;
    __asm__ __volatile__ (
   108ec:	b8 00 00 00 00       	mov    $0x0,%eax
   108f1:	e6 80                	out    %al,$0x80
	"outb %0, $0x80"
	:
	: "a" (value)
    );
}
   108f3:	c3                   	ret    

000108f4 <Keyboard_Interrupt_Handler>:

/*
 * Handler for keyboard interrupts.
 */
static void Keyboard_Interrupt_Handler(struct Interrupt_State* state)
{
   108f4:	57                   	push   %edi
   108f5:	56                   	push   %esi
   108f6:	53                   	push   %ebx
   108f7:	e8 16 f9 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   108fc:	81 c3 04 57 01 00    	add    $0x15704,%ebx
   10902:	8b 7c 24 10          	mov    0x10(%esp),%edi
    uchar_t status, scanCode;
    unsigned flag = 0;
    bool release = false, shift;
    Keycode keycode;

    Begin_IRQ(state);
   10906:	83 ec 0c             	sub    $0xc,%esp
   10909:	57                   	push   %edi
   1090a:	e8 5a ff ff ff       	call   10869 <Begin_IRQ>

    status = In_Byte(KB_CMD);
   1090f:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
   10916:	e8 b9 ff ff ff       	call   108d4 <In_Byte>
   1091b:	89 c6                	mov    %eax,%esi
    IO_Delay();
   1091d:	e8 ca ff ff ff       	call   108ec <IO_Delay>

    if ((status & KB_OUTPUT_FULL) != 0) {
   10922:	83 c4 10             	add    $0x10,%esp
   10925:	f7 c6 01 00 00 00    	test   $0x1,%esi
   1092b:	75 10                	jne    1093d <Keyboard_Interrupt_Handler+0x49>
	 */
	g_needReschedule = true;
    }

done:
    End_IRQ(state);
   1092d:	83 ec 0c             	sub    $0xc,%esp
   10930:	57                   	push   %edi
   10931:	e8 34 ff ff ff       	call   1086a <End_IRQ>
}
   10936:	83 c4 10             	add    $0x10,%esp
   10939:	5b                   	pop    %ebx
   1093a:	5e                   	pop    %esi
   1093b:	5f                   	pop    %edi
   1093c:	c3                   	ret    
	scanCode = In_Byte(KB_DATA);
   1093d:	83 ec 0c             	sub    $0xc,%esp
   10940:	6a 60                	push   $0x60
   10942:	e8 8d ff ff ff       	call   108d4 <In_Byte>
   10947:	89 c6                	mov    %eax,%esi
	IO_Delay();
   10949:	e8 9e ff ff ff       	call   108ec <IO_Delay>
	if (scanCode & KB_KEY_RELEASE) {
   1094e:	83 c4 10             	add    $0x10,%esp
    bool release = false, shift;
   10951:	b9 00 00 00 00       	mov    $0x0,%ecx
	if (scanCode & KB_KEY_RELEASE) {
   10956:	89 f0                	mov    %esi,%eax
   10958:	84 c0                	test   %al,%al
   1095a:	78 3a                	js     10996 <Keyboard_Interrupt_Handler+0xa2>
	if (scanCode >= SCAN_TABLE_SIZE) {
   1095c:	89 f0                	mov    %esi,%eax
   1095e:	3c 57                	cmp    $0x57,%al
   10960:	77 3e                	ja     109a0 <Keyboard_Interrupt_Handler+0xac>
	shift = ((s_shiftState & SHIFT_MASK) != 0);
   10962:	8b 93 20 0b 00 00    	mov    0xb20(%ebx),%edx
	keycode = shift ? s_scanTableWithShift[scanCode] : s_scanTableNoShift[scanCode];
   10968:	f6 c2 03             	test   $0x3,%dl
   1096b:	74 72                	je     109df <.L11+0x7>
   1096d:	0f b6 f0             	movzbl %al,%esi
   10970:	0f b7 84 73 00 74 ff 	movzwl -0x8c00(%ebx,%esi,2),%eax
   10977:	ff 
	switch (keycode) {
   10978:	8d b0 f3 fe ff ff    	lea    -0x10d(%eax),%esi
   1097e:	66 83 fe 05          	cmp    $0x5,%si
   10982:	0f 87 c8 00 00 00    	ja     10a50 <.L28+0xa>
   10988:	0f b7 f6             	movzwl %si,%esi
   1098b:	89 d8                	mov    %ebx,%eax
   1098d:	03 84 b3 a0 73 ff ff 	add    -0x8c60(%ebx,%esi,4),%eax
   10994:	ff e0                	jmp    *%eax
	    scanCode &= ~(KB_KEY_RELEASE);
   10996:	83 e6 7f             	and    $0x7f,%esi
	    release = true;
   10999:	b9 01 00 00 00       	mov    $0x1,%ecx
   1099e:	eb bc                	jmp    1095c <Keyboard_Interrupt_Handler+0x68>
	    Print("Unknown scan code: %x\n", scanCode);
   109a0:	83 ec 08             	sub    $0x8,%esp
   109a3:	0f b6 f0             	movzbl %al,%esi
   109a6:	56                   	push   %esi
   109a7:	8d 83 57 73 ff ff    	lea    -0x8ca9(%ebx),%eax
   109ad:	50                   	push   %eax
   109ae:	e8 27 06 00 00       	call   10fda <Print>
	    goto done;
   109b3:	83 c4 10             	add    $0x10,%esp
   109b6:	e9 72 ff ff ff       	jmp    1092d <Keyboard_Interrupt_Handler+0x39>

000109bb <.L13>:
	keycode = shift ? s_scanTableWithShift[scanCode] : s_scanTableNoShift[scanCode];
   109bb:	b8 04 00 00 00       	mov    $0x4,%eax
	    s_shiftState &= ~(flag);
   109c0:	89 d6                	mov    %edx,%esi
   109c2:	09 c6                	or     %eax,%esi
   109c4:	f7 d0                	not    %eax
   109c6:	21 d0                	and    %edx,%eax
   109c8:	84 c9                	test   %cl,%cl
   109ca:	0f 44 c6             	cmove  %esi,%eax
   109cd:	89 83 20 0b 00 00    	mov    %eax,0xb20(%ebx)
   109d3:	e9 55 ff ff ff       	jmp    1092d <Keyboard_Interrupt_Handler+0x39>

000109d8 <.L11>:
	    flag = LEFT_SHIFT;
   109d8:	b8 01 00 00 00       	mov    $0x1,%eax
   109dd:	eb e1                	jmp    109c0 <.L13+0x5>
	keycode = shift ? s_scanTableWithShift[scanCode] : s_scanTableNoShift[scanCode];
   109df:	0f b6 f0             	movzbl %al,%esi
   109e2:	0f b7 84 73 c0 74 ff 	movzwl -0x8b40(%ebx,%esi,2),%eax
   109e9:	ff 
	switch (keycode) {
   109ea:	8d b0 f3 fe ff ff    	lea    -0x10d(%eax),%esi
   109f0:	66 83 fe 05          	cmp    $0x5,%si
   109f4:	77 5d                	ja     10a53 <.L28+0xd>
   109f6:	0f b7 f6             	movzwl %si,%esi
   109f9:	89 d8                	mov    %ebx,%eax
   109fb:	03 84 b3 b8 73 ff ff 	add    -0x8c48(%ebx,%esi,4),%eax
   10a02:	ff e0                	jmp    *%eax

00010a04 <.L20>:
	keycode = shift ? s_scanTableWithShift[scanCode] : s_scanTableNoShift[scanCode];
   10a04:	b8 04 00 00 00       	mov    $0x4,%eax
   10a09:	eb b5                	jmp    109c0 <.L13+0x5>

00010a0b <.L16>:
	    flag = LEFT_ALT;
   10a0b:	b8 10 00 00 00       	mov    $0x10,%eax
   10a10:	eb ae                	jmp    109c0 <.L13+0x5>

00010a12 <.L18>:
	    flag = LEFT_SHIFT;
   10a12:	b8 01 00 00 00       	mov    $0x1,%eax
   10a17:	eb a7                	jmp    109c0 <.L13+0x5>

00010a19 <.L19>:
	    flag = RIGHT_CTRL;
   10a19:	b8 08 00 00 00       	mov    $0x8,%eax
   10a1e:	eb a0                	jmp    109c0 <.L13+0x5>

00010a20 <.L17>:
	    flag = RIGHT_SHIFT;
   10a20:	b8 02 00 00 00       	mov    $0x2,%eax
   10a25:	eb 99                	jmp    109c0 <.L13+0x5>

00010a27 <.L12>:
	    flag = RIGHT_CTRL;
   10a27:	b8 08 00 00 00       	mov    $0x8,%eax
   10a2c:	eb 92                	jmp    109c0 <.L13+0x5>

00010a2e <.L9>:
	    flag = LEFT_ALT;
   10a2e:	b8 10 00 00 00       	mov    $0x10,%eax
   10a33:	eb 8b                	jmp    109c0 <.L13+0x5>

00010a35 <.L7>:
	    flag = RIGHT_ALT;
   10a35:	b8 20 00 00 00       	mov    $0x20,%eax
   10a3a:	eb 84                	jmp    109c0 <.L13+0x5>

00010a3c <.L27>:
	    flag = RIGHT_SHIFT;
   10a3c:	b8 02 00 00 00       	mov    $0x2,%eax
   10a41:	e9 7a ff ff ff       	jmp    109c0 <.L13+0x5>

00010a46 <.L28>:
	    flag = RIGHT_ALT;
   10a46:	b8 20 00 00 00       	mov    $0x20,%eax
   10a4b:	e9 70 ff ff ff       	jmp    109c0 <.L13+0x5>
	    keycode |= KEY_SHIFT_FLAG;
   10a50:	80 cc 10             	or     $0x10,%ah
	    keycode |= KEY_CTRL_FLAG;
   10a53:	89 c6                	mov    %eax,%esi
   10a55:	66 81 ce 00 40       	or     $0x4000,%si
   10a5a:	f6 c2 0c             	test   $0xc,%dl
   10a5d:	0f 45 c6             	cmovne %esi,%eax
	    keycode |= KEY_ALT_FLAG;
   10a60:	89 c6                	mov    %eax,%esi
   10a62:	66 81 ce 00 20       	or     $0x2000,%si
   10a67:	f6 c2 30             	test   $0x30,%dl
   10a6a:	0f 45 c6             	cmovne %esi,%eax
	    keycode |= KEY_RELEASE_FLAG;
   10a6d:	89 c2                	mov    %eax,%edx
   10a6f:	66 81 ca 00 80       	or     $0x8000,%dx
   10a74:	84 c9                	test   %cl,%cl
   10a76:	0f 45 c2             	cmovne %edx,%eax
    return NEXT(s_queueTail) == s_queueHead;
   10a79:	8b 8b 08 09 00 00    	mov    0x908(%ebx),%ecx
   10a7f:	8d 51 01             	lea    0x1(%ecx),%edx
   10a82:	0f b6 d2             	movzbl %dl,%edx
    if (!Is_Queue_Full()) {
   10a85:	3b 93 0c 09 00 00    	cmp    0x90c(%ebx),%edx
   10a8b:	74 0e                	je     10a9b <.L28+0x55>
	s_queue[ s_queueTail ] = keycode;
   10a8d:	66 89 84 4b 20 09 00 	mov    %ax,0x920(%ebx,%ecx,2)
   10a94:	00 
	s_queueTail = NEXT(s_queueTail);
   10a95:	89 93 08 09 00 00    	mov    %edx,0x908(%ebx)
	Wake_Up(&s_waitQueue);
   10a9b:	83 ec 0c             	sub    $0xc,%esp
   10a9e:	8d 83 00 09 00 00    	lea    0x900(%ebx),%eax
   10aa4:	50                   	push   %eax
   10aa5:	e8 28 4d 00 00       	call   157d2 <Wake_Up>
	g_needReschedule = true;
   10aaa:	c7 c0 94 77 02 00    	mov    $0x27794,%eax
   10ab0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
   10ab6:	83 c4 10             	add    $0x10,%esp
   10ab9:	e9 6f fe ff ff       	jmp    1092d <Keyboard_Interrupt_Handler+0x39>

00010abe <Init_Keyboard>:
/* ----------------------------------------------------------------------
 * Public functions
 * ---------------------------------------------------------------------- */

void Init_Keyboard(void)
{
   10abe:	53                   	push   %ebx
   10abf:	83 ec 14             	sub    $0x14,%esp
   10ac2:	e8 4b f7 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10ac7:	81 c3 39 55 01 00    	add    $0x15539,%ebx
    ushort_t irqMask;

    Print("Initializing keyboard...\n");
   10acd:	8d 83 6e 73 ff ff    	lea    -0x8c92(%ebx),%eax
   10ad3:	50                   	push   %eax
   10ad4:	e8 01 05 00 00       	call   10fda <Print>

    /* Start out with no shift keys enabled. */
    s_shiftState = 0;
   10ad9:	c7 83 20 0b 00 00 00 	movl   $0x0,0xb20(%ebx)
   10ae0:	00 00 00 

    /* Buffer is initially empty. */
    s_queueHead = s_queueTail = 0;
   10ae3:	c7 83 08 09 00 00 00 	movl   $0x0,0x908(%ebx)
   10aea:	00 00 00 
   10aed:	c7 83 0c 09 00 00 00 	movl   $0x0,0x90c(%ebx)
   10af4:	00 00 00 

    /* Install interrupt handler */
    Install_IRQ(KB_IRQ, Keyboard_Interrupt_Handler);
   10af7:	83 c4 08             	add    $0x8,%esp
   10afa:	8d 83 f4 a8 fe ff    	lea    -0x1570c(%ebx),%eax
   10b00:	50                   	push   %eax
   10b01:	6a 01                	push   $0x1
   10b03:	e8 cf f9 ff ff       	call   104d7 <Install_IRQ>

    /* Enable IRQ1 (keyboard) */
    irqMask = Get_IRQ_Mask();
   10b08:	e8 ef f9 ff ff       	call   104fc <Get_IRQ_Mask>
    irqMask &= ~(1 << KB_IRQ);
    Set_IRQ_Mask(irqMask);
   10b0d:	25 fd ff 00 00       	and    $0xfffd,%eax
   10b12:	89 04 24             	mov    %eax,(%esp)
   10b15:	e8 f4 f9 ff ff       	call   1050e <Set_IRQ_Mask>
}
   10b1a:	83 c4 18             	add    $0x18,%esp
   10b1d:	5b                   	pop    %ebx
   10b1e:	c3                   	ret    

00010b1f <Read_Key>:
 * false if not.  If a key event is available,
 * it will be stored in the location pointed to
 * by keycode.
 */
bool Read_Key(Keycode* keycode)
{
   10b1f:	55                   	push   %ebp
   10b20:	57                   	push   %edi
   10b21:	56                   	push   %esi
   10b22:	53                   	push   %ebx
   10b23:	83 ec 0c             	sub    $0xc,%esp
   10b26:	e8 e7 f6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10b2b:	81 c3 d5 54 01 00    	add    $0x154d5,%ebx
    bool enabled = Interrupts_Enabled();
   10b31:	e8 16 f7 ff ff       	call   1024c <Interrupts_Enabled>
   10b36:	89 c6                	mov    %eax,%esi
    if (enabled)
   10b38:	84 c0                	test   %al,%al
   10b3a:	75 34                	jne    10b70 <Read_Key+0x51>
    return s_queueHead == s_queueTail;
   10b3c:	8b bb 0c 09 00 00    	mov    0x90c(%ebx),%edi
   10b42:	8b ab 08 09 00 00    	mov    0x908(%ebx),%ebp
    bool result, iflag;

    iflag = Begin_Int_Atomic();

    result = !Is_Queue_Empty();
    if (result) {
   10b48:	39 ef                	cmp    %ebp,%edi
   10b4a:	75 74                	jne    10bc0 <Read_Key+0xa1>
    KASSERT(!Interrupts_Enabled());
   10b4c:	e8 fb f6 ff ff       	call   1024c <Interrupts_Enabled>
   10b51:	84 c0                	test   %al,%al
   10b53:	0f 85 89 00 00 00    	jne    10be2 <Read_Key+0xc3>
    if (iflag) {
   10b59:	89 f0                	mov    %esi,%eax
   10b5b:	84 c0                	test   %al,%al
   10b5d:	0f 85 c3 00 00 00    	jne    10c26 <Read_Key+0x107>
    result = !Is_Queue_Empty();
   10b63:	39 ef                	cmp    %ebp,%edi
   10b65:	0f 95 c0             	setne  %al
    }

    End_Int_Atomic(iflag);

    return result;
}
   10b68:	83 c4 0c             	add    $0xc,%esp
   10b6b:	5b                   	pop    %ebx
   10b6c:	5e                   	pop    %esi
   10b6d:	5f                   	pop    %edi
   10b6e:	5d                   	pop    %ebp
   10b6f:	c3                   	ret    
	Disable_Interrupts();
   10b70:	e8 d7 f6 ff ff       	call   1024c <Interrupts_Enabled>
   10b75:	84 c0                	test   %al,%al
   10b77:	74 03                	je     10b7c <Read_Key+0x5d>
    __asm__ __volatile__ ("cli");
   10b79:	fa                   	cli    
}
   10b7a:	eb c0                	jmp    10b3c <Read_Key+0x1d>
	Disable_Interrupts();
   10b7c:	83 ec 0c             	sub    $0xc,%esp
   10b7f:	6a 4f                	push   $0x4f
   10b81:	e8 a3 05 00 00       	call   11129 <Set_Current_Attr>
   10b86:	83 c4 0c             	add    $0xc,%esp
   10b89:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10b8f:	ff 30                	pushl  (%eax)
   10b91:	ff 74 24 24          	pushl  0x24(%esp)
   10b95:	68 8f 00 00 00       	push   $0x8f
   10b9a:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10ba0:	50                   	push   %eax
   10ba1:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   10ba7:	50                   	push   %eax
   10ba8:	8d 83 e0 73 ff ff    	lea    -0x8c20(%ebx),%eax
   10bae:	50                   	push   %eax
   10baf:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10bb5:	50                   	push   %eax
   10bb6:	e8 1f 04 00 00       	call   10fda <Print>
   10bbb:	83 c4 20             	add    $0x20,%esp
   10bbe:	eb fe                	jmp    10bbe <Read_Key+0x9f>
    result = s_queue[ s_queueHead ];
   10bc0:	0f b7 94 7b 20 09 00 	movzwl 0x920(%ebx,%edi,2),%edx
   10bc7:	00 
    s_queueHead = NEXT(s_queueHead);
   10bc8:	8d 47 01             	lea    0x1(%edi),%eax
   10bcb:	25 ff 00 00 00       	and    $0xff,%eax
   10bd0:	89 83 0c 09 00 00    	mov    %eax,0x90c(%ebx)
	*keycode = Dequeue_Keycode();
   10bd6:	8b 44 24 20          	mov    0x20(%esp),%eax
   10bda:	66 89 10             	mov    %dx,(%eax)
   10bdd:	e9 6a ff ff ff       	jmp    10b4c <Read_Key+0x2d>
    KASSERT(!Interrupts_Enabled());
   10be2:	83 ec 0c             	sub    $0xc,%esp
   10be5:	6a 4f                	push   $0x4f
   10be7:	e8 3d 05 00 00       	call   11129 <Set_Current_Attr>
   10bec:	83 c4 0c             	add    $0xc,%esp
   10bef:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10bf5:	ff 30                	pushl  (%eax)
   10bf7:	ff 74 24 24          	pushl  0x24(%esp)
   10bfb:	68 99 00 00 00       	push   $0x99
   10c00:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10c06:	50                   	push   %eax
   10c07:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10c0d:	50                   	push   %eax
   10c0e:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
   10c14:	50                   	push   %eax
   10c15:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10c1b:	50                   	push   %eax
   10c1c:	e8 b9 03 00 00       	call   10fda <Print>
   10c21:	83 c4 20             	add    $0x20,%esp
   10c24:	eb fe                	jmp    10c24 <Read_Key+0x105>
	Enable_Interrupts();
   10c26:	e8 21 f6 ff ff       	call   1024c <Interrupts_Enabled>
   10c2b:	84 c0                	test   %al,%al
   10c2d:	75 06                	jne    10c35 <Read_Key+0x116>
    __asm__ __volatile__ ("sti");
   10c2f:	fb                   	sti    
}
   10c30:	e9 2e ff ff ff       	jmp    10b63 <Read_Key+0x44>
	Enable_Interrupts();
   10c35:	83 ec 0c             	sub    $0xc,%esp
   10c38:	6a 4f                	push   $0x4f
   10c3a:	e8 ea 04 00 00       	call   11129 <Set_Current_Attr>
   10c3f:	83 c4 0c             	add    $0xc,%esp
   10c42:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10c48:	ff 30                	pushl  (%eax)
   10c4a:	ff 74 24 24          	pushl  0x24(%esp)
   10c4e:	68 9c 00 00 00       	push   $0x9c
   10c53:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10c59:	50                   	push   %eax
   10c5a:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10c60:	50                   	push   %eax
   10c61:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
   10c67:	50                   	push   %eax
   10c68:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10c6e:	50                   	push   %eax
   10c6f:	e8 66 03 00 00       	call   10fda <Print>
   10c74:	83 c4 20             	add    $0x20,%esp
   10c77:	eb fe                	jmp    10c77 <Read_Key+0x158>

00010c79 <Wait_For_Key>:
 * Wait for a keycode to arrive.
 * Uses the keyboard wait queue to sleep until
 * a keycode arrives.
 */
Keycode Wait_For_Key(void)
{
   10c79:	57                   	push   %edi
   10c7a:	56                   	push   %esi
   10c7b:	53                   	push   %ebx
   10c7c:	e8 91 f5 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10c81:	81 c3 7f 53 01 00    	add    $0x1537f,%ebx
    bool enabled = Interrupts_Enabled();
   10c87:	e8 c0 f5 ff ff       	call   1024c <Interrupts_Enabled>
   10c8c:	89 c6                	mov    %eax,%esi
    if (enabled)
   10c8e:	84 c0                	test   %al,%al
   10c90:	75 08                	jne    10c9a <Wait_For_Key+0x21>
    do {
	gotKey = !Is_Queue_Empty();
	if (gotKey)
	    keycode = Dequeue_Keycode();
	else
	    Wait(&s_waitQueue);
   10c92:	8d bb 00 09 00 00    	lea    0x900(%ebx),%edi
   10c98:	eb 5c                	jmp    10cf6 <Wait_For_Key+0x7d>
	Disable_Interrupts();
   10c9a:	e8 ad f5 ff ff       	call   1024c <Interrupts_Enabled>
   10c9f:	84 c0                	test   %al,%al
   10ca1:	74 03                	je     10ca6 <Wait_For_Key+0x2d>
    __asm__ __volatile__ ("cli");
   10ca3:	fa                   	cli    
}
   10ca4:	eb ec                	jmp    10c92 <Wait_For_Key+0x19>
	Disable_Interrupts();
   10ca6:	83 ec 0c             	sub    $0xc,%esp
   10ca9:	6a 4f                	push   $0x4f
   10cab:	e8 79 04 00 00       	call   11129 <Set_Current_Attr>
   10cb0:	83 c4 0c             	add    $0xc,%esp
   10cb3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10cb9:	ff 30                	pushl  (%eax)
   10cbb:	ff 74 24 14          	pushl  0x14(%esp)
   10cbf:	68 8f 00 00 00       	push   $0x8f
   10cc4:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10cca:	50                   	push   %eax
   10ccb:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   10cd1:	50                   	push   %eax
   10cd2:	8d 83 e0 73 ff ff    	lea    -0x8c20(%ebx),%eax
   10cd8:	50                   	push   %eax
   10cd9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10cdf:	50                   	push   %eax
   10ce0:	e8 f5 02 00 00       	call   10fda <Print>
   10ce5:	83 c4 20             	add    $0x20,%esp
   10ce8:	eb fe                	jmp    10ce8 <Wait_For_Key+0x6f>
   10cea:	83 ec 0c             	sub    $0xc,%esp
   10ced:	57                   	push   %edi
   10cee:	e8 64 47 00 00       	call   15457 <Wait>
   10cf3:	83 c4 10             	add    $0x10,%esp
    return s_queueHead == s_queueTail;
   10cf6:	8b 83 0c 09 00 00    	mov    0x90c(%ebx),%eax
	if (gotKey)
   10cfc:	3b 83 08 09 00 00    	cmp    0x908(%ebx),%eax
   10d02:	74 e6                	je     10cea <Wait_For_Key+0x71>
    result = s_queue[ s_queueHead ];
   10d04:	0f b7 bc 43 20 09 00 	movzwl 0x920(%ebx,%eax,2),%edi
   10d0b:	00 
    s_queueHead = NEXT(s_queueHead);
   10d0c:	83 c0 01             	add    $0x1,%eax
   10d0f:	25 ff 00 00 00       	and    $0xff,%eax
   10d14:	89 83 0c 09 00 00    	mov    %eax,0x90c(%ebx)
    KASSERT(!Interrupts_Enabled());
   10d1a:	e8 2d f5 ff ff       	call   1024c <Interrupts_Enabled>
   10d1f:	84 c0                	test   %al,%al
   10d21:	75 0c                	jne    10d2f <Wait_For_Key+0xb6>
    if (iflag) {
   10d23:	89 f0                	mov    %esi,%eax
   10d25:	84 c0                	test   %al,%al
   10d27:	75 4a                	jne    10d73 <Wait_For_Key+0xfa>
    while (!gotKey);

    End_Int_Atomic(iflag);

    return keycode;
}
   10d29:	89 f8                	mov    %edi,%eax
   10d2b:	5b                   	pop    %ebx
   10d2c:	5e                   	pop    %esi
   10d2d:	5f                   	pop    %edi
   10d2e:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   10d2f:	83 ec 0c             	sub    $0xc,%esp
   10d32:	6a 4f                	push   $0x4f
   10d34:	e8 f0 03 00 00       	call   11129 <Set_Current_Attr>
   10d39:	83 c4 0c             	add    $0xc,%esp
   10d3c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10d42:	ff 30                	pushl  (%eax)
   10d44:	ff 74 24 14          	pushl  0x14(%esp)
   10d48:	68 99 00 00 00       	push   $0x99
   10d4d:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10d53:	50                   	push   %eax
   10d54:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10d5a:	50                   	push   %eax
   10d5b:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
   10d61:	50                   	push   %eax
   10d62:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10d68:	50                   	push   %eax
   10d69:	e8 6c 02 00 00       	call   10fda <Print>
   10d6e:	83 c4 20             	add    $0x20,%esp
   10d71:	eb fe                	jmp    10d71 <Wait_For_Key+0xf8>
	Enable_Interrupts();
   10d73:	e8 d4 f4 ff ff       	call   1024c <Interrupts_Enabled>
   10d78:	84 c0                	test   %al,%al
   10d7a:	75 03                	jne    10d7f <Wait_For_Key+0x106>
    __asm__ __volatile__ ("sti");
   10d7c:	fb                   	sti    
    return keycode;
   10d7d:	eb aa                	jmp    10d29 <Wait_For_Key+0xb0>
	Enable_Interrupts();
   10d7f:	83 ec 0c             	sub    $0xc,%esp
   10d82:	6a 4f                	push   $0x4f
   10d84:	e8 a0 03 00 00       	call   11129 <Set_Current_Attr>
   10d89:	83 c4 0c             	add    $0xc,%esp
   10d8c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   10d92:	ff 30                	pushl  (%eax)
   10d94:	ff 74 24 14          	pushl  0x14(%esp)
   10d98:	68 9c 00 00 00       	push   $0x9c
   10d9d:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   10da3:	50                   	push   %eax
   10da4:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   10daa:	50                   	push   %eax
   10dab:	8d 83 d0 73 ff ff    	lea    -0x8c30(%ebx),%eax
   10db1:	50                   	push   %eax
   10db2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   10db8:	50                   	push   %eax
   10db9:	e8 1c 02 00 00       	call   10fda <Print>
   10dbe:	83 c4 20             	add    $0x20,%esp
   10dc1:	eb fe                	jmp    10dc1 <Wait_For_Key+0x148>

00010dc3 <Clear_To_EOL>:
/*
 * Clear current cursor position to end of line using
 * current attribute.
 */
static void Clear_To_EOL(void)
{
   10dc3:	56                   	push   %esi
   10dc4:	53                   	push   %ebx
   10dc5:	e8 09 f7 ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   10dca:	81 c6 36 52 01 00    	add    $0x15236,%esi
    int n = (NUMCOLS - s_cons.col);
   10dd0:	8b 9e 44 0b 00 00    	mov    0xb44(%esi),%ebx
    uchar_t* v = VIDMEM + s_cons.row*(NUMCOLS*2) + s_cons.col*2;
   10dd6:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
   10ddc:	8d 04 80             	lea    (%eax,%eax,4),%eax
   10ddf:	c1 e0 05             	shl    $0x5,%eax
   10de2:	8d 84 58 00 80 0b 00 	lea    0xb8000(%eax,%ebx,2),%eax
    while (n-- > 0) {
   10de9:	ba 4f 00 00 00       	mov    $0x4f,%edx
   10dee:	29 da                	sub    %ebx,%edx
    int n = (NUMCOLS - s_cons.col);
   10df0:	b9 50 00 00 00       	mov    $0x50,%ecx
   10df5:	29 d9                	sub    %ebx,%ecx
    while (n-- > 0) {
   10df7:	85 c9                	test   %ecx,%ecx
   10df9:	7e 19                	jle    10e14 <Clear_To_EOL+0x51>
	*v++ = ' ';
	*v++ = s_cons.currentAttr;
   10dfb:	0f b6 9e 50 0b 00 00 	movzbl 0xb50(%esi),%ebx
	*v++ = ' ';
   10e02:	c6 00 20             	movb   $0x20,(%eax)
	*v++ = s_cons.currentAttr;
   10e05:	83 c0 02             	add    $0x2,%eax
   10e08:	88 58 ff             	mov    %bl,-0x1(%eax)
    while (n-- > 0) {
   10e0b:	89 d1                	mov    %edx,%ecx
   10e0d:	83 ea 01             	sub    $0x1,%edx
   10e10:	85 c9                	test   %ecx,%ecx
   10e12:	7f ee                	jg     10e02 <Clear_To_EOL+0x3f>
    }
}
   10e14:	5b                   	pop    %ebx
   10e15:	5e                   	pop    %esi
   10e16:	c3                   	ret    

00010e17 <Newline>:
/*
 * Move to the beginning of the next line, scrolling
 * if necessary.
 */
static void Newline(void)
{
   10e17:	e8 c7 11 00 00       	call   11fe3 <__x86.get_pc_thunk.dx>
   10e1c:	81 c2 e4 51 01 00    	add    $0x151e4,%edx
    ++s_cons.row;
   10e22:	8b 82 40 0b 00 00    	mov    0xb40(%edx),%eax
   10e28:	83 c0 01             	add    $0x1,%eax
   10e2b:	89 82 40 0b 00 00    	mov    %eax,0xb40(%edx)
    s_cons.col = 0;
   10e31:	c7 82 44 0b 00 00 00 	movl   $0x0,0xb44(%edx)
   10e38:	00 00 00 
    if (s_cons.row == NUMROWS) {
   10e3b:	83 f8 19             	cmp    $0x19,%eax
   10e3e:	74 01                	je     10e41 <Newline+0x2a>
   10e40:	c3                   	ret    
{
   10e41:	53                   	push   %ebx
    uint_t fill = FILL_DWORD;
   10e42:	0f b6 82 50 0b 00 00 	movzbl 0xb50(%edx),%eax
   10e49:	89 c1                	mov    %eax,%ecx
   10e4b:	c1 e1 18             	shl    $0x18,%ecx
   10e4e:	c1 e0 08             	shl    $0x8,%eax
   10e51:	09 c1                	or     %eax,%ecx
   10e53:	81 c9 20 00 20 00    	or     $0x200020,%ecx
    for (v = (uint_t*)VIDMEM, i = 0; i < n; ++i) {
   10e59:	b8 00 80 0b 00       	mov    $0xb8000,%eax
	*v = *(v + NUM_DWORDS_PER_LINE);
   10e5e:	8b 98 a0 00 00 00    	mov    0xa0(%eax),%ebx
   10e64:	89 18                	mov    %ebx,(%eax)
	++v;
   10e66:	83 c0 04             	add    $0x4,%eax
    for (v = (uint_t*)VIDMEM, i = 0; i < n; ++i) {
   10e69:	3d 00 8f 0b 00       	cmp    $0xb8f00,%eax
   10e6e:	75 ee                	jne    10e5e <Newline+0x47>
	*v++ = fill;
   10e70:	89 c3                	mov    %eax,%ebx
   10e72:	83 c0 04             	add    $0x4,%eax
   10e75:	89 0b                	mov    %ecx,(%ebx)
    for (v = (uint_t*)VIDMEM + n, i = 0; i < NUM_DWORDS_PER_LINE; ++i)
   10e77:	3d a0 8f 0b 00       	cmp    $0xb8fa0,%eax
   10e7c:	75 f2                	jne    10e70 <Newline+0x59>
	Scroll();
	s_cons.row = NUMROWS - 1;
   10e7e:	c7 82 40 0b 00 00 18 	movl   $0x18,0xb40(%edx)
   10e85:	00 00 00 
    }
}
   10e88:	5b                   	pop    %ebx
   10e89:	c3                   	ret    

00010e8a <Put_Graphic_Char>:
 * Write the graphic representation of given character to the screen
 * at current position, with current attribute, scrolling if
 * necessary.
 */
static void Put_Graphic_Char(int c)
{
   10e8a:	53                   	push   %ebx
   10e8b:	e8 53 11 00 00       	call   11fe3 <__x86.get_pc_thunk.dx>
   10e90:	81 c2 70 51 01 00    	add    $0x15170,%edx
   10e96:	89 c3                	mov    %eax,%ebx
    uchar_t* v = VIDMEM + s_cons.row*(NUMCOLS*2) + s_cons.col*2;
   10e98:	8b 82 44 0b 00 00    	mov    0xb44(%edx),%eax
   10e9e:	8b 8a 40 0b 00 00    	mov    0xb40(%edx),%ecx
   10ea4:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
   10ea7:	c1 e1 05             	shl    $0x5,%ecx
   10eaa:	8d 0c 41             	lea    (%ecx,%eax,2),%ecx

    /* Put character at current position */
    *v++ = (uchar_t) c;
   10ead:	88 99 00 80 0b 00    	mov    %bl,0xb8000(%ecx)
    *v = s_cons.currentAttr;
   10eb3:	0f b6 9a 50 0b 00 00 	movzbl 0xb50(%edx),%ebx
   10eba:	88 99 01 80 0b 00    	mov    %bl,0xb8001(%ecx)

    if (s_cons.col < NUMCOLS - 1)
   10ec0:	83 f8 4e             	cmp    $0x4e,%eax
   10ec3:	7f 0b                	jg     10ed0 <Put_Graphic_Char+0x46>
	++s_cons.col;
   10ec5:	83 c0 01             	add    $0x1,%eax
   10ec8:	89 82 44 0b 00 00    	mov    %eax,0xb44(%edx)
    else
	Newline();
}
   10ece:	5b                   	pop    %ebx
   10ecf:	c3                   	ret    
	Newline();
   10ed0:	e8 42 ff ff ff       	call   10e17 <Newline>
}
   10ed5:	eb f7                	jmp    10ece <Put_Graphic_Char+0x44>

00010ed7 <Move_Cursor>:

/*
 * Move the cursor to a new position, stopping at the screen borders.
 */
static void Move_Cursor(int row, int col)
{
   10ed7:	53                   	push   %ebx
   10ed8:	e8 0a 11 00 00       	call   11fe7 <__x86.get_pc_thunk.cx>
   10edd:	81 c1 23 51 01 00    	add    $0x15123,%ecx
    if (row < 0)
   10ee3:	83 f8 18             	cmp    $0x18,%eax
   10ee6:	bb 18 00 00 00       	mov    $0x18,%ebx
   10eeb:	0f 4f c3             	cmovg  %ebx,%eax
	row = 0;
    else if (row >= NUMROWS)
	row = NUMROWS - 1;

    if (col < 0)
   10eee:	83 fa 4f             	cmp    $0x4f,%edx
   10ef1:	bb 4f 00 00 00       	mov    $0x4f,%ebx
   10ef6:	0f 4f d3             	cmovg  %ebx,%edx
	col = 0;
    else if (col >= NUMCOLS)
	col = NUMCOLS - 1;

    s_cons.row = row;
   10ef9:	bb 00 00 00 00       	mov    $0x0,%ebx
   10efe:	85 c0                	test   %eax,%eax
   10f00:	0f 48 c3             	cmovs  %ebx,%eax
   10f03:	89 81 40 0b 00 00    	mov    %eax,0xb40(%ecx)
    s_cons.col = col;
   10f09:	85 d2                	test   %edx,%edx
   10f0b:	0f 48 d3             	cmovs  %ebx,%edx
   10f0e:	89 91 44 0b 00 00    	mov    %edx,0xb44(%ecx)
}
   10f14:	5b                   	pop    %ebx
   10f15:	c3                   	ret    

00010f16 <Update_Cursor>:

/*
 * Update the location of the hardware cursor.
 */
static void Update_Cursor(void)
{
   10f16:	57                   	push   %edi
   10f17:	56                   	push   %esi
   10f18:	53                   	push   %ebx
   10f19:	e8 f4 f2 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10f1e:	81 c3 e2 50 01 00    	add    $0x150e2,%ebx
    /*
     * The cursor location is a character offset from the beginning
     * of page memory (I think).
     */
    uint_t characterPos = (s_cons.row * NUMCOLS) + s_cons.col;
   10f24:	8b 83 40 0b 00 00    	mov    0xb40(%ebx),%eax
   10f2a:	8d 34 80             	lea    (%eax,%eax,4),%esi
   10f2d:	c1 e6 04             	shl    $0x4,%esi
   10f30:	03 b3 44 0b 00 00    	add    0xb44(%ebx),%esi
    /*
     * Save original contents of CRT address register.
     * It is considered good programming practice to restore
     * it to its original value after modifying it.
     */
    origAddr = In_Byte(CRT_ADDR_REG);
   10f36:	83 ec 0c             	sub    $0xc,%esp
   10f39:	68 d4 03 00 00       	push   $0x3d4
   10f3e:	e8 91 f9 ff ff       	call   108d4 <In_Byte>
   10f43:	89 c7                	mov    %eax,%edi
    IO_Delay();
   10f45:	e8 a2 f9 ff ff       	call   108ec <IO_Delay>

    /* Set the high cursor location byte */
    Out_Byte(CRT_ADDR_REG, CRT_CURSOR_LOC_HIGH_REG);
   10f4a:	83 c4 08             	add    $0x8,%esp
   10f4d:	6a 0e                	push   $0xe
   10f4f:	68 d4 03 00 00       	push   $0x3d4
   10f54:	e8 71 f9 ff ff       	call   108ca <Out_Byte>
    IO_Delay();
   10f59:	e8 8e f9 ff ff       	call   108ec <IO_Delay>
    Out_Byte(CRT_DATA_REG, (characterPos>>8) & 0xff);
   10f5e:	83 c4 08             	add    $0x8,%esp
   10f61:	89 f0                	mov    %esi,%eax
   10f63:	0f b6 c4             	movzbl %ah,%eax
   10f66:	50                   	push   %eax
   10f67:	68 d5 03 00 00       	push   $0x3d5
   10f6c:	e8 59 f9 ff ff       	call   108ca <Out_Byte>
    IO_Delay();
   10f71:	e8 76 f9 ff ff       	call   108ec <IO_Delay>

    /* Set the low cursor location byte */
    Out_Byte(CRT_ADDR_REG, CRT_CURSOR_LOC_LOW_REG);
   10f76:	83 c4 08             	add    $0x8,%esp
   10f79:	6a 0f                	push   $0xf
   10f7b:	68 d4 03 00 00       	push   $0x3d4
   10f80:	e8 45 f9 ff ff       	call   108ca <Out_Byte>
    IO_Delay();
   10f85:	e8 62 f9 ff ff       	call   108ec <IO_Delay>
    Out_Byte(CRT_DATA_REG, characterPos & 0xff);
   10f8a:	83 c4 08             	add    $0x8,%esp
   10f8d:	89 f0                	mov    %esi,%eax
   10f8f:	0f b6 f0             	movzbl %al,%esi
   10f92:	56                   	push   %esi
   10f93:	68 d5 03 00 00       	push   $0x3d5
   10f98:	e8 2d f9 ff ff       	call   108ca <Out_Byte>
    IO_Delay();
   10f9d:	e8 4a f9 ff ff       	call   108ec <IO_Delay>

    /* Restore contents of the CRT address register */
    Out_Byte(CRT_ADDR_REG, origAddr);
   10fa2:	83 c4 08             	add    $0x8,%esp
   10fa5:	89 f8                	mov    %edi,%eax
   10fa7:	0f b6 f8             	movzbl %al,%edi
   10faa:	57                   	push   %edi
   10fab:	68 d4 03 00 00       	push   $0x3d4
   10fb0:	e8 15 f9 ff ff       	call   108ca <Out_Byte>
}
   10fb5:	83 c4 10             	add    $0x10,%esp
   10fb8:	5b                   	pop    %ebx
   10fb9:	5e                   	pop    %esi
   10fba:	5f                   	pop    %edi
   10fbb:	c3                   	ret    

00010fbc <Print_Finish>:
    End_Int_Atomic(iflag);
}

/* Support for Print(). */
static void Print_Emit(struct Output_Sink *o, int ch) { Put_Char_Imp(ch); }
static void Print_Finish(struct Output_Sink *o) { Update_Cursor(); }
   10fbc:	83 ec 0c             	sub    $0xc,%esp
   10fbf:	e8 52 ff ff ff       	call   10f16 <Update_Cursor>
   10fc4:	83 c4 0c             	add    $0xc,%esp
   10fc7:	c3                   	ret    

00010fc8 <Get_Current_Attr>:
{
   10fc8:	e8 f9 f8 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   10fcd:	05 33 50 01 00       	add    $0x15033,%eax
    return s_cons.currentAttr;
   10fd2:	0f b6 80 50 0b 00 00 	movzbl 0xb50(%eax),%eax
}
   10fd9:	c3                   	ret    

00010fda <Print>:
/*
 * Print to console using printf()-style formatting.
 * Calls into Format_Output in common library.
 */
void Print(const char *fmt, ...)
{
   10fda:	53                   	push   %ebx
   10fdb:	83 ec 08             	sub    $0x8,%esp
   10fde:	e8 2f f2 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   10fe3:	81 c3 1d 50 01 00    	add    $0x1501d,%ebx
    bool enabled = Interrupts_Enabled();
   10fe9:	e8 5e f2 ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   10fee:	84 c0                	test   %al,%al
   10ff0:	75 2d                	jne    1101f <Print+0x45>
    va_list args;

    bool iflag = Begin_Int_Atomic();

    va_start(args, fmt);
   10ff2:	8d 44 24 14          	lea    0x14(%esp),%eax
    Format_Output(&s_outputSink, fmt, args);
   10ff6:	83 ec 04             	sub    $0x4,%esp
   10ff9:	50                   	push   %eax
   10ffa:	ff 74 24 18          	pushl  0x18(%esp)
   10ffe:	8d 83 24 00 00 00    	lea    0x24(%ebx),%eax
   11004:	50                   	push   %eax
   11005:	e8 0e af 00 00       	call   1bf18 <Format_Output>
    KASSERT(!Interrupts_Enabled());
   1100a:	e8 3d f2 ff ff       	call   1024c <Interrupts_Enabled>
   1100f:	83 c4 10             	add    $0x10,%esp
   11012:	84 c0                	test   %al,%al
   11014:	0f 85 87 00 00 00    	jne    110a1 <Print+0xc7>
    va_end(args);

    End_Int_Atomic(iflag);
}
   1101a:	83 c4 08             	add    $0x8,%esp
   1101d:	5b                   	pop    %ebx
   1101e:	c3                   	ret    
	Disable_Interrupts();
   1101f:	e8 28 f2 ff ff       	call   1024c <Interrupts_Enabled>
   11024:	84 c0                	test   %al,%al
   11026:	74 35                	je     1105d <Print+0x83>
    __asm__ __volatile__ ("cli");
   11028:	fa                   	cli    
    va_start(args, fmt);
   11029:	8d 44 24 14          	lea    0x14(%esp),%eax
    Format_Output(&s_outputSink, fmt, args);
   1102d:	83 ec 04             	sub    $0x4,%esp
   11030:	50                   	push   %eax
   11031:	ff 74 24 18          	pushl  0x18(%esp)
   11035:	8d 83 24 00 00 00    	lea    0x24(%ebx),%eax
   1103b:	50                   	push   %eax
   1103c:	e8 d7 ae 00 00       	call   1bf18 <Format_Output>
    KASSERT(!Interrupts_Enabled());
   11041:	e8 06 f2 ff ff       	call   1024c <Interrupts_Enabled>
   11046:	83 c4 10             	add    $0x10,%esp
   11049:	84 c0                	test   %al,%al
   1104b:	75 54                	jne    110a1 <Print+0xc7>
	Enable_Interrupts();
   1104d:	e8 fa f1 ff ff       	call   1024c <Interrupts_Enabled>
   11052:	84 c0                	test   %al,%al
   11054:	0f 85 8b 00 00 00    	jne    110e5 <Print+0x10b>
    __asm__ __volatile__ ("sti");
   1105a:	fb                   	sti    
}
   1105b:	eb bd                	jmp    1101a <Print+0x40>
	Disable_Interrupts();
   1105d:	83 ec 0c             	sub    $0xc,%esp
   11060:	6a 4f                	push   $0x4f
   11062:	e8 c2 00 00 00       	call   11129 <Set_Current_Attr>
   11067:	83 c4 0c             	add    $0xc,%esp
   1106a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11070:	ff 30                	pushl  (%eax)
   11072:	ff 74 24 14          	pushl  0x14(%esp)
   11076:	68 8f 00 00 00       	push   $0x8f
   1107b:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11081:	50                   	push   %eax
   11082:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11088:	50                   	push   %eax
   11089:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   1108f:	50                   	push   %eax
   11090:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11096:	50                   	push   %eax
   11097:	e8 3e ff ff ff       	call   10fda <Print>
   1109c:	83 c4 20             	add    $0x20,%esp
   1109f:	eb fe                	jmp    1109f <Print+0xc5>
    KASSERT(!Interrupts_Enabled());
   110a1:	83 ec 0c             	sub    $0xc,%esp
   110a4:	6a 4f                	push   $0x4f
   110a6:	e8 7e 00 00 00       	call   11129 <Set_Current_Attr>
   110ab:	83 c4 0c             	add    $0xc,%esp
   110ae:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   110b4:	ff 30                	pushl  (%eax)
   110b6:	ff 74 24 14          	pushl  0x14(%esp)
   110ba:	68 99 00 00 00       	push   $0x99
   110bf:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   110c5:	50                   	push   %eax
   110c6:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   110cc:	50                   	push   %eax
   110cd:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   110d3:	50                   	push   %eax
   110d4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   110da:	50                   	push   %eax
   110db:	e8 fa fe ff ff       	call   10fda <Print>
   110e0:	83 c4 20             	add    $0x20,%esp
   110e3:	eb fe                	jmp    110e3 <Print+0x109>
	Enable_Interrupts();
   110e5:	83 ec 0c             	sub    $0xc,%esp
   110e8:	6a 4f                	push   $0x4f
   110ea:	e8 3a 00 00 00       	call   11129 <Set_Current_Attr>
   110ef:	83 c4 0c             	add    $0xc,%esp
   110f2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   110f8:	ff 30                	pushl  (%eax)
   110fa:	ff 74 24 14          	pushl  0x14(%esp)
   110fe:	68 9c 00 00 00       	push   $0x9c
   11103:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11109:	50                   	push   %eax
   1110a:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11110:	50                   	push   %eax
   11111:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11117:	50                   	push   %eax
   11118:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1111e:	50                   	push   %eax
   1111f:	e8 b6 fe ff ff       	call   10fda <Print>
   11124:	83 c4 20             	add    $0x20,%esp
   11127:	eb fe                	jmp    11127 <Print+0x14d>

00011129 <Set_Current_Attr>:
{
   11129:	56                   	push   %esi
   1112a:	53                   	push   %ebx
   1112b:	83 ec 04             	sub    $0x4,%esp
   1112e:	e8 df f0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   11133:	81 c3 cd 4e 01 00    	add    $0x14ecd,%ebx
   11139:	8b 74 24 10          	mov    0x10(%esp),%esi
    bool enabled = Interrupts_Enabled();
   1113d:	e8 0a f1 ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   11142:	84 c0                	test   %al,%al
   11144:	75 17                	jne    1115d <Set_Current_Attr+0x34>
    s_cons.currentAttr = attrib;
   11146:	89 f0                	mov    %esi,%eax
   11148:	88 83 50 0b 00 00    	mov    %al,0xb50(%ebx)
    KASSERT(!Interrupts_Enabled());
   1114e:	e8 f9 f0 ff ff       	call   1024c <Interrupts_Enabled>
   11153:	84 c0                	test   %al,%al
   11155:	75 75                	jne    111cc <Set_Current_Attr+0xa3>
}
   11157:	83 c4 04             	add    $0x4,%esp
   1115a:	5b                   	pop    %ebx
   1115b:	5e                   	pop    %esi
   1115c:	c3                   	ret    
	Disable_Interrupts();
   1115d:	e8 ea f0 ff ff       	call   1024c <Interrupts_Enabled>
   11162:	84 c0                	test   %al,%al
   11164:	74 22                	je     11188 <Set_Current_Attr+0x5f>
    __asm__ __volatile__ ("cli");
   11166:	fa                   	cli    
    s_cons.currentAttr = attrib;
   11167:	89 f0                	mov    %esi,%eax
   11169:	88 83 50 0b 00 00    	mov    %al,0xb50(%ebx)
    KASSERT(!Interrupts_Enabled());
   1116f:	e8 d8 f0 ff ff       	call   1024c <Interrupts_Enabled>
   11174:	84 c0                	test   %al,%al
   11176:	75 54                	jne    111cc <Set_Current_Attr+0xa3>
	Enable_Interrupts();
   11178:	e8 cf f0 ff ff       	call   1024c <Interrupts_Enabled>
   1117d:	84 c0                	test   %al,%al
   1117f:	0f 85 8b 00 00 00    	jne    11210 <Set_Current_Attr+0xe7>
    __asm__ __volatile__ ("sti");
   11185:	fb                   	sti    
}
   11186:	eb cf                	jmp    11157 <Set_Current_Attr+0x2e>
	Disable_Interrupts();
   11188:	83 ec 0c             	sub    $0xc,%esp
   1118b:	6a 4f                	push   $0x4f
   1118d:	e8 97 ff ff ff       	call   11129 <Set_Current_Attr>
   11192:	83 c4 0c             	add    $0xc,%esp
   11195:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1119b:	ff 30                	pushl  (%eax)
   1119d:	ff 74 24 14          	pushl  0x14(%esp)
   111a1:	68 8f 00 00 00       	push   $0x8f
   111a6:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   111ac:	50                   	push   %eax
   111ad:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   111b3:	50                   	push   %eax
   111b4:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   111ba:	50                   	push   %eax
   111bb:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   111c1:	50                   	push   %eax
   111c2:	e8 13 fe ff ff       	call   10fda <Print>
   111c7:	83 c4 20             	add    $0x20,%esp
   111ca:	eb fe                	jmp    111ca <Set_Current_Attr+0xa1>
    KASSERT(!Interrupts_Enabled());
   111cc:	83 ec 0c             	sub    $0xc,%esp
   111cf:	6a 4f                	push   $0x4f
   111d1:	e8 53 ff ff ff       	call   11129 <Set_Current_Attr>
   111d6:	83 c4 0c             	add    $0xc,%esp
   111d9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   111df:	ff 30                	pushl  (%eax)
   111e1:	ff 74 24 14          	pushl  0x14(%esp)
   111e5:	68 99 00 00 00       	push   $0x99
   111ea:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   111f0:	50                   	push   %eax
   111f1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   111f7:	50                   	push   %eax
   111f8:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   111fe:	50                   	push   %eax
   111ff:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11205:	50                   	push   %eax
   11206:	e8 cf fd ff ff       	call   10fda <Print>
   1120b:	83 c4 20             	add    $0x20,%esp
   1120e:	eb fe                	jmp    1120e <Set_Current_Attr+0xe5>
	Enable_Interrupts();
   11210:	83 ec 0c             	sub    $0xc,%esp
   11213:	6a 4f                	push   $0x4f
   11215:	e8 0f ff ff ff       	call   11129 <Set_Current_Attr>
   1121a:	83 c4 0c             	add    $0xc,%esp
   1121d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11223:	ff 30                	pushl  (%eax)
   11225:	ff 74 24 14          	pushl  0x14(%esp)
   11229:	68 9c 00 00 00       	push   $0x9c
   1122e:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11234:	50                   	push   %eax
   11235:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1123b:	50                   	push   %eax
   1123c:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11242:	50                   	push   %eax
   11243:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11249:	50                   	push   %eax
   1124a:	e8 8b fd ff ff       	call   10fda <Print>
   1124f:	83 c4 20             	add    $0x20,%esp
   11252:	eb fe                	jmp    11252 <Set_Current_Attr+0x129>

00011254 <Put_Cursor>:
{
   11254:	57                   	push   %edi
   11255:	56                   	push   %esi
   11256:	53                   	push   %ebx
   11257:	e8 b6 ef ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1125c:	81 c3 a4 4d 01 00    	add    $0x14da4,%ebx
   11262:	8b 74 24 10          	mov    0x10(%esp),%esi
    if (row < 0 || row >= NUMROWS || col < 0 || col >= NUMCOLS)
   11266:	83 fe 18             	cmp    $0x18,%esi
   11269:	77 07                	ja     11272 <Put_Cursor+0x1e>
   1126b:	83 7c 24 14 4f       	cmpl   $0x4f,0x14(%esp)
   11270:	76 0b                	jbe    1127d <Put_Cursor+0x29>
	return false;
   11272:	bf 00 00 00 00       	mov    $0x0,%edi
}
   11277:	89 f8                	mov    %edi,%eax
   11279:	5b                   	pop    %ebx
   1127a:	5e                   	pop    %esi
   1127b:	5f                   	pop    %edi
   1127c:	c3                   	ret    
    bool enabled = Interrupts_Enabled();
   1127d:	e8 ca ef ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   11282:	84 c0                	test   %al,%al
   11284:	75 29                	jne    112af <Put_Cursor+0x5b>
    s_cons.row = row;
   11286:	89 b3 40 0b 00 00    	mov    %esi,0xb40(%ebx)
    s_cons.col = col;
   1128c:	8b 44 24 14          	mov    0x14(%esp),%eax
   11290:	89 83 44 0b 00 00    	mov    %eax,0xb44(%ebx)
    Update_Cursor();
   11296:	e8 7b fc ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   1129b:	e8 ac ef ff ff       	call   1024c <Interrupts_Enabled>
   112a0:	84 c0                	test   %al,%al
   112a2:	0f 85 85 00 00 00    	jne    1132d <Put_Cursor+0xd9>
    return true;
   112a8:	bf 01 00 00 00       	mov    $0x1,%edi
   112ad:	eb c8                	jmp    11277 <Put_Cursor+0x23>
	Disable_Interrupts();
   112af:	e8 98 ef ff ff       	call   1024c <Interrupts_Enabled>
   112b4:	89 c7                	mov    %eax,%edi
   112b6:	84 c0                	test   %al,%al
   112b8:	74 2f                	je     112e9 <Put_Cursor+0x95>
    __asm__ __volatile__ ("cli");
   112ba:	fa                   	cli    
    s_cons.row = row;
   112bb:	89 b3 40 0b 00 00    	mov    %esi,0xb40(%ebx)
    s_cons.col = col;
   112c1:	8b 44 24 14          	mov    0x14(%esp),%eax
   112c5:	89 83 44 0b 00 00    	mov    %eax,0xb44(%ebx)
    Update_Cursor();
   112cb:	e8 46 fc ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   112d0:	e8 77 ef ff ff       	call   1024c <Interrupts_Enabled>
   112d5:	84 c0                	test   %al,%al
   112d7:	75 54                	jne    1132d <Put_Cursor+0xd9>
	Enable_Interrupts();
   112d9:	e8 6e ef ff ff       	call   1024c <Interrupts_Enabled>
   112de:	84 c0                	test   %al,%al
   112e0:	0f 85 8b 00 00 00    	jne    11371 <Put_Cursor+0x11d>
    __asm__ __volatile__ ("sti");
   112e6:	fb                   	sti    
}
   112e7:	eb 8e                	jmp    11277 <Put_Cursor+0x23>
	Disable_Interrupts();
   112e9:	83 ec 0c             	sub    $0xc,%esp
   112ec:	6a 4f                	push   $0x4f
   112ee:	e8 36 fe ff ff       	call   11129 <Set_Current_Attr>
   112f3:	83 c4 0c             	add    $0xc,%esp
   112f6:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   112fc:	ff 30                	pushl  (%eax)
   112fe:	ff 74 24 14          	pushl  0x14(%esp)
   11302:	68 8f 00 00 00       	push   $0x8f
   11307:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1130d:	50                   	push   %eax
   1130e:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11314:	50                   	push   %eax
   11315:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   1131b:	50                   	push   %eax
   1131c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11322:	50                   	push   %eax
   11323:	e8 b2 fc ff ff       	call   10fda <Print>
   11328:	83 c4 20             	add    $0x20,%esp
   1132b:	eb fe                	jmp    1132b <Put_Cursor+0xd7>
    KASSERT(!Interrupts_Enabled());
   1132d:	83 ec 0c             	sub    $0xc,%esp
   11330:	6a 4f                	push   $0x4f
   11332:	e8 f2 fd ff ff       	call   11129 <Set_Current_Attr>
   11337:	83 c4 0c             	add    $0xc,%esp
   1133a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11340:	ff 30                	pushl  (%eax)
   11342:	ff 74 24 14          	pushl  0x14(%esp)
   11346:	68 99 00 00 00       	push   $0x99
   1134b:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11351:	50                   	push   %eax
   11352:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11358:	50                   	push   %eax
   11359:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   1135f:	50                   	push   %eax
   11360:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11366:	50                   	push   %eax
   11367:	e8 6e fc ff ff       	call   10fda <Print>
   1136c:	83 c4 20             	add    $0x20,%esp
   1136f:	eb fe                	jmp    1136f <Put_Cursor+0x11b>
	Enable_Interrupts();
   11371:	83 ec 0c             	sub    $0xc,%esp
   11374:	6a 4f                	push   $0x4f
   11376:	e8 ae fd ff ff       	call   11129 <Set_Current_Attr>
   1137b:	83 c4 0c             	add    $0xc,%esp
   1137e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11384:	ff 30                	pushl  (%eax)
   11386:	ff 74 24 14          	pushl  0x14(%esp)
   1138a:	68 9c 00 00 00       	push   $0x9c
   1138f:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11395:	50                   	push   %eax
   11396:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1139c:	50                   	push   %eax
   1139d:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   113a3:	50                   	push   %eax
   113a4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   113aa:	50                   	push   %eax
   113ab:	e8 2a fc ff ff       	call   10fda <Print>
   113b0:	83 c4 20             	add    $0x20,%esp
   113b3:	eb fe                	jmp    113b3 <Put_Cursor+0x15f>

000113b5 <Add_Digit>:
{
   113b5:	53                   	push   %ebx
   113b6:	83 ec 08             	sub    $0x8,%esp
   113b9:	e8 54 ee ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   113be:	81 c3 42 4c 01 00    	add    $0x14c42,%ebx
    KASSERT(ISDIGIT(c));
   113c4:	8d 50 d0             	lea    -0x30(%eax),%edx
   113c7:	83 fa 09             	cmp    $0x9,%edx
   113ca:	77 24                	ja     113f0 <Add_Digit+0x3b>
    if (s_cons.numArgs < MAXARGS) {
   113cc:	8b 93 78 0b 00 00    	mov    0xb78(%ebx),%edx
   113d2:	83 fa 07             	cmp    $0x7,%edx
   113d5:	7f 14                	jg     113eb <Add_Digit+0x36>
	s_cons.argList[argNum] += (c - '0');
   113d7:	8d 94 93 4c 0b 00 00 	lea    0xb4c(%ebx,%edx,4),%edx
	s_cons.argList[argNum] *= 10;
   113de:	8b 4a 08             	mov    0x8(%edx),%ecx
   113e1:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
	s_cons.argList[argNum] += (c - '0');
   113e4:	8d 44 48 d0          	lea    -0x30(%eax,%ecx,2),%eax
   113e8:	89 42 08             	mov    %eax,0x8(%edx)
}
   113eb:	83 c4 08             	add    $0x8,%esp
   113ee:	5b                   	pop    %ebx
   113ef:	c3                   	ret    
    KASSERT(ISDIGIT(c));
   113f0:	83 ec 0c             	sub    $0xc,%esp
   113f3:	6a 4f                	push   $0x4f
   113f5:	e8 2f fd ff ff       	call   11129 <Set_Current_Attr>
   113fa:	83 c4 0c             	add    $0xc,%esp
   113fd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11403:	ff 30                	pushl  (%eax)
   11405:	ff 74 24 14          	pushl  0x14(%esp)
   11409:	68 ff 00 00 00       	push   $0xff
   1140e:	8d 83 70 75 ff ff    	lea    -0x8a90(%ebx),%eax
   11414:	50                   	push   %eax
   11415:	8d 83 87 75 ff ff    	lea    -0x8a79(%ebx),%eax
   1141b:	50                   	push   %eax
   1141c:	8d 83 a8 76 ff ff    	lea    -0x8958(%ebx),%eax
   11422:	50                   	push   %eax
   11423:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11429:	50                   	push   %eax
   1142a:	e8 ab fb ff ff       	call   10fda <Print>
   1142f:	83 c4 20             	add    $0x20,%esp
   11432:	eb fe                	jmp    11432 <Add_Digit+0x7d>

00011434 <Start_Arg>:
{
   11434:	53                   	push   %ebx
   11435:	83 ec 08             	sub    $0x8,%esp
   11438:	e8 d5 ed ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1143d:	81 c3 c3 4b 01 00    	add    $0x14bc3,%ebx
    KASSERT(s_cons.numArgs == argNum);
   11443:	39 83 78 0b 00 00    	cmp    %eax,0xb78(%ebx)
   11449:	75 28                	jne    11473 <Start_Arg+0x3f>
    s_cons.numArgs++;
   1144b:	8d 50 01             	lea    0x1(%eax),%edx
   1144e:	89 93 78 0b 00 00    	mov    %edx,0xb78(%ebx)
    s_cons.state = S_ARG;
   11454:	c7 83 54 0b 00 00 03 	movl   $0x3,0xb54(%ebx)
   1145b:	00 00 00 
    if (argNum < MAXARGS)
   1145e:	83 f8 07             	cmp    $0x7,%eax
   11461:	7f 0b                	jg     1146e <Start_Arg+0x3a>
	s_cons.argList[argNum] = 0;
   11463:	c7 84 83 58 0b 00 00 	movl   $0x0,0xb58(%ebx,%eax,4)
   1146a:	00 00 00 00 
}
   1146e:	83 c4 08             	add    $0x8,%esp
   11471:	5b                   	pop    %ebx
   11472:	c3                   	ret    
    KASSERT(s_cons.numArgs == argNum);
   11473:	83 ec 0c             	sub    $0xc,%esp
   11476:	6a 4f                	push   $0x4f
   11478:	e8 ac fc ff ff       	call   11129 <Set_Current_Attr>
   1147d:	83 c4 0c             	add    $0xc,%esp
   11480:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11486:	ff 30                	pushl  (%eax)
   11488:	ff 74 24 14          	pushl  0x14(%esp)
   1148c:	68 e7 00 00 00       	push   $0xe7
   11491:	8d 83 70 75 ff ff    	lea    -0x8a90(%ebx),%eax
   11497:	50                   	push   %eax
   11498:	8d 83 92 75 ff ff    	lea    -0x8a6e(%ebx),%eax
   1149e:	50                   	push   %eax
   1149f:	8d 83 9c 76 ff ff    	lea    -0x8964(%ebx),%eax
   114a5:	50                   	push   %eax
   114a6:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   114ac:	50                   	push   %eax
   114ad:	e8 28 fb ff ff       	call   10fda <Print>
   114b2:	83 c4 20             	add    $0x20,%esp
   114b5:	eb fe                	jmp    114b5 <Start_Arg+0x81>

000114b7 <Get_Cursor>:
{
   114b7:	53                   	push   %ebx
   114b8:	83 ec 08             	sub    $0x8,%esp
   114bb:	e8 52 ed ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   114c0:	81 c3 40 4b 01 00    	add    $0x14b40,%ebx
    bool enabled = Interrupts_Enabled();
   114c6:	e8 81 ed ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   114cb:	84 c0                	test   %al,%al
   114cd:	75 2a                	jne    114f9 <Get_Cursor+0x42>
    *row = s_cons.row;
   114cf:	8b 83 40 0b 00 00    	mov    0xb40(%ebx),%eax
   114d5:	8b 54 24 10          	mov    0x10(%esp),%edx
   114d9:	89 02                	mov    %eax,(%edx)
    *col = s_cons.col;
   114db:	8b 83 44 0b 00 00    	mov    0xb44(%ebx),%eax
   114e1:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   114e5:	89 01                	mov    %eax,(%ecx)
    KASSERT(!Interrupts_Enabled());
   114e7:	e8 60 ed ff ff       	call   1024c <Interrupts_Enabled>
   114ec:	84 c0                	test   %al,%al
   114ee:	0f 85 84 00 00 00    	jne    11578 <Get_Cursor+0xc1>
}
   114f4:	83 c4 08             	add    $0x8,%esp
   114f7:	5b                   	pop    %ebx
   114f8:	c3                   	ret    
	Disable_Interrupts();
   114f9:	e8 4e ed ff ff       	call   1024c <Interrupts_Enabled>
   114fe:	84 c0                	test   %al,%al
   11500:	74 32                	je     11534 <Get_Cursor+0x7d>
    __asm__ __volatile__ ("cli");
   11502:	fa                   	cli    
    *row = s_cons.row;
   11503:	8b 83 40 0b 00 00    	mov    0xb40(%ebx),%eax
   11509:	8b 54 24 10          	mov    0x10(%esp),%edx
   1150d:	89 02                	mov    %eax,(%edx)
    *col = s_cons.col;
   1150f:	8b 83 44 0b 00 00    	mov    0xb44(%ebx),%eax
   11515:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   11519:	89 01                	mov    %eax,(%ecx)
    KASSERT(!Interrupts_Enabled());
   1151b:	e8 2c ed ff ff       	call   1024c <Interrupts_Enabled>
   11520:	84 c0                	test   %al,%al
   11522:	75 54                	jne    11578 <Get_Cursor+0xc1>
	Enable_Interrupts();
   11524:	e8 23 ed ff ff       	call   1024c <Interrupts_Enabled>
   11529:	84 c0                	test   %al,%al
   1152b:	0f 85 8b 00 00 00    	jne    115bc <Get_Cursor+0x105>
    __asm__ __volatile__ ("sti");
   11531:	fb                   	sti    
}
   11532:	eb c0                	jmp    114f4 <Get_Cursor+0x3d>
	Disable_Interrupts();
   11534:	83 ec 0c             	sub    $0xc,%esp
   11537:	6a 4f                	push   $0x4f
   11539:	e8 eb fb ff ff       	call   11129 <Set_Current_Attr>
   1153e:	83 c4 0c             	add    $0xc,%esp
   11541:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11547:	ff 30                	pushl  (%eax)
   11549:	ff 74 24 14          	pushl  0x14(%esp)
   1154d:	68 8f 00 00 00       	push   $0x8f
   11552:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11558:	50                   	push   %eax
   11559:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1155f:	50                   	push   %eax
   11560:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11566:	50                   	push   %eax
   11567:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1156d:	50                   	push   %eax
   1156e:	e8 67 fa ff ff       	call   10fda <Print>
   11573:	83 c4 20             	add    $0x20,%esp
   11576:	eb fe                	jmp    11576 <Get_Cursor+0xbf>
    KASSERT(!Interrupts_Enabled());
   11578:	83 ec 0c             	sub    $0xc,%esp
   1157b:	6a 4f                	push   $0x4f
   1157d:	e8 a7 fb ff ff       	call   11129 <Set_Current_Attr>
   11582:	83 c4 0c             	add    $0xc,%esp
   11585:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1158b:	ff 30                	pushl  (%eax)
   1158d:	ff 74 24 14          	pushl  0x14(%esp)
   11591:	68 99 00 00 00       	push   $0x99
   11596:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1159c:	50                   	push   %eax
   1159d:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   115a3:	50                   	push   %eax
   115a4:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   115aa:	50                   	push   %eax
   115ab:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   115b1:	50                   	push   %eax
   115b2:	e8 23 fa ff ff       	call   10fda <Print>
   115b7:	83 c4 20             	add    $0x20,%esp
   115ba:	eb fe                	jmp    115ba <Get_Cursor+0x103>
	Enable_Interrupts();
   115bc:	83 ec 0c             	sub    $0xc,%esp
   115bf:	6a 4f                	push   $0x4f
   115c1:	e8 63 fb ff ff       	call   11129 <Set_Current_Attr>
   115c6:	83 c4 0c             	add    $0xc,%esp
   115c9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   115cf:	ff 30                	pushl  (%eax)
   115d1:	ff 74 24 14          	pushl  0x14(%esp)
   115d5:	68 9c 00 00 00       	push   $0x9c
   115da:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   115e0:	50                   	push   %eax
   115e1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   115e7:	50                   	push   %eax
   115e8:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   115ee:	50                   	push   %eax
   115ef:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   115f5:	50                   	push   %eax
   115f6:	e8 df f9 ff ff       	call   10fda <Print>
   115fb:	83 c4 20             	add    $0x20,%esp
   115fe:	eb fe                	jmp    115fe <Get_Cursor+0x147>

00011600 <Clear_Screen>:
{
   11600:	57                   	push   %edi
   11601:	56                   	push   %esi
   11602:	53                   	push   %ebx
   11603:	e8 0a ec ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   11608:	81 c3 f8 49 01 00    	add    $0x149f8,%ebx
    uint_t fill = FILL_DWORD;
   1160e:	0f b6 83 50 0b 00 00 	movzbl 0xb50(%ebx),%eax
   11615:	89 c6                	mov    %eax,%esi
   11617:	c1 e6 18             	shl    $0x18,%esi
   1161a:	c1 e0 08             	shl    $0x8,%eax
   1161d:	09 f0                	or     %esi,%eax
   1161f:	0d 20 00 20 00       	or     $0x200020,%eax
   11624:	89 c6                	mov    %eax,%esi
    bool enabled = Interrupts_Enabled();
   11626:	e8 21 ec ff ff       	call   1024c <Interrupts_Enabled>
   1162b:	89 c7                	mov    %eax,%edi
    if (enabled)
   1162d:	84 c0                	test   %al,%al
   1162f:	75 2a                	jne    1165b <Clear_Screen+0x5b>
{
   11631:	b8 00 80 0b 00       	mov    $0xb8000,%eax
	*v++ = fill;
   11636:	89 c2                	mov    %eax,%edx
   11638:	83 c0 04             	add    $0x4,%eax
   1163b:	89 32                	mov    %esi,(%edx)
    for (i = 0; i < NUM_SCREEN_DWORDS; ++i)
   1163d:	3d a0 8f 0b 00       	cmp    $0xb8fa0,%eax
   11642:	75 f2                	jne    11636 <Clear_Screen+0x36>
    KASSERT(!Interrupts_Enabled());
   11644:	e8 03 ec ff ff       	call   1024c <Interrupts_Enabled>
   11649:	84 c0                	test   %al,%al
   1164b:	75 5e                	jne    116ab <Clear_Screen+0xab>
    if (iflag) {
   1164d:	89 f8                	mov    %edi,%eax
   1164f:	84 c0                	test   %al,%al
   11651:	0f 85 98 00 00 00    	jne    116ef <Clear_Screen+0xef>
}
   11657:	5b                   	pop    %ebx
   11658:	5e                   	pop    %esi
   11659:	5f                   	pop    %edi
   1165a:	c3                   	ret    
	Disable_Interrupts();
   1165b:	e8 ec eb ff ff       	call   1024c <Interrupts_Enabled>
   11660:	84 c0                	test   %al,%al
   11662:	74 03                	je     11667 <Clear_Screen+0x67>
    __asm__ __volatile__ ("cli");
   11664:	fa                   	cli    
}
   11665:	eb ca                	jmp    11631 <Clear_Screen+0x31>
	Disable_Interrupts();
   11667:	83 ec 0c             	sub    $0xc,%esp
   1166a:	6a 4f                	push   $0x4f
   1166c:	e8 b8 fa ff ff       	call   11129 <Set_Current_Attr>
   11671:	83 c4 0c             	add    $0xc,%esp
   11674:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1167a:	ff 30                	pushl  (%eax)
   1167c:	ff 74 24 14          	pushl  0x14(%esp)
   11680:	68 8f 00 00 00       	push   $0x8f
   11685:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1168b:	50                   	push   %eax
   1168c:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11692:	50                   	push   %eax
   11693:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11699:	50                   	push   %eax
   1169a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   116a0:	50                   	push   %eax
   116a1:	e8 34 f9 ff ff       	call   10fda <Print>
   116a6:	83 c4 20             	add    $0x20,%esp
   116a9:	eb fe                	jmp    116a9 <Clear_Screen+0xa9>
    KASSERT(!Interrupts_Enabled());
   116ab:	83 ec 0c             	sub    $0xc,%esp
   116ae:	6a 4f                	push   $0x4f
   116b0:	e8 74 fa ff ff       	call   11129 <Set_Current_Attr>
   116b5:	83 c4 0c             	add    $0xc,%esp
   116b8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   116be:	ff 30                	pushl  (%eax)
   116c0:	ff 74 24 14          	pushl  0x14(%esp)
   116c4:	68 99 00 00 00       	push   $0x99
   116c9:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   116cf:	50                   	push   %eax
   116d0:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   116d6:	50                   	push   %eax
   116d7:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   116dd:	50                   	push   %eax
   116de:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   116e4:	50                   	push   %eax
   116e5:	e8 f0 f8 ff ff       	call   10fda <Print>
   116ea:	83 c4 20             	add    $0x20,%esp
   116ed:	eb fe                	jmp    116ed <Clear_Screen+0xed>
	Enable_Interrupts();
   116ef:	e8 58 eb ff ff       	call   1024c <Interrupts_Enabled>
   116f4:	84 c0                	test   %al,%al
   116f6:	75 06                	jne    116fe <Clear_Screen+0xfe>
    __asm__ __volatile__ ("sti");
   116f8:	fb                   	sti    
   116f9:	e9 59 ff ff ff       	jmp    11657 <Clear_Screen+0x57>
	Enable_Interrupts();
   116fe:	83 ec 0c             	sub    $0xc,%esp
   11701:	6a 4f                	push   $0x4f
   11703:	e8 21 fa ff ff       	call   11129 <Set_Current_Attr>
   11708:	83 c4 0c             	add    $0xc,%esp
   1170b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11711:	ff 30                	pushl  (%eax)
   11713:	ff 74 24 14          	pushl  0x14(%esp)
   11717:	68 9c 00 00 00       	push   $0x9c
   1171c:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11722:	50                   	push   %eax
   11723:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11729:	50                   	push   %eax
   1172a:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11730:	50                   	push   %eax
   11731:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11737:	50                   	push   %eax
   11738:	e8 9d f8 ff ff       	call   10fda <Print>
   1173d:	83 c4 20             	add    $0x20,%esp
   11740:	eb fe                	jmp    11740 <Clear_Screen+0x140>

00011742 <Init_Screen>:
{
   11742:	53                   	push   %ebx
   11743:	83 ec 08             	sub    $0x8,%esp
   11746:	e8 c7 ea ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1174b:	81 c3 b5 48 01 00    	add    $0x148b5,%ebx
    bool enabled = Interrupts_Enabled();
   11751:	e8 f6 ea ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   11756:	84 c0                	test   %al,%al
   11758:	75 32                	jne    1178c <Init_Screen+0x4a>
    s_cons.row = s_cons.col = 0;
   1175a:	c7 83 44 0b 00 00 00 	movl   $0x0,0xb44(%ebx)
   11761:	00 00 00 
   11764:	c7 83 40 0b 00 00 00 	movl   $0x0,0xb40(%ebx)
   1176b:	00 00 00 
    s_cons.currentAttr = DEFAULT_ATTRIBUTE;
   1176e:	c6 83 50 0b 00 00 07 	movb   $0x7,0xb50(%ebx)
    Clear_Screen();
   11775:	e8 86 fe ff ff       	call   11600 <Clear_Screen>
    KASSERT(!Interrupts_Enabled());
   1177a:	e8 cd ea ff ff       	call   1024c <Interrupts_Enabled>
   1177f:	84 c0                	test   %al,%al
   11781:	0f 85 8c 00 00 00    	jne    11813 <Init_Screen+0xd1>
}
   11787:	83 c4 08             	add    $0x8,%esp
   1178a:	5b                   	pop    %ebx
   1178b:	c3                   	ret    
	Disable_Interrupts();
   1178c:	e8 bb ea ff ff       	call   1024c <Interrupts_Enabled>
   11791:	84 c0                	test   %al,%al
   11793:	74 3a                	je     117cf <Init_Screen+0x8d>
    __asm__ __volatile__ ("cli");
   11795:	fa                   	cli    
    s_cons.row = s_cons.col = 0;
   11796:	c7 83 44 0b 00 00 00 	movl   $0x0,0xb44(%ebx)
   1179d:	00 00 00 
   117a0:	c7 83 40 0b 00 00 00 	movl   $0x0,0xb40(%ebx)
   117a7:	00 00 00 
    s_cons.currentAttr = DEFAULT_ATTRIBUTE;
   117aa:	c6 83 50 0b 00 00 07 	movb   $0x7,0xb50(%ebx)
    Clear_Screen();
   117b1:	e8 4a fe ff ff       	call   11600 <Clear_Screen>
    KASSERT(!Interrupts_Enabled());
   117b6:	e8 91 ea ff ff       	call   1024c <Interrupts_Enabled>
   117bb:	84 c0                	test   %al,%al
   117bd:	75 54                	jne    11813 <Init_Screen+0xd1>
	Enable_Interrupts();
   117bf:	e8 88 ea ff ff       	call   1024c <Interrupts_Enabled>
   117c4:	84 c0                	test   %al,%al
   117c6:	0f 85 8b 00 00 00    	jne    11857 <Init_Screen+0x115>
    __asm__ __volatile__ ("sti");
   117cc:	fb                   	sti    
}
   117cd:	eb b8                	jmp    11787 <Init_Screen+0x45>
	Disable_Interrupts();
   117cf:	83 ec 0c             	sub    $0xc,%esp
   117d2:	6a 4f                	push   $0x4f
   117d4:	e8 50 f9 ff ff       	call   11129 <Set_Current_Attr>
   117d9:	83 c4 0c             	add    $0xc,%esp
   117dc:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   117e2:	ff 30                	pushl  (%eax)
   117e4:	ff 74 24 14          	pushl  0x14(%esp)
   117e8:	68 8f 00 00 00       	push   $0x8f
   117ed:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   117f3:	50                   	push   %eax
   117f4:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   117fa:	50                   	push   %eax
   117fb:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11801:	50                   	push   %eax
   11802:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11808:	50                   	push   %eax
   11809:	e8 cc f7 ff ff       	call   10fda <Print>
   1180e:	83 c4 20             	add    $0x20,%esp
   11811:	eb fe                	jmp    11811 <Init_Screen+0xcf>
    KASSERT(!Interrupts_Enabled());
   11813:	83 ec 0c             	sub    $0xc,%esp
   11816:	6a 4f                	push   $0x4f
   11818:	e8 0c f9 ff ff       	call   11129 <Set_Current_Attr>
   1181d:	83 c4 0c             	add    $0xc,%esp
   11820:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11826:	ff 30                	pushl  (%eax)
   11828:	ff 74 24 14          	pushl  0x14(%esp)
   1182c:	68 99 00 00 00       	push   $0x99
   11831:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11837:	50                   	push   %eax
   11838:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1183e:	50                   	push   %eax
   1183f:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11845:	50                   	push   %eax
   11846:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1184c:	50                   	push   %eax
   1184d:	e8 88 f7 ff ff       	call   10fda <Print>
   11852:	83 c4 20             	add    $0x20,%esp
   11855:	eb fe                	jmp    11855 <Init_Screen+0x113>
	Enable_Interrupts();
   11857:	83 ec 0c             	sub    $0xc,%esp
   1185a:	6a 4f                	push   $0x4f
   1185c:	e8 c8 f8 ff ff       	call   11129 <Set_Current_Attr>
   11861:	83 c4 0c             	add    $0xc,%esp
   11864:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1186a:	ff 30                	pushl  (%eax)
   1186c:	ff 74 24 14          	pushl  0x14(%esp)
   11870:	68 9c 00 00 00       	push   $0x9c
   11875:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1187b:	50                   	push   %eax
   1187c:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11882:	50                   	push   %eax
   11883:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11889:	50                   	push   %eax
   1188a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11890:	50                   	push   %eax
   11891:	e8 44 f7 ff ff       	call   10fda <Print>
   11896:	83 c4 20             	add    $0x20,%esp
   11899:	eb fe                	jmp    11899 <Init_Screen+0x157>

0001189b <Put_Char_Imp>:
{
   1189b:	55                   	push   %ebp
   1189c:	57                   	push   %edi
   1189d:	56                   	push   %esi
   1189e:	53                   	push   %ebx
   1189f:	83 ec 0c             	sub    $0xc,%esp
   118a2:	e8 2c ec ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   118a7:	81 c6 59 47 01 00    	add    $0x14759,%esi
   118ad:	89 c3                	mov    %eax,%ebx
    switch (s_cons.state) {
   118af:	8d 3d 40 0b 00 00    	lea    0xb40,%edi
	if (ISDIGIT(c))
   118b5:	8d 68 d0             	lea    -0x30(%eax),%ebp
    switch (s_cons.state) {
   118b8:	83 7c 3e 14 04       	cmpl   $0x4,0x14(%esi,%edi,1)
   118bd:	0f 87 20 03 00 00    	ja     11be3 <.L157+0x33>
   118c3:	8b 44 3e 14          	mov    0x14(%esi,%edi,1),%eax
   118c7:	89 f2                	mov    %esi,%edx
   118c9:	03 94 86 b4 75 ff ff 	add    -0x8a4c(%esi,%eax,4),%edx
   118d0:	ff e2                	jmp    *%edx

000118d2 <.L137>:
	if (c == ESC)
   118d2:	83 fb 1b             	cmp    $0x1b,%ebx
   118d5:	74 2f                	je     11906 <.L137+0x34>
    switch (c) {
   118d7:	83 fb 09             	cmp    $0x9,%ebx
   118da:	74 43                	je     1191f <.L137+0x4d>
   118dc:	83 fb 0a             	cmp    $0xa,%ebx
   118df:	75 6a                	jne    1194b <.L137+0x79>
	Clear_To_EOL();
   118e1:	e8 dd f4 ff ff       	call   10dc3 <Clear_To_EOL>
	Newline();
   118e6:	e8 2c f5 ff ff       	call   10e17 <Newline>
    Out_Byte(0xE9, c);
   118eb:	83 ec 08             	sub    $0x8,%esp
   118ee:	0f b6 c3             	movzbl %bl,%eax
   118f1:	50                   	push   %eax
   118f2:	68 e9 00 00 00       	push   $0xe9
   118f7:	89 f3                	mov    %esi,%ebx
   118f9:	e8 cc ef ff ff       	call   108ca <Out_Byte>
}
   118fe:	83 c4 10             	add    $0x10,%esp
   11901:	e9 1a 01 00 00       	jmp    11a20 <.L150+0x14>
    s_cons.state = S_ESC;
   11906:	c7 86 54 0b 00 00 01 	movl   $0x1,0xb54(%esi)
   1190d:	00 00 00 
    s_cons.numArgs = 0;
   11910:	c7 86 78 0b 00 00 00 	movl   $0x0,0xb78(%esi)
   11917:	00 00 00 
}
   1191a:	e9 01 01 00 00       	jmp    11a20 <.L150+0x14>
	numSpaces = TABWIDTH - (s_cons.col % TABWIDTH);
   1191f:	8b 96 44 0b 00 00    	mov    0xb44(%esi),%edx
   11925:	89 d0                	mov    %edx,%eax
   11927:	c1 f8 1f             	sar    $0x1f,%eax
   1192a:	c1 e8 1d             	shr    $0x1d,%eax
   1192d:	01 c2                	add    %eax,%edx
   1192f:	83 e2 07             	and    $0x7,%edx
	while (numSpaces-- > 0)
   11932:	29 d0                	sub    %edx,%eax
   11934:	8d 78 07             	lea    0x7(%eax),%edi
	    Put_Graphic_Char(' ');
   11937:	b8 20 00 00 00       	mov    $0x20,%eax
   1193c:	e8 49 f5 ff ff       	call   10e8a <Put_Graphic_Char>
	while (numSpaces-- > 0)
   11941:	83 ef 01             	sub    $0x1,%edi
   11944:	83 ff ff             	cmp    $0xffffffff,%edi
   11947:	75 ee                	jne    11937 <.L137+0x65>
   11949:	eb a0                	jmp    118eb <.L137+0x19>
	Put_Graphic_Char(c);
   1194b:	89 d8                	mov    %ebx,%eax
   1194d:	e8 38 f5 ff ff       	call   10e8a <Put_Graphic_Char>
	break;
   11952:	eb 97                	jmp    118eb <.L137+0x19>

00011954 <.L136>:
	if (c == '[')
   11954:	83 fb 5b             	cmp    $0x5b,%ebx
   11957:	75 0f                	jne    11968 <.L136+0x14>
	    s_cons.state = S_ESC2;
   11959:	c7 86 54 0b 00 00 02 	movl   $0x2,0xb54(%esi)
   11960:	00 00 00 
   11963:	e9 b8 00 00 00       	jmp    11a20 <.L150+0x14>
    s_cons.state = S_NORMAL;
   11968:	c7 86 54 0b 00 00 00 	movl   $0x0,0xb54(%esi)
   1196f:	00 00 00 
    s_cons.numArgs = 0;
   11972:	c7 86 78 0b 00 00 00 	movl   $0x0,0xb78(%esi)
   11979:	00 00 00 
}
   1197c:	e9 9f 00 00 00       	jmp    11a20 <.L150+0x14>

00011981 <.L135>:
	if (ISDIGIT(c)) {
   11981:	83 fd 09             	cmp    $0x9,%ebp
   11984:	76 12                	jbe    11998 <.L135+0x17>
	} else if (c == ';') {
   11986:	83 fb 3b             	cmp    $0x3b,%ebx
   11989:	74 1c                	je     119a7 <.L135+0x26>
	    s_cons.state = S_CMD;
   1198b:	c7 44 3e 14 04 00 00 	movl   $0x4,0x14(%esi,%edi,1)
   11992:	00 
	    goto again;
   11993:	e9 20 ff ff ff       	jmp    118b8 <Put_Char_Imp+0x1d>
	    Start_Arg(0);
   11998:	b8 00 00 00 00       	mov    $0x0,%eax
   1199d:	e8 92 fa ff ff       	call   11434 <Start_Arg>
	    goto again;
   119a2:	e9 11 ff ff ff       	jmp    118b8 <Put_Char_Imp+0x1d>
	    Start_Arg(0);
   119a7:	b8 00 00 00 00       	mov    $0x0,%eax
   119ac:	e8 83 fa ff ff       	call   11434 <Start_Arg>
	    Add_Digit('1');
   119b1:	b8 31 00 00 00       	mov    $0x31,%eax
   119b6:	e8 fa f9 ff ff       	call   113b5 <Add_Digit>
	    Start_Arg(1);
   119bb:	b8 01 00 00 00       	mov    $0x1,%eax
   119c0:	e8 6f fa ff ff       	call   11434 <Start_Arg>
	break;
   119c5:	eb 59                	jmp    11a20 <.L150+0x14>

000119c7 <.L134>:
	if (ISDIGIT(c))
   119c7:	83 fd 09             	cmp    $0x9,%ebp
   119ca:	76 12                	jbe    119de <.L134+0x17>
	else if (c == ';')
   119cc:	83 fb 3b             	cmp    $0x3b,%ebx
   119cf:	74 16                	je     119e7 <.L134+0x20>
	    s_cons.state = S_CMD;
   119d1:	c7 44 3e 14 04 00 00 	movl   $0x4,0x14(%esi,%edi,1)
   119d8:	00 
	    goto again;
   119d9:	e9 da fe ff ff       	jmp    118b8 <Put_Char_Imp+0x1d>
	    Add_Digit(c);
   119de:	89 d8                	mov    %ebx,%eax
   119e0:	e8 d0 f9 ff ff       	call   113b5 <Add_Digit>
   119e5:	eb 39                	jmp    11a20 <.L150+0x14>
	    Start_Arg(s_cons.numArgs);
   119e7:	8b 86 78 0b 00 00    	mov    0xb78(%esi),%eax
   119ed:	e8 42 fa ff ff       	call   11434 <Start_Arg>
   119f2:	eb 2c                	jmp    11a20 <.L150+0x14>

000119f4 <.L132>:
	switch (c) {
   119f4:	8d 43 bf             	lea    -0x41(%ebx),%eax
   119f7:	83 f8 34             	cmp    $0x34,%eax
   119fa:	77 10                	ja     11a0c <.L150>
   119fc:	89 f1                	mov    %esi,%ecx
   119fe:	03 8c 86 c8 75 ff ff 	add    -0x8a38(%esi,%eax,4),%ecx
   11a05:	ff e1                	jmp    *%ecx

00011a07 <.L156>:
	case 'K': Clear_To_EOL(); break;
   11a07:	e8 b7 f3 ff ff       	call   10dc3 <Clear_To_EOL>

00011a0c <.L150>:
    s_cons.state = S_NORMAL;
   11a0c:	c7 86 54 0b 00 00 00 	movl   $0x0,0xb54(%esi)
   11a13:	00 00 00 
    s_cons.numArgs = 0;
   11a16:	c7 86 78 0b 00 00 00 	movl   $0x0,0xb78(%esi)
   11a1d:	00 00 00 
}
   11a20:	83 c4 0c             	add    $0xc,%esp
   11a23:	5b                   	pop    %ebx
   11a24:	5e                   	pop    %esi
   11a25:	5f                   	pop    %edi
   11a26:	5d                   	pop    %ebp
   11a27:	c3                   	ret    

00011a28 <.L153>:
    s_cons.saveRow = s_cons.row;
   11a28:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
   11a2e:	89 86 48 0b 00 00    	mov    %eax,0xb48(%esi)
    s_cons.saveCol = s_cons.col;
   11a34:	8b 86 44 0b 00 00    	mov    0xb44(%esi),%eax
   11a3a:	89 86 4c 0b 00 00    	mov    %eax,0xb4c(%esi)
}
   11a40:	eb ca                	jmp    11a0c <.L150>

00011a42 <.L151>:
    s_cons.row = s_cons.saveRow;
   11a42:	8b 86 48 0b 00 00    	mov    0xb48(%esi),%eax
   11a48:	89 86 40 0b 00 00    	mov    %eax,0xb40(%esi)
    s_cons.col = s_cons.saveCol;
   11a4e:	8b 86 4c 0b 00 00    	mov    0xb4c(%esi),%eax
   11a54:	89 86 44 0b 00 00    	mov    %eax,0xb44(%esi)
}
   11a5a:	eb b0                	jmp    11a0c <.L150>

00011a5c <.L161>:
	case 'A': Move_Cursor(s_cons.row - Get_Arg(0), s_cons.col); break;
   11a5c:	8b 8e 44 0b 00 00    	mov    0xb44(%esi),%ecx
   11a62:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
    return argNum < s_cons.numArgs ? s_cons.argList[argNum] : 0;
   11a68:	ba 00 00 00 00       	mov    $0x0,%edx
   11a6d:	83 be 78 0b 00 00 00 	cmpl   $0x0,0xb78(%esi)
   11a74:	7e 06                	jle    11a7c <.L161+0x20>
   11a76:	8b 96 58 0b 00 00    	mov    0xb58(%esi),%edx
	case 'A': Move_Cursor(s_cons.row - Get_Arg(0), s_cons.col); break;
   11a7c:	29 d0                	sub    %edx,%eax
   11a7e:	89 ca                	mov    %ecx,%edx
   11a80:	e8 52 f4 ff ff       	call   10ed7 <Move_Cursor>
   11a85:	eb 85                	jmp    11a0c <.L150>

00011a87 <.L160>:
	case 'B': Move_Cursor(s_cons.row + Get_Arg(0), s_cons.col); break;
   11a87:	8b 8e 44 0b 00 00    	mov    0xb44(%esi),%ecx
   11a8d:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
    return argNum < s_cons.numArgs ? s_cons.argList[argNum] : 0;
   11a93:	ba 00 00 00 00       	mov    $0x0,%edx
   11a98:	83 be 78 0b 00 00 00 	cmpl   $0x0,0xb78(%esi)
   11a9f:	7e 06                	jle    11aa7 <.L160+0x20>
   11aa1:	8b 96 58 0b 00 00    	mov    0xb58(%esi),%edx
	case 'B': Move_Cursor(s_cons.row + Get_Arg(0), s_cons.col); break;
   11aa7:	01 d0                	add    %edx,%eax
   11aa9:	89 ca                	mov    %ecx,%edx
   11aab:	e8 27 f4 ff ff       	call   10ed7 <Move_Cursor>
   11ab0:	e9 57 ff ff ff       	jmp    11a0c <.L150>

00011ab5 <.L159>:
	case 'C': Move_Cursor(s_cons.row, s_cons.col + Get_Arg(0)); break;
   11ab5:	8b 96 44 0b 00 00    	mov    0xb44(%esi),%edx
    return argNum < s_cons.numArgs ? s_cons.argList[argNum] : 0;
   11abb:	b8 00 00 00 00       	mov    $0x0,%eax
   11ac0:	83 be 78 0b 00 00 00 	cmpl   $0x0,0xb78(%esi)
   11ac7:	7e 06                	jle    11acf <.L159+0x1a>
   11ac9:	8b 86 58 0b 00 00    	mov    0xb58(%esi),%eax
	case 'C': Move_Cursor(s_cons.row, s_cons.col + Get_Arg(0)); break;
   11acf:	01 c2                	add    %eax,%edx
   11ad1:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
   11ad7:	e8 fb f3 ff ff       	call   10ed7 <Move_Cursor>
   11adc:	e9 2b ff ff ff       	jmp    11a0c <.L150>

00011ae1 <.L158>:
	case 'D': Move_Cursor(s_cons.row, s_cons.col - Get_Arg(0)); break;
   11ae1:	8b 96 44 0b 00 00    	mov    0xb44(%esi),%edx
    return argNum < s_cons.numArgs ? s_cons.argList[argNum] : 0;
   11ae7:	b8 00 00 00 00       	mov    $0x0,%eax
   11aec:	83 be 78 0b 00 00 00 	cmpl   $0x0,0xb78(%esi)
   11af3:	7e 06                	jle    11afb <.L158+0x1a>
   11af5:	8b 86 58 0b 00 00    	mov    0xb58(%esi),%eax
	case 'D': Move_Cursor(s_cons.row, s_cons.col - Get_Arg(0)); break;
   11afb:	29 c2                	sub    %eax,%edx
   11afd:	8b 86 40 0b 00 00    	mov    0xb40(%esi),%eax
   11b03:	e8 cf f3 ff ff       	call   10ed7 <Move_Cursor>
   11b08:	e9 ff fe ff ff       	jmp    11a0c <.L150>

00011b0d <.L154>:
    int attr = s_cons.currentAttr & ~(BRIGHT);
   11b0d:	0f b6 86 50 0b 00 00 	movzbl 0xb50(%esi),%eax
   11b14:	83 e0 f7             	and    $0xfffffff7,%eax
    for (i = 0; i < s_cons.numArgs; ++i) {
   11b17:	8b 96 78 0b 00 00    	mov    0xb78(%esi),%edx
   11b1d:	85 d2                	test   %edx,%edx
   11b1f:	7e 5b                	jle    11b7c <.L154+0x6f>
   11b21:	8d 8e 40 0b 00 00    	lea    0xb40(%esi),%ecx
   11b27:	8d 1c 91             	lea    (%ecx,%edx,4),%ebx
	    attr = (attr & ~(0x7 << 4)) | (s_ansiToVgaColor[value - 40] << 4);
   11b2a:	8d 96 e8 76 ff ff    	lea    -0x8918(%esi),%edx
   11b30:	eb 2a                	jmp    11b5c <.L154+0x4f>
	    attr |= BRIGHT;
   11b32:	83 c8 08             	or     $0x8,%eax
   11b35:	eb 1e                	jmp    11b55 <.L154+0x48>
	else if (value >= 40 && value <= 47)
   11b37:	8d 7d d8             	lea    -0x28(%ebp),%edi
   11b3a:	83 ff 07             	cmp    $0x7,%edi
   11b3d:	77 16                	ja     11b55 <.L154+0x48>
	    attr = (attr & ~(0x7 << 4)) | (s_ansiToVgaColor[value - 40] << 4);
   11b3f:	83 e0 8f             	and    $0xffffff8f,%eax
   11b42:	89 c7                	mov    %eax,%edi
   11b44:	0f b6 44 15 d8       	movzbl -0x28(%ebp,%edx,1),%eax
   11b49:	c1 e0 04             	shl    $0x4,%eax
   11b4c:	09 f8                	or     %edi,%eax
   11b4e:	eb 05                	jmp    11b55 <.L154+0x48>
	    attr = DEFAULT_ATTRIBUTE;
   11b50:	b8 07 00 00 00       	mov    $0x7,%eax
    for (i = 0; i < s_cons.numArgs; ++i) {
   11b55:	83 c1 04             	add    $0x4,%ecx
   11b58:	39 d9                	cmp    %ebx,%ecx
   11b5a:	74 20                	je     11b7c <.L154+0x6f>
	int value = s_cons.argList[i];
   11b5c:	8b 69 18             	mov    0x18(%ecx),%ebp
	if (value == 0)
   11b5f:	85 ed                	test   %ebp,%ebp
   11b61:	74 ed                	je     11b50 <.L154+0x43>
	else if (value == 1)
   11b63:	83 fd 01             	cmp    $0x1,%ebp
   11b66:	74 ca                	je     11b32 <.L154+0x25>
	else if (value >= 30 && value <= 37)
   11b68:	8d 7d e2             	lea    -0x1e(%ebp),%edi
   11b6b:	83 ff 07             	cmp    $0x7,%edi
   11b6e:	77 c7                	ja     11b37 <.L154+0x2a>
	    attr = (attr & ~0x7) | s_ansiToVgaColor[value - 30];
   11b70:	83 e0 f8             	and    $0xfffffff8,%eax
   11b73:	0f b6 7c 15 e2       	movzbl -0x1e(%ebp,%edx,1),%edi
   11b78:	09 f8                	or     %edi,%eax
   11b7a:	eb d9                	jmp    11b55 <.L154+0x48>
    s_cons.currentAttr = attr;
   11b7c:	88 86 50 0b 00 00    	mov    %al,0xb50(%esi)
}
   11b82:	e9 85 fe ff ff       	jmp    11a0c <.L150>

00011b87 <.L155>:
	    if (s_cons.numArgs == 2) Move_Cursor(Get_Arg(0)-1, Get_Arg(1)-1); break;
   11b87:	83 be 78 0b 00 00 02 	cmpl   $0x2,0xb78(%esi)
   11b8e:	0f 85 78 fe ff ff    	jne    11a0c <.L150>
   11b94:	8b 96 5c 0b 00 00    	mov    0xb5c(%esi),%edx
   11b9a:	83 ea 01             	sub    $0x1,%edx
   11b9d:	8b 86 58 0b 00 00    	mov    0xb58(%esi),%eax
   11ba3:	83 e8 01             	sub    $0x1,%eax
   11ba6:	e8 2c f3 ff ff       	call   10ed7 <Move_Cursor>
   11bab:	e9 5c fe ff ff       	jmp    11a0c <.L150>

00011bb0 <.L157>:
	    if (s_cons.numArgs == 1 && Get_Arg(0) == 2) {
   11bb0:	83 be 78 0b 00 00 01 	cmpl   $0x1,0xb78(%esi)
   11bb7:	0f 85 4f fe ff ff    	jne    11a0c <.L150>
   11bbd:	83 be 58 0b 00 00 02 	cmpl   $0x2,0xb58(%esi)
   11bc4:	0f 85 42 fe ff ff    	jne    11a0c <.L150>
		Clear_Screen();
   11bca:	e8 31 fa ff ff       	call   11600 <Clear_Screen>
		Put_Cursor(0, 0);
   11bcf:	83 ec 08             	sub    $0x8,%esp
   11bd2:	6a 00                	push   $0x0
   11bd4:	6a 00                	push   $0x0
   11bd6:	e8 79 f6 ff ff       	call   11254 <Put_Cursor>
   11bdb:	83 c4 10             	add    $0x10,%esp
   11bde:	e9 29 fe ff ff       	jmp    11a0c <.L150>
	KASSERT(false);
   11be3:	83 ec 0c             	sub    $0xc,%esp
   11be6:	6a 4f                	push   $0x4f
   11be8:	e8 3c f5 ff ff       	call   11129 <Set_Current_Attr>
   11bed:	83 c4 0c             	add    $0xc,%esp
   11bf0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11bf6:	ff 30                	pushl  (%eax)
   11bf8:	ff 74 24 24          	pushl  0x24(%esp)
   11bfc:	68 5a 01 00 00       	push   $0x15a
   11c01:	8d 86 70 75 ff ff    	lea    -0x8a90(%esi),%eax
   11c07:	50                   	push   %eax
   11c08:	8d 86 ab 75 ff ff    	lea    -0x8a55(%esi),%eax
   11c0e:	50                   	push   %eax
   11c0f:	8d 86 b4 76 ff ff    	lea    -0x894c(%esi),%eax
   11c15:	50                   	push   %eax
   11c16:	8d 86 54 70 ff ff    	lea    -0x8fac(%esi),%eax
   11c1c:	50                   	push   %eax
   11c1d:	e8 b8 f3 ff ff       	call   10fda <Print>
   11c22:	83 c4 20             	add    $0x20,%esp
   11c25:	eb fe                	jmp    11c25 <.L157+0x75>

00011c27 <Put_Char>:
{
   11c27:	53                   	push   %ebx
   11c28:	83 ec 08             	sub    $0x8,%esp
   11c2b:	e8 e2 e5 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   11c30:	81 c3 d0 43 01 00    	add    $0x143d0,%ebx
    bool enabled = Interrupts_Enabled();
   11c36:	e8 11 e6 ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   11c3b:	84 c0                	test   %al,%al
   11c3d:	75 1c                	jne    11c5b <Put_Char+0x34>
    Put_Char_Imp(c);
   11c3f:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c43:	e8 53 fc ff ff       	call   1189b <Put_Char_Imp>
    Update_Cursor();
   11c48:	e8 c9 f2 ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   11c4d:	e8 fa e5 ff ff       	call   1024c <Interrupts_Enabled>
   11c52:	84 c0                	test   %al,%al
   11c54:	75 7a                	jne    11cd0 <Put_Char+0xa9>
}
   11c56:	83 c4 08             	add    $0x8,%esp
   11c59:	5b                   	pop    %ebx
   11c5a:	c3                   	ret    
	Disable_Interrupts();
   11c5b:	e8 ec e5 ff ff       	call   1024c <Interrupts_Enabled>
   11c60:	84 c0                	test   %al,%al
   11c62:	74 28                	je     11c8c <Put_Char+0x65>
    __asm__ __volatile__ ("cli");
   11c64:	fa                   	cli    
    Put_Char_Imp(c);
   11c65:	8b 44 24 10          	mov    0x10(%esp),%eax
   11c69:	e8 2d fc ff ff       	call   1189b <Put_Char_Imp>
    Update_Cursor();
   11c6e:	e8 a3 f2 ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   11c73:	e8 d4 e5 ff ff       	call   1024c <Interrupts_Enabled>
   11c78:	84 c0                	test   %al,%al
   11c7a:	75 54                	jne    11cd0 <Put_Char+0xa9>
	Enable_Interrupts();
   11c7c:	e8 cb e5 ff ff       	call   1024c <Interrupts_Enabled>
   11c81:	84 c0                	test   %al,%al
   11c83:	0f 85 8b 00 00 00    	jne    11d14 <Put_Char+0xed>
    __asm__ __volatile__ ("sti");
   11c89:	fb                   	sti    
}
   11c8a:	eb ca                	jmp    11c56 <Put_Char+0x2f>
	Disable_Interrupts();
   11c8c:	83 ec 0c             	sub    $0xc,%esp
   11c8f:	6a 4f                	push   $0x4f
   11c91:	e8 93 f4 ff ff       	call   11129 <Set_Current_Attr>
   11c96:	83 c4 0c             	add    $0xc,%esp
   11c99:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11c9f:	ff 30                	pushl  (%eax)
   11ca1:	ff 74 24 14          	pushl  0x14(%esp)
   11ca5:	68 8f 00 00 00       	push   $0x8f
   11caa:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11cb0:	50                   	push   %eax
   11cb1:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11cb7:	50                   	push   %eax
   11cb8:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11cbe:	50                   	push   %eax
   11cbf:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11cc5:	50                   	push   %eax
   11cc6:	e8 0f f3 ff ff       	call   10fda <Print>
   11ccb:	83 c4 20             	add    $0x20,%esp
   11cce:	eb fe                	jmp    11cce <Put_Char+0xa7>
    KASSERT(!Interrupts_Enabled());
   11cd0:	83 ec 0c             	sub    $0xc,%esp
   11cd3:	6a 4f                	push   $0x4f
   11cd5:	e8 4f f4 ff ff       	call   11129 <Set_Current_Attr>
   11cda:	83 c4 0c             	add    $0xc,%esp
   11cdd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11ce3:	ff 30                	pushl  (%eax)
   11ce5:	ff 74 24 14          	pushl  0x14(%esp)
   11ce9:	68 99 00 00 00       	push   $0x99
   11cee:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11cf4:	50                   	push   %eax
   11cf5:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11cfb:	50                   	push   %eax
   11cfc:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11d02:	50                   	push   %eax
   11d03:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11d09:	50                   	push   %eax
   11d0a:	e8 cb f2 ff ff       	call   10fda <Print>
   11d0f:	83 c4 20             	add    $0x20,%esp
   11d12:	eb fe                	jmp    11d12 <Put_Char+0xeb>
	Enable_Interrupts();
   11d14:	83 ec 0c             	sub    $0xc,%esp
   11d17:	6a 4f                	push   $0x4f
   11d19:	e8 0b f4 ff ff       	call   11129 <Set_Current_Attr>
   11d1e:	83 c4 0c             	add    $0xc,%esp
   11d21:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11d27:	ff 30                	pushl  (%eax)
   11d29:	ff 74 24 14          	pushl  0x14(%esp)
   11d2d:	68 9c 00 00 00       	push   $0x9c
   11d32:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11d38:	50                   	push   %eax
   11d39:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11d3f:	50                   	push   %eax
   11d40:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11d46:	50                   	push   %eax
   11d47:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11d4d:	50                   	push   %eax
   11d4e:	e8 87 f2 ff ff       	call   10fda <Print>
   11d53:	83 c4 20             	add    $0x20,%esp
   11d56:	eb fe                	jmp    11d56 <Put_Char+0x12f>

00011d58 <Put_String>:
{
   11d58:	57                   	push   %edi
   11d59:	56                   	push   %esi
   11d5a:	53                   	push   %ebx
   11d5b:	e8 b2 e4 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   11d60:	81 c3 a0 42 01 00    	add    $0x142a0,%ebx
   11d66:	8b 74 24 10          	mov    0x10(%esp),%esi
    bool enabled = Interrupts_Enabled();
   11d6a:	e8 dd e4 ff ff       	call   1024c <Interrupts_Enabled>
   11d6f:	89 c7                	mov    %eax,%edi
    if (enabled)
   11d71:	84 c0                	test   %al,%al
   11d73:	75 35                	jne    11daa <Put_String+0x52>
    while (*s != '\0')
   11d75:	0f b6 06             	movzbl (%esi),%eax
   11d78:	84 c0                	test   %al,%al
   11d7a:	74 12                	je     11d8e <Put_String+0x36>
	Put_Char_Imp(*s++);
   11d7c:	83 c6 01             	add    $0x1,%esi
   11d7f:	0f be c0             	movsbl %al,%eax
   11d82:	e8 14 fb ff ff       	call   1189b <Put_Char_Imp>
    while (*s != '\0')
   11d87:	0f b6 06             	movzbl (%esi),%eax
   11d8a:	84 c0                	test   %al,%al
   11d8c:	75 ee                	jne    11d7c <Put_String+0x24>
    Update_Cursor();
   11d8e:	e8 83 f1 ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   11d93:	e8 b4 e4 ff ff       	call   1024c <Interrupts_Enabled>
   11d98:	84 c0                	test   %al,%al
   11d9a:	75 5e                	jne    11dfa <Put_String+0xa2>
    if (iflag) {
   11d9c:	89 f8                	mov    %edi,%eax
   11d9e:	84 c0                	test   %al,%al
   11da0:	0f 85 98 00 00 00    	jne    11e3e <Put_String+0xe6>
}
   11da6:	5b                   	pop    %ebx
   11da7:	5e                   	pop    %esi
   11da8:	5f                   	pop    %edi
   11da9:	c3                   	ret    
	Disable_Interrupts();
   11daa:	e8 9d e4 ff ff       	call   1024c <Interrupts_Enabled>
   11daf:	84 c0                	test   %al,%al
   11db1:	74 03                	je     11db6 <Put_String+0x5e>
    __asm__ __volatile__ ("cli");
   11db3:	fa                   	cli    
}
   11db4:	eb bf                	jmp    11d75 <Put_String+0x1d>
	Disable_Interrupts();
   11db6:	83 ec 0c             	sub    $0xc,%esp
   11db9:	6a 4f                	push   $0x4f
   11dbb:	e8 69 f3 ff ff       	call   11129 <Set_Current_Attr>
   11dc0:	83 c4 0c             	add    $0xc,%esp
   11dc3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11dc9:	ff 30                	pushl  (%eax)
   11dcb:	ff 74 24 14          	pushl  0x14(%esp)
   11dcf:	68 8f 00 00 00       	push   $0x8f
   11dd4:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11dda:	50                   	push   %eax
   11ddb:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11de1:	50                   	push   %eax
   11de2:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11de8:	50                   	push   %eax
   11de9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11def:	50                   	push   %eax
   11df0:	e8 e5 f1 ff ff       	call   10fda <Print>
   11df5:	83 c4 20             	add    $0x20,%esp
   11df8:	eb fe                	jmp    11df8 <Put_String+0xa0>
    KASSERT(!Interrupts_Enabled());
   11dfa:	83 ec 0c             	sub    $0xc,%esp
   11dfd:	6a 4f                	push   $0x4f
   11dff:	e8 25 f3 ff ff       	call   11129 <Set_Current_Attr>
   11e04:	83 c4 0c             	add    $0xc,%esp
   11e07:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11e0d:	ff 30                	pushl  (%eax)
   11e0f:	ff 74 24 14          	pushl  0x14(%esp)
   11e13:	68 99 00 00 00       	push   $0x99
   11e18:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11e1e:	50                   	push   %eax
   11e1f:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11e25:	50                   	push   %eax
   11e26:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11e2c:	50                   	push   %eax
   11e2d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11e33:	50                   	push   %eax
   11e34:	e8 a1 f1 ff ff       	call   10fda <Print>
   11e39:	83 c4 20             	add    $0x20,%esp
   11e3c:	eb fe                	jmp    11e3c <Put_String+0xe4>
	Enable_Interrupts();
   11e3e:	e8 09 e4 ff ff       	call   1024c <Interrupts_Enabled>
   11e43:	84 c0                	test   %al,%al
   11e45:	75 06                	jne    11e4d <Put_String+0xf5>
    __asm__ __volatile__ ("sti");
   11e47:	fb                   	sti    
   11e48:	e9 59 ff ff ff       	jmp    11da6 <Put_String+0x4e>
	Enable_Interrupts();
   11e4d:	83 ec 0c             	sub    $0xc,%esp
   11e50:	6a 4f                	push   $0x4f
   11e52:	e8 d2 f2 ff ff       	call   11129 <Set_Current_Attr>
   11e57:	83 c4 0c             	add    $0xc,%esp
   11e5a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11e60:	ff 30                	pushl  (%eax)
   11e62:	ff 74 24 14          	pushl  0x14(%esp)
   11e66:	68 9c 00 00 00       	push   $0x9c
   11e6b:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11e71:	50                   	push   %eax
   11e72:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11e78:	50                   	push   %eax
   11e79:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11e7f:	50                   	push   %eax
   11e80:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11e86:	50                   	push   %eax
   11e87:	e8 4e f1 ff ff       	call   10fda <Print>
   11e8c:	83 c4 20             	add    $0x20,%esp
   11e8f:	eb fe                	jmp    11e8f <Put_String+0x137>

00011e91 <Put_Buf>:
{
   11e91:	55                   	push   %ebp
   11e92:	57                   	push   %edi
   11e93:	56                   	push   %esi
   11e94:	53                   	push   %ebx
   11e95:	83 ec 0c             	sub    $0xc,%esp
   11e98:	e8 75 e3 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   11e9d:	81 c3 63 41 01 00    	add    $0x14163,%ebx
   11ea3:	8b 74 24 20          	mov    0x20(%esp),%esi
   11ea7:	8b 7c 24 24          	mov    0x24(%esp),%edi
    bool enabled = Interrupts_Enabled();
   11eab:	e8 9c e3 ff ff       	call   1024c <Interrupts_Enabled>
   11eb0:	89 c5                	mov    %eax,%ebp
    if (enabled)
   11eb2:	84 c0                	test   %al,%al
   11eb4:	75 36                	jne    11eec <Put_Buf+0x5b>
    while (length > 0) {
   11eb6:	85 ff                	test   %edi,%edi
   11eb8:	74 12                	je     11ecc <Put_Buf+0x3b>
   11eba:	01 f7                	add    %esi,%edi
	Put_Char_Imp(*buf++);
   11ebc:	83 c6 01             	add    $0x1,%esi
   11ebf:	0f be 46 ff          	movsbl -0x1(%esi),%eax
   11ec3:	e8 d3 f9 ff ff       	call   1189b <Put_Char_Imp>
    while (length > 0) {
   11ec8:	39 f7                	cmp    %esi,%edi
   11eca:	75 f0                	jne    11ebc <Put_Buf+0x2b>
    Update_Cursor();
   11ecc:	e8 45 f0 ff ff       	call   10f16 <Update_Cursor>
    KASSERT(!Interrupts_Enabled());
   11ed1:	e8 76 e3 ff ff       	call   1024c <Interrupts_Enabled>
   11ed6:	84 c0                	test   %al,%al
   11ed8:	75 62                	jne    11f3c <Put_Buf+0xab>
    if (iflag) {
   11eda:	89 e8                	mov    %ebp,%eax
   11edc:	84 c0                	test   %al,%al
   11ede:	0f 85 9c 00 00 00    	jne    11f80 <Put_Buf+0xef>
}
   11ee4:	83 c4 0c             	add    $0xc,%esp
   11ee7:	5b                   	pop    %ebx
   11ee8:	5e                   	pop    %esi
   11ee9:	5f                   	pop    %edi
   11eea:	5d                   	pop    %ebp
   11eeb:	c3                   	ret    
	Disable_Interrupts();
   11eec:	e8 5b e3 ff ff       	call   1024c <Interrupts_Enabled>
   11ef1:	84 c0                	test   %al,%al
   11ef3:	74 03                	je     11ef8 <Put_Buf+0x67>
    __asm__ __volatile__ ("cli");
   11ef5:	fa                   	cli    
}
   11ef6:	eb be                	jmp    11eb6 <Put_Buf+0x25>
	Disable_Interrupts();
   11ef8:	83 ec 0c             	sub    $0xc,%esp
   11efb:	6a 4f                	push   $0x4f
   11efd:	e8 27 f2 ff ff       	call   11129 <Set_Current_Attr>
   11f02:	83 c4 0c             	add    $0xc,%esp
   11f05:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11f0b:	ff 30                	pushl  (%eax)
   11f0d:	ff 74 24 24          	pushl  0x24(%esp)
   11f11:	68 8f 00 00 00       	push   $0x8f
   11f16:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11f1c:	50                   	push   %eax
   11f1d:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   11f23:	50                   	push   %eax
   11f24:	8d 83 d4 76 ff ff    	lea    -0x892c(%ebx),%eax
   11f2a:	50                   	push   %eax
   11f2b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11f31:	50                   	push   %eax
   11f32:	e8 a3 f0 ff ff       	call   10fda <Print>
   11f37:	83 c4 20             	add    $0x20,%esp
   11f3a:	eb fe                	jmp    11f3a <Put_Buf+0xa9>
    KASSERT(!Interrupts_Enabled());
   11f3c:	83 ec 0c             	sub    $0xc,%esp
   11f3f:	6a 4f                	push   $0x4f
   11f41:	e8 e3 f1 ff ff       	call   11129 <Set_Current_Attr>
   11f46:	83 c4 0c             	add    $0xc,%esp
   11f49:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11f4f:	ff 30                	pushl  (%eax)
   11f51:	ff 74 24 24          	pushl  0x24(%esp)
   11f55:	68 99 00 00 00       	push   $0x99
   11f5a:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11f60:	50                   	push   %eax
   11f61:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11f67:	50                   	push   %eax
   11f68:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11f6e:	50                   	push   %eax
   11f6f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11f75:	50                   	push   %eax
   11f76:	e8 5f f0 ff ff       	call   10fda <Print>
   11f7b:	83 c4 20             	add    $0x20,%esp
   11f7e:	eb fe                	jmp    11f7e <Put_Buf+0xed>
	Enable_Interrupts();
   11f80:	e8 c7 e2 ff ff       	call   1024c <Interrupts_Enabled>
   11f85:	84 c0                	test   %al,%al
   11f87:	75 06                	jne    11f8f <Put_Buf+0xfe>
    __asm__ __volatile__ ("sti");
   11f89:	fb                   	sti    
   11f8a:	e9 55 ff ff ff       	jmp    11ee4 <Put_Buf+0x53>
	Enable_Interrupts();
   11f8f:	83 ec 0c             	sub    $0xc,%esp
   11f92:	6a 4f                	push   $0x4f
   11f94:	e8 90 f1 ff ff       	call   11129 <Set_Current_Attr>
   11f99:	83 c4 0c             	add    $0xc,%esp
   11f9c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   11fa2:	ff 30                	pushl  (%eax)
   11fa4:	ff 74 24 24          	pushl  0x24(%esp)
   11fa8:	68 9c 00 00 00       	push   $0x9c
   11fad:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   11fb3:	50                   	push   %eax
   11fb4:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   11fba:	50                   	push   %eax
   11fbb:	8d 83 c4 76 ff ff    	lea    -0x893c(%ebx),%eax
   11fc1:	50                   	push   %eax
   11fc2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   11fc8:	50                   	push   %eax
   11fc9:	e8 0c f0 ff ff       	call   10fda <Print>
   11fce:	83 c4 20             	add    $0x20,%esp
   11fd1:	eb fe                	jmp    11fd1 <Put_Buf+0x140>

00011fd3 <Print_Emit>:
static void Print_Emit(struct Output_Sink *o, int ch) { Put_Char_Imp(ch); }
   11fd3:	83 ec 0c             	sub    $0xc,%esp
   11fd6:	8b 44 24 14          	mov    0x14(%esp),%eax
   11fda:	e8 bc f8 ff ff       	call   1189b <Put_Char_Imp>
   11fdf:	83 c4 0c             	add    $0xc,%esp
   11fe2:	c3                   	ret    

00011fe3 <__x86.get_pc_thunk.dx>:
   11fe3:	8b 14 24             	mov    (%esp),%edx
   11fe6:	c3                   	ret    

00011fe7 <__x86.get_pc_thunk.cx>:
   11fe7:	8b 0c 24             	mov    (%esp),%ecx
   11fea:	c3                   	ret    

00011feb <Spin>:
     * We rely on EAX being used as the counter
     * variable.
     */

    int result;
    __asm__ __volatile__ (
   11feb:	48                   	dec    %eax
   11fec:	83 f8 00             	cmp    $0x0,%eax
   11fef:	90                   	nop
   11ff0:	90                   	nop
   11ff1:	90                   	nop
   11ff2:	90                   	nop
   11ff3:	90                   	nop
   11ff4:	90                   	nop
   11ff5:	90                   	nop
   11ff6:	90                   	nop
   11ff7:	90                   	nop
   11ff8:	90                   	nop
   11ff9:	90                   	nop
   11ffa:	90                   	nop
   11ffb:	7f ee                	jg     11feb <Spin>
	"nop; nop; nop; nop; nop; nop\n\t"
	"jg 1b"
	: "=a" (result)
	: "a" (count)
    );
}
   11ffd:	c3                   	ret    

00011ffe <Timer_Interrupt_Handler>:
{
   11ffe:	57                   	push   %edi
   11fff:	56                   	push   %esi
   12000:	53                   	push   %ebx
   12001:	e8 0c e2 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12006:	81 c3 fa 3f 01 00    	add    $0x13ffa,%ebx
   1200c:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct Kernel_Thread* current = g_currentThread;
   12010:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12016:	8b 30                	mov    (%eax),%esi
    Begin_IRQ(state);
   12018:	83 ec 0c             	sub    $0xc,%esp
   1201b:	57                   	push   %edi
   1201c:	e8 48 e8 ff ff       	call   10869 <Begin_IRQ>
    ++g_numTicks;
   12021:	c7 c2 80 77 02 00    	mov    $0x27780,%edx
   12027:	8b 02                	mov    (%edx),%eax
   12029:	83 c0 01             	add    $0x1,%eax
   1202c:	89 02                	mov    %eax,(%edx)
    ++current->numTicks;
   1202e:	8b 46 04             	mov    0x4(%esi),%eax
   12031:	83 c0 01             	add    $0x1,%eax
   12034:	89 46 04             	mov    %eax,0x4(%esi)
    if (current->numTicks >= g_Quantum) {
   12037:	8b 46 04             	mov    0x4(%esi),%eax
   1203a:	83 c4 10             	add    $0x10,%esp
   1203d:	3b 83 2c 00 00 00    	cmp    0x2c(%ebx),%eax
   12043:	72 0c                	jb     12051 <Timer_Interrupt_Handler+0x53>
	g_needReschedule = true;
   12045:	c7 c0 94 77 02 00    	mov    $0x27794,%eax
   1204b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    End_IRQ(state);
   12051:	83 ec 0c             	sub    $0xc,%esp
   12054:	57                   	push   %edi
   12055:	e8 10 e8 ff ff       	call   1086a <End_IRQ>
}
   1205a:	83 c4 10             	add    $0x10,%esp
   1205d:	5b                   	pop    %ebx
   1205e:	5e                   	pop    %esi
   1205f:	5f                   	pop    %edi
   12060:	c3                   	ret    

00012061 <Timer_Calibrate>:
{
   12061:	56                   	push   %esi
   12062:	53                   	push   %ebx
   12063:	83 ec 10             	sub    $0x10,%esp
   12066:	e8 a7 e1 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1206b:	81 c3 95 3f 01 00    	add    $0x13f95,%ebx
   12071:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    Begin_IRQ(state);
   12075:	56                   	push   %esi
   12076:	e8 ee e7 ff ff       	call   10869 <Begin_IRQ>
    if (g_numTicks < CALIBRATE_NUM_TICKS)
   1207b:	c7 c0 80 77 02 00    	mov    $0x27780,%eax
   12081:	8b 00                	mov    (%eax),%eax
   12083:	83 c4 10             	add    $0x10,%esp
   12086:	83 f8 02             	cmp    $0x2,%eax
   12089:	77 1c                	ja     120a7 <Timer_Calibrate+0x46>
	++g_numTicks;
   1208b:	c7 c2 80 77 02 00    	mov    $0x27780,%edx
   12091:	8b 02                	mov    (%edx),%eax
   12093:	83 c0 01             	add    $0x1,%eax
   12096:	89 02                	mov    %eax,(%edx)
    End_IRQ(state);
   12098:	83 ec 0c             	sub    $0xc,%esp
   1209b:	56                   	push   %esi
   1209c:	e8 c9 e7 ff ff       	call   1086a <End_IRQ>
}
   120a1:	83 c4 14             	add    $0x14,%esp
   120a4:	5b                   	pop    %ebx
   120a5:	5e                   	pop    %esi
   120a6:	c3                   	ret    
	s_spinCountPerTick = INT_MAX  - state->eax;
   120a7:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
   120ac:	2b 46 28             	sub    0x28(%esi),%eax
   120af:	89 83 7c 0b 00 00    	mov    %eax,0xb7c(%ebx)
	state->eax = 0;  /* make the loop terminate */
   120b5:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
   120bc:	eb da                	jmp    12098 <Timer_Calibrate+0x37>

000120be <Init_Timer>:
/* ----------------------------------------------------------------------
 * Public functions
 * ---------------------------------------------------------------------- */

void Init_Timer(void)
{
   120be:	53                   	push   %ebx
   120bf:	83 ec 14             	sub    $0x14,%esp
   120c2:	e8 4b e1 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   120c7:	81 c3 39 3f 01 00    	add    $0x13f39,%ebx
     * TODO: reprogram the timer to set the frequency.
     * In bochs, it defaults to 18Hz, which is actually pretty
     * reasonable.
     */

    Print("Initializing timer...\n");
   120cd:	8d 83 f0 76 ff ff    	lea    -0x8910(%ebx),%eax
   120d3:	50                   	push   %eax
   120d4:	e8 01 ef ff ff       	call   10fda <Print>
    Disable_Interrupts();
   120d9:	e8 6e e1 ff ff       	call   1024c <Interrupts_Enabled>
   120de:	83 c4 10             	add    $0x10,%esp
   120e1:	84 c0                	test   %al,%al
   120e3:	75 44                	jne    12129 <Init_Timer+0x6b>
   120e5:	83 ec 0c             	sub    $0xc,%esp
   120e8:	6a 4f                	push   $0x4f
   120ea:	e8 3a f0 ff ff       	call   11129 <Set_Current_Attr>
   120ef:	83 c4 0c             	add    $0xc,%esp
   120f2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   120f8:	ff 30                	pushl  (%eax)
   120fa:	ff 74 24 14          	pushl  0x14(%esp)
   120fe:	68 8a 00 00 00       	push   $0x8a
   12103:	8d 83 07 77 ff ff    	lea    -0x88f9(%ebx),%eax
   12109:	50                   	push   %eax
   1210a:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   12110:	50                   	push   %eax
   12111:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
   12117:	50                   	push   %eax
   12118:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1211e:	50                   	push   %eax
   1211f:	e8 b6 ee ff ff       	call   10fda <Print>
   12124:	83 c4 20             	add    $0x20,%esp
   12127:	eb fe                	jmp    12127 <Init_Timer+0x69>
    __asm__ __volatile__ ("cli");
   12129:	fa                   	cli    
    Install_IRQ(TIMER_IRQ, &Timer_Calibrate);
   1212a:	83 ec 08             	sub    $0x8,%esp
   1212d:	8d 83 61 c0 fe ff    	lea    -0x13f9f(%ebx),%eax
   12133:	50                   	push   %eax
   12134:	6a 00                	push   $0x0
   12136:	e8 9c e3 ff ff       	call   104d7 <Install_IRQ>
    Enable_IRQ(TIMER_IRQ);
   1213b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   12142:	e8 28 e4 ff ff       	call   1056f <Enable_IRQ>
    Enable_Interrupts();
   12147:	e8 00 e1 ff ff       	call   1024c <Interrupts_Enabled>
   1214c:	83 c4 10             	add    $0x10,%esp
   1214f:	84 c0                	test   %al,%al
   12151:	75 69                	jne    121bc <Init_Timer+0xfe>
    __asm__ __volatile__ ("sti");
   12153:	fb                   	sti    
    while (g_numTicks < CALIBRATE_NUM_TICKS)
   12154:	c7 c2 80 77 02 00    	mov    $0x27780,%edx
   1215a:	8b 02                	mov    (%edx),%eax
   1215c:	83 f8 02             	cmp    $0x2,%eax
   1215f:	76 f9                	jbe    1215a <Init_Timer+0x9c>
    Spin(INT_MAX);
   12161:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
   12166:	e8 80 fe ff ff       	call   11feb <Spin>
    Disable_Interrupts();
   1216b:	e8 dc e0 ff ff       	call   1024c <Interrupts_Enabled>
   12170:	84 c0                	test   %al,%al
   12172:	0f 85 88 00 00 00    	jne    12200 <Init_Timer+0x142>
   12178:	83 ec 0c             	sub    $0xc,%esp
   1217b:	6a 4f                	push   $0x4f
   1217d:	e8 a7 ef ff ff       	call   11129 <Set_Current_Attr>
   12182:	83 c4 0c             	add    $0xc,%esp
   12185:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1218b:	ff 30                	pushl  (%eax)
   1218d:	ff 74 24 14          	pushl  0x14(%esp)
   12191:	68 9d 00 00 00       	push   $0x9d
   12196:	8d 83 07 77 ff ff    	lea    -0x88f9(%ebx),%eax
   1219c:	50                   	push   %eax
   1219d:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   121a3:	50                   	push   %eax
   121a4:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
   121aa:	50                   	push   %eax
   121ab:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   121b1:	50                   	push   %eax
   121b2:	e8 23 ee ff ff       	call   10fda <Print>
   121b7:	83 c4 20             	add    $0x20,%esp
   121ba:	eb fe                	jmp    121ba <Init_Timer+0xfc>
    Enable_Interrupts();
   121bc:	83 ec 0c             	sub    $0xc,%esp
   121bf:	6a 4f                	push   $0x4f
   121c1:	e8 63 ef ff ff       	call   11129 <Set_Current_Attr>
   121c6:	83 c4 0c             	add    $0xc,%esp
   121c9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   121cf:	ff 30                	pushl  (%eax)
   121d1:	ff 74 24 14          	pushl  0x14(%esp)
   121d5:	68 90 00 00 00       	push   $0x90
   121da:	8d 83 07 77 ff ff    	lea    -0x88f9(%ebx),%eax
   121e0:	50                   	push   %eax
   121e1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   121e7:	50                   	push   %eax
   121e8:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
   121ee:	50                   	push   %eax
   121ef:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   121f5:	50                   	push   %eax
   121f6:	e8 df ed ff ff       	call   10fda <Print>
   121fb:	83 c4 20             	add    $0x20,%esp
   121fe:	eb fe                	jmp    121fe <Init_Timer+0x140>
    __asm__ __volatile__ ("cli");
   12200:	fa                   	cli    
    Disable_IRQ(TIMER_IRQ);
   12201:	83 ec 0c             	sub    $0xc,%esp
   12204:	6a 00                	push   $0x0
   12206:	e8 e1 e4 ff ff       	call   106ec <Disable_IRQ>
    Enable_Interrupts();
   1220b:	e8 3c e0 ff ff       	call   1024c <Interrupts_Enabled>
   12210:	83 c4 10             	add    $0x10,%esp
   12213:	84 c0                	test   %al,%al
   12215:	75 38                	jne    1224f <Init_Timer+0x191>
    __asm__ __volatile__ ("sti");
   12217:	fb                   	sti    


    /* Calibrate for delay loop */
    Calibrate_Delay();
    Print("Delay loop: %d iterations per tick\n", s_spinCountPerTick);
   12218:	83 ec 08             	sub    $0x8,%esp
   1221b:	ff b3 7c 0b 00 00    	pushl  0xb7c(%ebx)
   12221:	8d 83 20 77 ff ff    	lea    -0x88e0(%ebx),%eax
   12227:	50                   	push   %eax
   12228:	e8 ad ed ff ff       	call   10fda <Print>

    /* Install an interrupt handler for the timer IRQ */
    Install_IRQ(TIMER_IRQ, &Timer_Interrupt_Handler);
   1222d:	83 c4 08             	add    $0x8,%esp
   12230:	8d 83 fe bf fe ff    	lea    -0x14002(%ebx),%eax
   12236:	50                   	push   %eax
   12237:	6a 00                	push   $0x0
   12239:	e8 99 e2 ff ff       	call   104d7 <Install_IRQ>
    Enable_IRQ(TIMER_IRQ);
   1223e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
   12245:	e8 25 e3 ff ff       	call   1056f <Enable_IRQ>
}
   1224a:	83 c4 18             	add    $0x18,%esp
   1224d:	5b                   	pop    %ebx
   1224e:	c3                   	ret    
    Enable_Interrupts();
   1224f:	83 ec 0c             	sub    $0xc,%esp
   12252:	6a 4f                	push   $0x4f
   12254:	e8 d0 ee ff ff       	call   11129 <Set_Current_Attr>
   12259:	83 c4 0c             	add    $0xc,%esp
   1225c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12262:	ff 30                	pushl  (%eax)
   12264:	ff 74 24 14          	pushl  0x14(%esp)
   12268:	68 a4 00 00 00       	push   $0xa4
   1226d:	8d 83 07 77 ff ff    	lea    -0x88f9(%ebx),%eax
   12273:	50                   	push   %eax
   12274:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1227a:	50                   	push   %eax
   1227b:	8d 83 44 77 ff ff    	lea    -0x88bc(%ebx),%eax
   12281:	50                   	push   %eax
   12282:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12288:	50                   	push   %eax
   12289:	e8 4c ed ff ff       	call   10fda <Print>
   1228e:	83 c4 20             	add    $0x20,%esp
   12291:	eb fe                	jmp    12291 <Init_Timer+0x1d3>

00012293 <Micro_Delay>:
 * Spin for at least given number of microseconds.
 * FIXME: I'm sure this implementation leaves a lot to
 * be desired.
 */
void Micro_Delay(int us)
{
   12293:	e8 2e e6 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   12298:	05 68 3d 01 00       	add    $0x13d68,%eax
    int num = us * s_spinCountPerTick;
   1229d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   122a1:	0f af 88 7c 0b 00 00 	imul   0xb7c(%eax),%ecx
    int denom = US_PER_TICK;

    int numSpins = num / denom;
   122a8:	ba 5b fd 4d 77       	mov    $0x774dfd5b,%edx
   122ad:	89 c8                	mov    %ecx,%eax
   122af:	f7 ea                	imul   %edx
   122b1:	89 d0                	mov    %edx,%eax
   122b3:	c1 f8 17             	sar    $0x17,%eax
   122b6:	89 ca                	mov    %ecx,%edx
   122b8:	c1 fa 1f             	sar    $0x1f,%edx
   122bb:	29 d0                	sub    %edx,%eax
    int rem = num % denom;
   122bd:	69 d0 80 a8 12 01    	imul   $0x112a880,%eax,%edx
   122c3:	29 d1                	sub    %edx,%ecx

    if (rem > 0)
	++numSpins;
   122c5:	85 c9                	test   %ecx,%ecx
   122c7:	0f 9f c2             	setg   %dl
   122ca:	0f b6 d2             	movzbl %dl,%edx
   122cd:	01 d0                	add    %edx,%eax

    Debug("Micro_Delay(): num=%d, denom=%d, spin count = %d\n", num, denom, numSpins);

    Spin(numSpins);
   122cf:	e8 17 fd ff ff       	call   11feb <Spin>
}
   122d4:	c3                   	ret    

000122d5 <Add_Page_Range>:

/*
 * Add a range of pages to the inventory of physical memory.
 */
static void Add_Page_Range(ulong_t start, ulong_t end, int flags)
{
   122d5:	55                   	push   %ebp
   122d6:	57                   	push   %edi
   122d7:	56                   	push   %esi
   122d8:	53                   	push   %ebx
   122d9:	83 ec 0c             	sub    $0xc,%esp
   122dc:	e8 31 df ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   122e1:	81 c3 1f 3d 01 00    	add    $0x13d1f,%ebx
    ulong_t addr;

    KASSERT(Is_Page_Multiple(start));
   122e7:	a9 ff 0f 00 00       	test   $0xfff,%eax
   122ec:	75 5f                	jne    1234d <Add_Page_Range+0x78>
   122ee:	89 c6                	mov    %eax,%esi
   122f0:	89 d7                	mov    %edx,%edi
    KASSERT(Is_Page_Multiple(end));
   122f2:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
   122f8:	0f 85 90 00 00 00    	jne    1238e <Add_Page_Range+0xb9>
 * Get the Page struct associated with given address.
 */
static __inline__ struct Page *Get_Page(ulong_t addr)
{
    extern struct Page* g_pageList;
    return &g_pageList[Page_Index(addr)];
   122fe:	c7 c5 84 77 02 00    	mov    $0x27784,%ebp
    KASSERT(start < end);
   12304:	39 d0                	cmp    %edx,%eax
   12306:	0f 82 60 01 00 00    	jb     1246c <Add_Page_Range+0x197>
   1230c:	83 ec 0c             	sub    $0xc,%esp
   1230f:	6a 4f                	push   $0x4f
   12311:	e8 13 ee ff ff       	call   11129 <Set_Current_Attr>
   12316:	83 c4 0c             	add    $0xc,%esp
   12319:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1231f:	ff 30                	pushl  (%eax)
   12321:	ff 74 24 24          	pushl  0x24(%esp)
   12325:	6a 41                	push   $0x41
   12327:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   1232d:	50                   	push   %eax
   1232e:	8d 83 96 77 ff ff    	lea    -0x886a(%ebx),%eax
   12334:	50                   	push   %eax
   12335:	8d 83 00 79 ff ff    	lea    -0x8700(%ebx),%eax
   1233b:	50                   	push   %eax
   1233c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12342:	50                   	push   %eax
   12343:	e8 92 ec ff ff       	call   10fda <Print>
   12348:	83 c4 20             	add    $0x20,%esp
   1234b:	eb fe                	jmp    1234b <Add_Page_Range+0x76>
    KASSERT(Is_Page_Multiple(start));
   1234d:	83 ec 0c             	sub    $0xc,%esp
   12350:	6a 4f                	push   $0x4f
   12352:	e8 d2 ed ff ff       	call   11129 <Set_Current_Attr>
   12357:	83 c4 0c             	add    $0xc,%esp
   1235a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12360:	ff 30                	pushl  (%eax)
   12362:	ff 74 24 24          	pushl  0x24(%esp)
   12366:	6a 3f                	push   $0x3f
   12368:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   1236e:	50                   	push   %eax
   1236f:	8d 83 68 77 ff ff    	lea    -0x8898(%ebx),%eax
   12375:	50                   	push   %eax
   12376:	8d 83 00 79 ff ff    	lea    -0x8700(%ebx),%eax
   1237c:	50                   	push   %eax
   1237d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12383:	50                   	push   %eax
   12384:	e8 51 ec ff ff       	call   10fda <Print>
   12389:	83 c4 20             	add    $0x20,%esp
   1238c:	eb fe                	jmp    1238c <Add_Page_Range+0xb7>
    KASSERT(Is_Page_Multiple(end));
   1238e:	83 ec 0c             	sub    $0xc,%esp
   12391:	6a 4f                	push   $0x4f
   12393:	e8 91 ed ff ff       	call   11129 <Set_Current_Attr>
   12398:	83 c4 0c             	add    $0xc,%esp
   1239b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   123a1:	ff 30                	pushl  (%eax)
   123a3:	ff 74 24 24          	pushl  0x24(%esp)
   123a7:	6a 40                	push   $0x40
   123a9:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   123af:	50                   	push   %eax
   123b0:	8d 83 80 77 ff ff    	lea    -0x8880(%ebx),%eax
   123b6:	50                   	push   %eax
   123b7:	8d 83 00 79 ff ff    	lea    -0x8700(%ebx),%eax
   123bd:	50                   	push   %eax
   123be:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   123c4:	50                   	push   %eax
   123c5:	e8 10 ec ff ff       	call   10fda <Print>
   123ca:	83 c4 20             	add    $0x20,%esp
   123cd:	eb fe                	jmp    123cd <Add_Page_Range+0xf8>
IMPLEMENT_LIST(Page_List, Page);
   123cf:	8b 93 84 0b 00 00    	mov    0xb84(%ebx),%edx
   123d5:	85 d2                	test   %edx,%edx
   123d7:	74 65                	je     1243e <Add_Page_Range+0x169>
   123d9:	39 d0                	cmp    %edx,%eax
   123db:	74 0b                	je     123e8 <Add_Page_Range+0x113>
   123dd:	8b 52 08             	mov    0x8(%edx),%edx
   123e0:	85 d2                	test   %edx,%edx
   123e2:	74 5a                	je     1243e <Add_Page_Range+0x169>
   123e4:	39 d0                	cmp    %edx,%eax
   123e6:	75 f5                	jne    123dd <Add_Page_Range+0x108>
   123e8:	83 ec 0c             	sub    $0xc,%esp
   123eb:	6a 4f                	push   $0x4f
   123ed:	e8 37 ed ff ff       	call   11129 <Set_Current_Attr>
   123f2:	83 c4 0c             	add    $0xc,%esp
   123f5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   123fb:	ff 30                	pushl  (%eax)
   123fd:	ff 74 24 24          	pushl  0x24(%esp)
   12401:	6a 3f                	push   $0x3f
   12403:	8d 83 a2 77 ff ff    	lea    -0x885e(%ebx),%eax
   12409:	50                   	push   %eax
   1240a:	8d 83 ec 77 ff ff    	lea    -0x8814(%ebx),%eax
   12410:	50                   	push   %eax
   12411:	8d 83 e4 78 ff ff    	lea    -0x871c(%ebx),%eax
   12417:	50                   	push   %eax
   12418:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1241e:	50                   	push   %eax
   1241f:	e8 b6 eb ff ff       	call   10fda <Print>
   12424:	83 c4 20             	add    $0x20,%esp
   12427:	eb fe                	jmp    12427 <Add_Page_Range+0x152>
   12429:	89 83 88 0b 00 00    	mov    %eax,0xb88(%ebx)
   1242f:	89 83 84 0b 00 00    	mov    %eax,0xb84(%ebx)
   12435:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1243c:	eb 1d                	jmp    1245b <Add_Page_Range+0x186>
   1243e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   12445:	8b 93 88 0b 00 00    	mov    0xb88(%ebx),%edx
   1244b:	85 d2                	test   %edx,%edx
   1244d:	74 da                	je     12429 <Add_Page_Range+0x154>
   1244f:	89 42 08             	mov    %eax,0x8(%edx)
   12452:	89 50 04             	mov    %edx,0x4(%eax)
   12455:	89 83 88 0b 00 00    	mov    %eax,0xb88(%ebx)
	if (flags == PAGE_AVAIL) {
	    /* Add the page to the freelist */
	    Add_To_Back_Of_Page_List(&s_freeList, page);

	    /* Update free page count */
	    ++g_freePageCount;
   1245b:	83 83 80 0b 00 00 01 	addl   $0x1,0xb80(%ebx)
    for (addr = start; addr < end; addr += PAGE_SIZE) {
   12462:	81 c6 00 10 00 00    	add    $0x1000,%esi
   12468:	39 f7                	cmp    %esi,%edi
   1246a:	76 28                	jbe    12494 <Add_Page_Range+0x1bf>
    return (int) (addr >> PAGE_POWER);
   1246c:	89 f0                	mov    %esi,%eax
   1246e:	c1 e8 0c             	shr    $0xc,%eax
    return &g_pageList[Page_Index(addr)];
   12471:	8d 14 40             	lea    (%eax,%eax,2),%edx
   12474:	8b 45 00             	mov    0x0(%ebp),%eax
   12477:	8d 04 90             	lea    (%eax,%edx,4),%eax
	page->flags = flags;
   1247a:	89 08                	mov    %ecx,(%eax)
	if (flags == PAGE_AVAIL) {
   1247c:	85 c9                	test   %ecx,%ecx
   1247e:	0f 84 4b ff ff ff    	je     123cf <Add_Page_Range+0xfa>
IMPLEMENT_LIST(Page_List, Page);
   12484:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   1248b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   12492:	eb ce                	jmp    12462 <Add_Page_Range+0x18d>
	    Set_Next_In_Page_List(page, 0);
	    Set_Prev_In_Page_List(page, 0);
	}

    }
}
   12494:	83 c4 0c             	add    $0xc,%esp
   12497:	5b                   	pop    %ebx
   12498:	5e                   	pop    %esi
   12499:	5f                   	pop    %edi
   1249a:	5d                   	pop    %ebp
   1249b:	c3                   	ret    

0001249c <Init_Mem>:
/*
 * Initialize memory management data structures.
 * Enables the use of Alloc_Page() and Free_Page() functions.
 */
void Init_Mem(struct Boot_Info* bootInfo)
{
   1249c:	55                   	push   %ebp
   1249d:	57                   	push   %edi
   1249e:	56                   	push   %esi
   1249f:	53                   	push   %ebx
   124a0:	83 ec 0c             	sub    $0xc,%esp
   124a3:	e8 6a dd ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   124a8:	81 c3 58 3b 01 00    	add    $0x13b58,%ebx
   124ae:	8b 6c 24 20          	mov    0x20(%esp),%ebp
    ulong_t numPages = bootInfo->memSizeKB >> 2;
   124b2:	8b 7d 04             	mov    0x4(%ebp),%edi
    ulong_t endOfMem = numPages * PAGE_SIZE;
    unsigned numPageListBytes = sizeof(struct Page) * numPages;
    ulong_t pageListAddr;
    ulong_t kernEnd;

    KASSERT(bootInfo->memSizeKB > 0);
   124b5:	85 ff                	test   %edi,%edi
   124b7:	0f 8e 2b 01 00 00    	jle    125e8 <Init_Mem+0x14c>

    /*
     * Before we do anything, switch from setup.asm's temporary GDT
     * to the kernel's permanent GDT.
     */
    Init_GDT();
   124bd:	e8 b2 09 00 00       	call   12e74 <Init_GDT>
     * We'll put the list of Page objects right after the end
     * of the kernel, and mark it as "kernel".  This will bootstrap
     * us sufficiently that we can start allocating pages and
     * keeping track of them.
     */
    pageListAddr = Round_Up_To_Page((ulong_t) &end);
   124c2:	c7 c0 b0 77 02 00    	mov    $0x277b0,%eax
    if ((addr & PAGE_MASK) != 0) {
   124c8:	89 c1                	mov    %eax,%ecx
   124ca:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
	addr += PAGE_SIZE;
   124d0:	89 c2                	mov    %eax,%edx
   124d2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
   124d8:	81 c2 00 10 00 00    	add    $0x1000,%edx
   124de:	85 c9                	test   %ecx,%ecx
   124e0:	0f 45 c2             	cmovne %edx,%eax
    ulong_t numPages = bootInfo->memSizeKB >> 2;
   124e3:	c1 ff 02             	sar    $0x2,%edi
    g_pageList = (struct Page*) pageListAddr;
   124e6:	c7 c2 84 77 02 00    	mov    $0x27784,%edx
   124ec:	89 02                	mov    %eax,(%edx)
    unsigned numPageListBytes = sizeof(struct Page) * numPages;
   124ee:	8d 14 7f             	lea    (%edi,%edi,2),%edx
   124f1:	c1 e2 02             	shl    $0x2,%edx
    kernEnd = Round_Up_To_Page(pageListAddr + numPageListBytes);
   124f4:	8d 34 02             	lea    (%edx,%eax,1),%esi
    if ((addr & PAGE_MASK) != 0) {
   124f7:	89 f1                	mov    %esi,%ecx
   124f9:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
	addr += PAGE_SIZE;
   124ff:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
   12505:	81 c6 00 10 00 00    	add    $0x1000,%esi
   1250b:	01 d0                	add    %edx,%eax
   1250d:	85 c9                	test   %ecx,%ecx
   1250f:	0f 44 f0             	cmove  %eax,%esi
    s_numPages = numPages;
   12512:	c7 c0 88 77 02 00    	mov    $0x27788,%eax
   12518:	89 38                	mov    %edi,(%eax)
     * HIGHMEM_START - end of memory: available
     *    (the kernel heap is located at HIGHMEM_START; any unused memory
     *    beyond that is added to the freelist)
     */

    Add_Page_Range(0, PAGE_SIZE, PAGE_UNUSED);
   1251a:	b9 08 00 00 00       	mov    $0x8,%ecx
   1251f:	ba 00 10 00 00       	mov    $0x1000,%edx
   12524:	b8 00 00 00 00       	mov    $0x0,%eax
   12529:	e8 a7 fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(PAGE_SIZE, KERNEL_START_ADDR, PAGE_AVAIL);
   1252e:	b9 00 00 00 00       	mov    $0x0,%ecx
   12533:	ba 00 00 01 00       	mov    $0x10000,%edx
   12538:	b8 00 10 00 00       	mov    $0x1000,%eax
   1253d:	e8 93 fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(KERNEL_START_ADDR, kernEnd, PAGE_KERN);
   12542:	b9 01 00 00 00       	mov    $0x1,%ecx
   12547:	89 f2                	mov    %esi,%edx
   12549:	b8 00 00 01 00       	mov    $0x10000,%eax
   1254e:	e8 82 fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(kernEnd, ISA_HOLE_START, PAGE_AVAIL);
   12553:	b9 00 00 00 00       	mov    $0x0,%ecx
   12558:	ba 00 00 0a 00       	mov    $0xa0000,%edx
   1255d:	89 f0                	mov    %esi,%eax
   1255f:	e8 71 fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(ISA_HOLE_START, ISA_HOLE_END, PAGE_HW);
   12564:	b9 02 00 00 00       	mov    $0x2,%ecx
   12569:	ba 00 00 10 00       	mov    $0x100000,%edx
   1256e:	b8 00 00 0a 00       	mov    $0xa0000,%eax
   12573:	e8 5d fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(ISA_HOLE_END, HIGHMEM_START, PAGE_ALLOCATED);
   12578:	b9 04 00 00 00       	mov    $0x4,%ecx
   1257d:	ba 00 20 10 00       	mov    $0x102000,%edx
   12582:	b8 00 00 10 00       	mov    $0x100000,%eax
   12587:	e8 49 fd ff ff       	call   122d5 <Add_Page_Range>
    Add_Page_Range(HIGHMEM_START, HIGHMEM_START + KERNEL_HEAP_SIZE, PAGE_HEAP);
   1258c:	b9 10 00 00 00       	mov    $0x10,%ecx
   12591:	ba 00 20 20 00       	mov    $0x202000,%edx
   12596:	b8 00 20 10 00       	mov    $0x102000,%eax
   1259b:	e8 35 fd ff ff       	call   122d5 <Add_Page_Range>
    ulong_t endOfMem = numPages * PAGE_SIZE;
   125a0:	c1 e7 0c             	shl    $0xc,%edi
   125a3:	89 fa                	mov    %edi,%edx
    Add_Page_Range(HIGHMEM_START + KERNEL_HEAP_SIZE, endOfMem, PAGE_AVAIL);
   125a5:	b9 00 00 00 00       	mov    $0x0,%ecx
   125aa:	b8 00 20 20 00       	mov    $0x202000,%eax
   125af:	e8 21 fd ff ff       	call   122d5 <Add_Page_Range>

    /* Initialize the kernel heap */
    Init_Heap(HIGHMEM_START, KERNEL_HEAP_SIZE);
   125b4:	83 ec 08             	sub    $0x8,%esp
   125b7:	68 00 00 10 00       	push   $0x100000
   125bc:	68 00 20 10 00       	push   $0x102000
   125c1:	e8 c5 15 00 00       	call   13b8b <Init_Heap>

    Print("%uKB memory detected, %u pages in freelist, %d bytes in kernel heap\n",
   125c6:	68 00 00 10 00       	push   $0x100000
   125cb:	ff b3 80 0b 00 00    	pushl  0xb80(%ebx)
   125d1:	ff 75 04             	pushl  0x4(%ebp)
   125d4:	8d 83 18 78 ff ff    	lea    -0x87e8(%ebx),%eax
   125da:	50                   	push   %eax
   125db:	e8 fa e9 ff ff       	call   10fda <Print>
	bootInfo->memSizeKB, g_freePageCount, KERNEL_HEAP_SIZE);
}
   125e0:	83 c4 2c             	add    $0x2c,%esp
   125e3:	5b                   	pop    %ebx
   125e4:	5e                   	pop    %esi
   125e5:	5f                   	pop    %edi
   125e6:	5d                   	pop    %ebp
   125e7:	c3                   	ret    
    KASSERT(bootInfo->memSizeKB > 0);
   125e8:	83 ec 0c             	sub    $0xc,%esp
   125eb:	6a 4f                	push   $0x4f
   125ed:	e8 37 eb ff ff       	call   11129 <Set_Current_Attr>
   125f2:	83 c4 0c             	add    $0xc,%esp
   125f5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   125fb:	ff 30                	pushl  (%eax)
   125fd:	ff 74 24 24          	pushl  0x24(%esp)
   12601:	6a 6c                	push   $0x6c
   12603:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   12609:	50                   	push   %eax
   1260a:	8d 83 ba 77 ff ff    	lea    -0x8846(%ebx),%eax
   12610:	50                   	push   %eax
   12611:	8d 83 10 79 ff ff    	lea    -0x86f0(%ebx),%eax
   12617:	50                   	push   %eax
   12618:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1261e:	50                   	push   %eax
   1261f:	e8 b6 e9 ff ff       	call   10fda <Print>
   12624:	83 c4 20             	add    $0x20,%esp
   12627:	eb fe                	jmp    12627 <Init_Mem+0x18b>

00012629 <Init_BSS>:

/*
 * Initialize the .bss section of the kernel executable image.
 */
void Init_BSS(void)
{
   12629:	53                   	push   %ebx
   1262a:	83 ec 0c             	sub    $0xc,%esp
   1262d:	e8 e0 db ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12632:	81 c3 ce 39 01 00    	add    $0x139ce,%ebx
    extern char BSS_START, BSS_END;

    /* Fill .bss with zeroes */
    memset(&BSS_START, '\0', &BSS_END - &BSS_START);
   12638:	c7 c0 b0 77 02 00    	mov    $0x277b0,%eax
   1263e:	c7 c2 00 61 02 00    	mov    $0x26100,%edx
   12644:	29 d0                	sub    %edx,%eax
   12646:	50                   	push   %eax
   12647:	6a 00                	push   $0x0
   12649:	52                   	push   %edx
   1264a:	e8 0c a4 00 00       	call   1ca5b <memset>
}
   1264f:	83 c4 18             	add    $0x18,%esp
   12652:	5b                   	pop    %ebx
   12653:	c3                   	ret    

00012654 <Alloc_Page>:

/*
 * Allocate a page of physical memory.
 */
void* Alloc_Page(void)
{
   12654:	57                   	push   %edi
   12655:	56                   	push   %esi
   12656:	53                   	push   %ebx
   12657:	e8 b6 db ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1265c:	81 c3 a4 39 01 00    	add    $0x139a4,%ebx
    bool enabled = Interrupts_Enabled();
   12662:	e8 e5 db ff ff       	call   1024c <Interrupts_Enabled>
   12667:	89 c7                	mov    %eax,%edi
    if (enabled)
   12669:	84 c0                	test   %al,%al
   1266b:	75 5b                	jne    126c8 <Alloc_Page+0x74>
IMPLEMENT_LIST(Page_List, Page);
   1266d:	8b b3 84 0b 00 00    	mov    0xb84(%ebx),%esi
    void *result = 0;

    bool iflag = Begin_Int_Atomic();

    /* See if we have a free page */
    if (!Is_Page_List_Empty(&s_freeList)) {
   12673:	85 f6                	test   %esi,%esi
   12675:	0f 84 cf 00 00 00    	je     1274a <Alloc_Page+0xf6>
	/* Remove the first page on the freelist. */
	page = Get_Front_Of_Page_List(&s_freeList);
	KASSERT((page->flags & PAGE_ALLOCATED) == 0);
   1267b:	f6 06 04             	testb  $0x4,(%esi)
   1267e:	0f 84 94 00 00 00    	je     12718 <Alloc_Page+0xc4>
   12684:	83 ec 0c             	sub    $0xc,%esp
   12687:	6a 4f                	push   $0x4f
   12689:	e8 9b ea ff ff       	call   11129 <Set_Current_Attr>
   1268e:	83 c4 0c             	add    $0xc,%esp
   12691:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12697:	ff 30                	pushl  (%eax)
   12699:	ff 74 24 14          	pushl  0x14(%esp)
   1269d:	68 bb 00 00 00       	push   $0xbb
   126a2:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   126a8:	50                   	push   %eax
   126a9:	8d 83 60 78 ff ff    	lea    -0x87a0(%ebx),%eax
   126af:	50                   	push   %eax
   126b0:	8d 83 d8 78 ff ff    	lea    -0x8728(%ebx),%eax
   126b6:	50                   	push   %eax
   126b7:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   126bd:	50                   	push   %eax
   126be:	e8 17 e9 ff ff       	call   10fda <Print>
   126c3:	83 c4 20             	add    $0x20,%esp
   126c6:	eb fe                	jmp    126c6 <Alloc_Page+0x72>
	Disable_Interrupts();
   126c8:	e8 7f db ff ff       	call   1024c <Interrupts_Enabled>
   126cd:	84 c0                	test   %al,%al
   126cf:	74 03                	je     126d4 <Alloc_Page+0x80>
    __asm__ __volatile__ ("cli");
   126d1:	fa                   	cli    
}
   126d2:	eb 99                	jmp    1266d <Alloc_Page+0x19>
	Disable_Interrupts();
   126d4:	83 ec 0c             	sub    $0xc,%esp
   126d7:	6a 4f                	push   $0x4f
   126d9:	e8 4b ea ff ff       	call   11129 <Set_Current_Attr>
   126de:	83 c4 0c             	add    $0xc,%esp
   126e1:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   126e7:	ff 30                	pushl  (%eax)
   126e9:	ff 74 24 14          	pushl  0x14(%esp)
   126ed:	68 8f 00 00 00       	push   $0x8f
   126f2:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   126f8:	50                   	push   %eax
   126f9:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   126ff:	50                   	push   %eax
   12700:	8d 83 c4 78 ff ff    	lea    -0x873c(%ebx),%eax
   12706:	50                   	push   %eax
   12707:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1270d:	50                   	push   %eax
   1270e:	e8 c7 e8 ff ff       	call   10fda <Print>
   12713:	83 c4 20             	add    $0x20,%esp
   12716:	eb fe                	jmp    12716 <Alloc_Page+0xc2>
   12718:	8b 46 08             	mov    0x8(%esi),%eax
   1271b:	89 83 84 0b 00 00    	mov    %eax,0xb84(%ebx)
   12721:	85 c0                	test   %eax,%eax
   12723:	74 3a                	je     1275f <Alloc_Page+0x10b>
   12725:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	Remove_From_Front_Of_Page_List(&s_freeList);

	/* Mark page as having been allocated. */
	page->flags |= PAGE_ALLOCATED;
   1272c:	83 0e 04             	orl    $0x4,(%esi)
	g_freePageCount--;
   1272f:	83 ab 80 0b 00 00 01 	subl   $0x1,0xb80(%ebx)
 * Get the physical address of the memory represented by given Page object.
 */
static __inline__ ulong_t Get_Page_Address(struct Page *page)
{
    extern struct Page* g_pageList;
    ulong_t index = page - g_pageList;
   12736:	c7 c0 84 77 02 00    	mov    $0x27784,%eax
   1273c:	2b 30                	sub    (%eax),%esi
   1273e:	c1 fe 02             	sar    $0x2,%esi
   12741:	69 f6 ab aa aa aa    	imul   $0xaaaaaaab,%esi,%esi
    return index << PAGE_POWER;
   12747:	c1 e6 0c             	shl    $0xc,%esi
    KASSERT(!Interrupts_Enabled());
   1274a:	e8 fd da ff ff       	call   1024c <Interrupts_Enabled>
   1274f:	84 c0                	test   %al,%al
   12751:	75 18                	jne    1276b <Alloc_Page+0x117>
    if (iflag) {
   12753:	89 f8                	mov    %edi,%eax
   12755:	84 c0                	test   %al,%al
   12757:	75 56                	jne    127af <Alloc_Page+0x15b>
    }

    End_Int_Atomic(iflag);

    return result;
}
   12759:	89 f0                	mov    %esi,%eax
   1275b:	5b                   	pop    %ebx
   1275c:	5e                   	pop    %esi
   1275d:	5f                   	pop    %edi
   1275e:	c3                   	ret    
IMPLEMENT_LIST(Page_List, Page);
   1275f:	c7 83 88 0b 00 00 00 	movl   $0x0,0xb88(%ebx)
   12766:	00 00 00 
   12769:	eb c1                	jmp    1272c <Alloc_Page+0xd8>
    KASSERT(!Interrupts_Enabled());
   1276b:	83 ec 0c             	sub    $0xc,%esp
   1276e:	6a 4f                	push   $0x4f
   12770:	e8 b4 e9 ff ff       	call   11129 <Set_Current_Attr>
   12775:	83 c4 0c             	add    $0xc,%esp
   12778:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1277e:	ff 30                	pushl  (%eax)
   12780:	ff 74 24 14          	pushl  0x14(%esp)
   12784:	68 99 00 00 00       	push   $0x99
   12789:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1278f:	50                   	push   %eax
   12790:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12796:	50                   	push   %eax
   12797:	8d 83 b4 78 ff ff    	lea    -0x874c(%ebx),%eax
   1279d:	50                   	push   %eax
   1279e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   127a4:	50                   	push   %eax
   127a5:	e8 30 e8 ff ff       	call   10fda <Print>
   127aa:	83 c4 20             	add    $0x20,%esp
   127ad:	eb fe                	jmp    127ad <Alloc_Page+0x159>
	Enable_Interrupts();
   127af:	e8 98 da ff ff       	call   1024c <Interrupts_Enabled>
   127b4:	84 c0                	test   %al,%al
   127b6:	75 03                	jne    127bb <Alloc_Page+0x167>
    __asm__ __volatile__ ("sti");
   127b8:	fb                   	sti    
    return result;
   127b9:	eb 9e                	jmp    12759 <Alloc_Page+0x105>
	Enable_Interrupts();
   127bb:	83 ec 0c             	sub    $0xc,%esp
   127be:	6a 4f                	push   $0x4f
   127c0:	e8 64 e9 ff ff       	call   11129 <Set_Current_Attr>
   127c5:	83 c4 0c             	add    $0xc,%esp
   127c8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   127ce:	ff 30                	pushl  (%eax)
   127d0:	ff 74 24 14          	pushl  0x14(%esp)
   127d4:	68 9c 00 00 00       	push   $0x9c
   127d9:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   127df:	50                   	push   %eax
   127e0:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   127e6:	50                   	push   %eax
   127e7:	8d 83 b4 78 ff ff    	lea    -0x874c(%ebx),%eax
   127ed:	50                   	push   %eax
   127ee:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   127f4:	50                   	push   %eax
   127f5:	e8 e0 e7 ff ff       	call   10fda <Print>
   127fa:	83 c4 20             	add    $0x20,%esp
   127fd:	eb fe                	jmp    127fd <Alloc_Page+0x1a9>

000127ff <Free_Page>:

/*
 * Free a page of physical memory.
 */
void Free_Page(void* pageAddr)
{
   127ff:	57                   	push   %edi
   12800:	56                   	push   %esi
   12801:	53                   	push   %ebx
   12802:	e8 0b da ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12807:	81 c3 f9 37 01 00    	add    $0x137f9,%ebx
   1280d:	8b 7c 24 10          	mov    0x10(%esp),%edi
    bool enabled = Interrupts_Enabled();
   12811:	e8 36 da ff ff       	call   1024c <Interrupts_Enabled>
   12816:	89 c6                	mov    %eax,%esi
    if (enabled)
   12818:	84 c0                	test   %al,%al
   1281a:	75 6e                	jne    1288a <Free_Page+0x8b>
    struct Page* page;
    bool iflag;

    iflag = Begin_Int_Atomic();

    KASSERT(Is_Page_Multiple(addr));
   1281c:	f7 c7 ff 0f 00 00    	test   $0xfff,%edi
   12822:	0f 85 b2 00 00 00    	jne    128da <Free_Page+0xdb>
    return (int) (addr >> PAGE_POWER);
   12828:	89 f8                	mov    %edi,%eax
   1282a:	c1 e8 0c             	shr    $0xc,%eax
    return &g_pageList[Page_Index(addr)];
   1282d:	8d 14 40             	lea    (%eax,%eax,2),%edx
   12830:	c7 c0 84 77 02 00    	mov    $0x27784,%eax
   12836:	8b 00                	mov    (%eax),%eax
   12838:	8d 04 90             	lea    (%eax,%edx,4),%eax

    /* Get the Page object for this page */
    page = Get_Page(addr);
    KASSERT((page->flags & PAGE_ALLOCATED) != 0);
   1283b:	8b 10                	mov    (%eax),%edx
   1283d:	f6 c2 04             	test   $0x4,%dl
   12840:	0f 85 d8 00 00 00    	jne    1291e <Free_Page+0x11f>
   12846:	83 ec 0c             	sub    $0xc,%esp
   12849:	6a 4f                	push   $0x4f
   1284b:	e8 d9 e8 ff ff       	call   11129 <Set_Current_Attr>
   12850:	83 c4 0c             	add    $0xc,%esp
   12853:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12859:	ff 30                	pushl  (%eax)
   1285b:	ff 74 24 14          	pushl  0x14(%esp)
   1285f:	68 d8 00 00 00       	push   $0xd8
   12864:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   1286a:	50                   	push   %eax
   1286b:	8d 83 84 78 ff ff    	lea    -0x877c(%ebx),%eax
   12871:	50                   	push   %eax
   12872:	8d 83 a8 78 ff ff    	lea    -0x8758(%ebx),%eax
   12878:	50                   	push   %eax
   12879:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1287f:	50                   	push   %eax
   12880:	e8 55 e7 ff ff       	call   10fda <Print>
   12885:	83 c4 20             	add    $0x20,%esp
   12888:	eb fe                	jmp    12888 <Free_Page+0x89>
	Disable_Interrupts();
   1288a:	e8 bd d9 ff ff       	call   1024c <Interrupts_Enabled>
   1288f:	84 c0                	test   %al,%al
   12891:	74 03                	je     12896 <Free_Page+0x97>
    __asm__ __volatile__ ("cli");
   12893:	fa                   	cli    
}
   12894:	eb 86                	jmp    1281c <Free_Page+0x1d>
	Disable_Interrupts();
   12896:	83 ec 0c             	sub    $0xc,%esp
   12899:	6a 4f                	push   $0x4f
   1289b:	e8 89 e8 ff ff       	call   11129 <Set_Current_Attr>
   128a0:	83 c4 0c             	add    $0xc,%esp
   128a3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   128a9:	ff 30                	pushl  (%eax)
   128ab:	ff 74 24 14          	pushl  0x14(%esp)
   128af:	68 8f 00 00 00       	push   $0x8f
   128b4:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   128ba:	50                   	push   %eax
   128bb:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   128c1:	50                   	push   %eax
   128c2:	8d 83 c4 78 ff ff    	lea    -0x873c(%ebx),%eax
   128c8:	50                   	push   %eax
   128c9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   128cf:	50                   	push   %eax
   128d0:	e8 05 e7 ff ff       	call   10fda <Print>
   128d5:	83 c4 20             	add    $0x20,%esp
   128d8:	eb fe                	jmp    128d8 <Free_Page+0xd9>
    KASSERT(Is_Page_Multiple(addr));
   128da:	83 ec 0c             	sub    $0xc,%esp
   128dd:	6a 4f                	push   $0x4f
   128df:	e8 45 e8 ff ff       	call   11129 <Set_Current_Attr>
   128e4:	83 c4 0c             	add    $0xc,%esp
   128e7:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   128ed:	ff 30                	pushl  (%eax)
   128ef:	ff 74 24 14          	pushl  0x14(%esp)
   128f3:	68 d4 00 00 00       	push   $0xd4
   128f8:	8d 83 54 77 ff ff    	lea    -0x88ac(%ebx),%eax
   128fe:	50                   	push   %eax
   128ff:	8d 83 d2 77 ff ff    	lea    -0x882e(%ebx),%eax
   12905:	50                   	push   %eax
   12906:	8d 83 a8 78 ff ff    	lea    -0x8758(%ebx),%eax
   1290c:	50                   	push   %eax
   1290d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12913:	50                   	push   %eax
   12914:	e8 c1 e6 ff ff       	call   10fda <Print>
   12919:	83 c4 20             	add    $0x20,%esp
   1291c:	eb fe                	jmp    1291c <Free_Page+0x11d>

    /* Clear the allocation bit */
    page->flags &= ~(PAGE_ALLOCATED);
   1291e:	83 e2 fb             	and    $0xfffffffb,%edx
   12921:	89 10                	mov    %edx,(%eax)
IMPLEMENT_LIST(Page_List, Page);
   12923:	8b 93 84 0b 00 00    	mov    0xb84(%ebx),%edx
   12929:	85 d2                	test   %edx,%edx
   1292b:	0f 84 03 01 00 00    	je     12a34 <Free_Page+0x235>
   12931:	39 d0                	cmp    %edx,%eax
   12933:	74 0f                	je     12944 <Free_Page+0x145>
   12935:	8b 52 08             	mov    0x8(%edx),%edx
   12938:	85 d2                	test   %edx,%edx
   1293a:	0f 84 f4 00 00 00    	je     12a34 <Free_Page+0x235>
   12940:	39 d0                	cmp    %edx,%eax
   12942:	75 f1                	jne    12935 <Free_Page+0x136>
   12944:	83 ec 0c             	sub    $0xc,%esp
   12947:	6a 4f                	push   $0x4f
   12949:	e8 db e7 ff ff       	call   11129 <Set_Current_Attr>
   1294e:	83 c4 0c             	add    $0xc,%esp
   12951:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12957:	ff 30                	pushl  (%eax)
   12959:	ff 74 24 14          	pushl  0x14(%esp)
   1295d:	6a 3f                	push   $0x3f
   1295f:	8d 83 a2 77 ff ff    	lea    -0x885e(%ebx),%eax
   12965:	50                   	push   %eax
   12966:	8d 83 ec 77 ff ff    	lea    -0x8814(%ebx),%eax
   1296c:	50                   	push   %eax
   1296d:	8d 83 e4 78 ff ff    	lea    -0x871c(%ebx),%eax
   12973:	50                   	push   %eax
   12974:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1297a:	50                   	push   %eax
   1297b:	e8 5a e6 ff ff       	call   10fda <Print>
   12980:	83 c4 20             	add    $0x20,%esp
   12983:	eb fe                	jmp    12983 <Free_Page+0x184>
   12985:	89 83 88 0b 00 00    	mov    %eax,0xb88(%ebx)
   1298b:	89 83 84 0b 00 00    	mov    %eax,0xb84(%ebx)
   12991:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   12998:	e9 b8 00 00 00       	jmp    12a55 <Free_Page+0x256>
    KASSERT(!Interrupts_Enabled());
   1299d:	83 ec 0c             	sub    $0xc,%esp
   129a0:	6a 4f                	push   $0x4f
   129a2:	e8 82 e7 ff ff       	call   11129 <Set_Current_Attr>
   129a7:	83 c4 0c             	add    $0xc,%esp
   129aa:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   129b0:	ff 30                	pushl  (%eax)
   129b2:	ff 74 24 14          	pushl  0x14(%esp)
   129b6:	68 99 00 00 00       	push   $0x99
   129bb:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   129c1:	50                   	push   %eax
   129c2:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   129c8:	50                   	push   %eax
   129c9:	8d 83 b4 78 ff ff    	lea    -0x874c(%ebx),%eax
   129cf:	50                   	push   %eax
   129d0:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   129d6:	50                   	push   %eax
   129d7:	e8 fe e5 ff ff       	call   10fda <Print>
   129dc:	83 c4 20             	add    $0x20,%esp
   129df:	eb fe                	jmp    129df <Free_Page+0x1e0>
	Enable_Interrupts();
   129e1:	e8 66 d8 ff ff       	call   1024c <Interrupts_Enabled>
   129e6:	84 c0                	test   %al,%al
   129e8:	75 06                	jne    129f0 <Free_Page+0x1f1>
    __asm__ __volatile__ ("sti");
   129ea:	fb                   	sti    
    /* Put the page back on the freelist */
    Add_To_Back_Of_Page_List(&s_freeList, page);
    g_freePageCount++;

    End_Int_Atomic(iflag);
}
   129eb:	e9 83 00 00 00       	jmp    12a73 <Free_Page+0x274>
	Enable_Interrupts();
   129f0:	83 ec 0c             	sub    $0xc,%esp
   129f3:	6a 4f                	push   $0x4f
   129f5:	e8 2f e7 ff ff       	call   11129 <Set_Current_Attr>
   129fa:	83 c4 0c             	add    $0xc,%esp
   129fd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12a03:	ff 30                	pushl  (%eax)
   12a05:	ff 74 24 14          	pushl  0x14(%esp)
   12a09:	68 9c 00 00 00       	push   $0x9c
   12a0e:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12a14:	50                   	push   %eax
   12a15:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12a1b:	50                   	push   %eax
   12a1c:	8d 83 b4 78 ff ff    	lea    -0x874c(%ebx),%eax
   12a22:	50                   	push   %eax
   12a23:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12a29:	50                   	push   %eax
   12a2a:	e8 ab e5 ff ff       	call   10fda <Print>
   12a2f:	83 c4 20             	add    $0x20,%esp
   12a32:	eb fe                	jmp    12a32 <Free_Page+0x233>
   12a34:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   12a3b:	8b 93 88 0b 00 00    	mov    0xb88(%ebx),%edx
   12a41:	85 d2                	test   %edx,%edx
   12a43:	0f 84 3c ff ff ff    	je     12985 <Free_Page+0x186>
   12a49:	89 42 08             	mov    %eax,0x8(%edx)
   12a4c:	89 50 04             	mov    %edx,0x4(%eax)
   12a4f:	89 83 88 0b 00 00    	mov    %eax,0xb88(%ebx)
    g_freePageCount++;
   12a55:	83 83 80 0b 00 00 01 	addl   $0x1,0xb80(%ebx)
    KASSERT(!Interrupts_Enabled());
   12a5c:	e8 eb d7 ff ff       	call   1024c <Interrupts_Enabled>
   12a61:	84 c0                	test   %al,%al
   12a63:	0f 85 34 ff ff ff    	jne    1299d <Free_Page+0x19e>
    if (iflag) {
   12a69:	89 f0                	mov    %esi,%eax
   12a6b:	84 c0                	test   %al,%al
   12a6d:	0f 85 6e ff ff ff    	jne    129e1 <Free_Page+0x1e2>
}
   12a73:	5b                   	pop    %ebx
   12a74:	5e                   	pop    %esi
   12a75:	5f                   	pop    %edi
   12a76:	c3                   	ret    

00012a77 <Init_CRC32>:
/*
 * This routine writes each crc_table entry exactly once,
 * with the correct final value.  Thus, it is safe to call
 * even on a table that someone else is using concurrently.
 */
void Init_CRC32(void) {
   12a77:	55                   	push   %ebp
   12a78:	57                   	push   %edi
   12a79:	56                   	push   %esi
   12a7a:	53                   	push   %ebx
   12a7b:	83 ec 08             	sub    $0x8,%esp
   12a7e:	e8 0b 01 00 00       	call   12b8e <__x86.get_pc_thunk.di>
   12a83:	81 c7 7d 35 01 00    	add    $0x1357d,%edi
  unsigned int i, j;
  ulong_t h = 1;
  crc_table[0] = 0;
   12a89:	c7 87 a0 0b 00 00 00 	movl   $0x0,0xba0(%edi)
   12a90:	00 00 00 
   12a93:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  for (i = 128; i; i >>= 1) {
   12a9a:	bd 80 00 00 00       	mov    $0x80,%ebp
    h = (h >> 1) ^ ((h & 1) ? POLYNOMIAL : 0);
   12a9f:	b8 00 00 00 00       	mov    $0x0,%eax
   12aa4:	ba 20 83 b8 ed       	mov    $0xedb88320,%edx
   12aa9:	8d b7 a0 0b 00 00    	lea    0xba0(%edi),%esi
   12aaf:	89 74 24 04          	mov    %esi,0x4(%esp)
   12ab3:	31 c2                	xor    %eax,%edx
    /* h is now crc_table[i] */
    for (j = 0; j < 256; j += 2*i)
   12ab5:	8d 74 2d 00          	lea    0x0(%ebp,%ebp,1),%esi
   12ab9:	8b 44 24 04          	mov    0x4(%esp),%eax
   12abd:	8d 1c a8             	lea    (%eax,%ebp,4),%ebx
   12ac0:	b8 00 00 00 00       	mov    $0x0,%eax
      crc_table[i+j] = crc_table[j] ^ h;
   12ac5:	89 d1                	mov    %edx,%ecx
   12ac7:	33 8c 87 a0 0b 00 00 	xor    0xba0(%edi,%eax,4),%ecx
   12ace:	89 0c 83             	mov    %ecx,(%ebx,%eax,4)
    for (j = 0; j < 256; j += 2*i)
   12ad1:	01 f0                	add    %esi,%eax
   12ad3:	3d ff 00 00 00       	cmp    $0xff,%eax
   12ad8:	76 eb                	jbe    12ac5 <Init_CRC32+0x4e>
  for (i = 128; i; i >>= 1) {
   12ada:	d1 ed                	shr    %ebp
   12adc:	83 2c 24 01          	subl   $0x1,(%esp)
   12ae0:	74 11                	je     12af3 <Init_CRC32+0x7c>
    h = (h >> 1) ^ ((h & 1) ? POLYNOMIAL : 0);
   12ae2:	89 d0                	mov    %edx,%eax
   12ae4:	d1 e8                	shr    %eax
   12ae6:	83 e2 01             	and    $0x1,%edx
   12ae9:	bb 20 83 b8 ed       	mov    $0xedb88320,%ebx
   12aee:	0f 45 d3             	cmovne %ebx,%edx
   12af1:	eb c0                	jmp    12ab3 <Init_CRC32+0x3c>
  }
}
   12af3:	83 c4 08             	add    $0x8,%esp
   12af6:	5b                   	pop    %ebx
   12af7:	5e                   	pop    %esi
   12af8:	5f                   	pop    %edi
   12af9:	5d                   	pop    %ebp
   12afa:	c3                   	ret    

00012afb <crc32>:
 * Note that this is a little-endian CRC, which is best used with
 * data transmitted lsbit-first, and it should, itself, be appended
 * to data in little-endian byte and bit order to preserve the
 * property of detecting all burst errors of length 32 bits or less.
 */
ulong_t crc32(ulong_t crc, char const *buf, size_t len) {
   12afb:	56                   	push   %esi
   12afc:	53                   	push   %ebx
   12afd:	83 ec 04             	sub    $0x4,%esp
   12b00:	e8 0d d7 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12b05:	81 c3 fb 34 01 00    	add    $0x134fb,%ebx
   12b0b:	8b 54 24 14          	mov    0x14(%esp),%edx
   12b0f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  KASSERT(crc_table[255] != 0);
   12b13:	83 bb 9c 0f 00 00 00 	cmpl   $0x0,0xf9c(%ebx)
   12b1a:	74 31                	je     12b4d <crc32+0x52>
  crc ^= 0xffffffff;
   12b1c:	8b 44 24 10          	mov    0x10(%esp),%eax
   12b20:	f7 d0                	not    %eax
  while (len--)
   12b22:	85 c9                	test   %ecx,%ecx
   12b24:	74 1f                	je     12b45 <crc32+0x4a>
   12b26:	01 d1                	add    %edx,%ecx
    crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   12b28:	8d 9b a0 0b 00 00    	lea    0xba0(%ebx),%ebx
   12b2e:	89 c6                	mov    %eax,%esi
   12b30:	c1 ee 08             	shr    $0x8,%esi
   12b33:	83 c2 01             	add    $0x1,%edx
   12b36:	32 42 ff             	xor    -0x1(%edx),%al
   12b39:	0f b6 c0             	movzbl %al,%eax
   12b3c:	33 34 83             	xor    (%ebx,%eax,4),%esi
   12b3f:	89 f0                	mov    %esi,%eax
  while (len--)
   12b41:	39 d1                	cmp    %edx,%ecx
   12b43:	75 e9                	jne    12b2e <crc32+0x33>
  return crc ^ 0xffffffff;
   12b45:	f7 d0                	not    %eax
}
   12b47:	83 c4 04             	add    $0x4,%esp
   12b4a:	5b                   	pop    %ebx
   12b4b:	5e                   	pop    %esi
   12b4c:	c3                   	ret    
  KASSERT(crc_table[255] != 0);
   12b4d:	83 ec 0c             	sub    $0xc,%esp
   12b50:	6a 4f                	push   $0x4f
   12b52:	e8 d2 e5 ff ff       	call   11129 <Set_Current_Attr>
   12b57:	83 c4 0c             	add    $0xc,%esp
   12b5a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12b60:	ff 30                	pushl  (%eax)
   12b62:	ff 74 24 14          	pushl  0x14(%esp)
   12b66:	6a 2b                	push   $0x2b
   12b68:	8d 83 19 79 ff ff    	lea    -0x86e7(%ebx),%eax
   12b6e:	50                   	push   %eax
   12b6f:	8d 83 2f 79 ff ff    	lea    -0x86d1(%ebx),%eax
   12b75:	50                   	push   %eax
   12b76:	8d 83 44 79 ff ff    	lea    -0x86bc(%ebx),%eax
   12b7c:	50                   	push   %eax
   12b7d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12b83:	50                   	push   %eax
   12b84:	e8 51 e4 ff ff       	call   10fda <Print>
   12b89:	83 c4 20             	add    $0x20,%esp
   12b8c:	eb fe                	jmp    12b8c <crc32+0x91>

00012b8e <__x86.get_pc_thunk.di>:
   12b8e:	8b 3c 24             	mov    (%esp),%edi
   12b91:	c3                   	ret    

00012b92 <Allocate_Segment_Descriptor>:
/*
 * Allocate an descriptor from the GDT.
 * Returns null if there are none left.
 */
struct Segment_Descriptor* Allocate_Segment_Descriptor(void)
{
   12b92:	57                   	push   %edi
   12b93:	56                   	push   %esi
   12b94:	53                   	push   %ebx
   12b95:	e8 78 d6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12b9a:	81 c3 66 34 01 00    	add    $0x13466,%ebx
    bool enabled = Interrupts_Enabled();
   12ba0:	e8 a7 d6 ff ff       	call   1024c <Interrupts_Enabled>
   12ba5:	89 c6                	mov    %eax,%esi
    if (enabled)
   12ba7:	84 c0                	test   %al,%al
   12ba9:	75 35                	jne    12be0 <Allocate_Segment_Descriptor+0x4e>
    bool iflag;

    iflag = Begin_Int_Atomic();

    /* Note; entry 0 is unused (thus never allocated) */
    for (i = 1; i < NUM_GDT_ENTRIES; ++i) {
   12bab:	b8 01 00 00 00       	mov    $0x1,%eax
	struct Segment_Descriptor *desc = &s_GDT[ i ];
	if (desc->avail) {
   12bb0:	f6 84 c3 c6 0f 00 00 	testb  $0x10,0xfc6(%ebx,%eax,8)
   12bb7:	10 
   12bb8:	75 76                	jne    12c30 <Allocate_Segment_Descriptor+0x9e>
    for (i = 1; i < NUM_GDT_ENTRIES; ++i) {
   12bba:	83 c0 01             	add    $0x1,%eax
   12bbd:	83 f8 10             	cmp    $0x10,%eax
   12bc0:	75 ee                	jne    12bb0 <Allocate_Segment_Descriptor+0x1e>
    struct Segment_Descriptor* result = 0;
   12bc2:	bf 00 00 00 00       	mov    $0x0,%edi
    KASSERT(!Interrupts_Enabled());
   12bc7:	e8 80 d6 ff ff       	call   1024c <Interrupts_Enabled>
   12bcc:	84 c0                	test   %al,%al
   12bce:	75 7b                	jne    12c4b <Allocate_Segment_Descriptor+0xb9>
    if (iflag) {
   12bd0:	89 f0                	mov    %esi,%eax
   12bd2:	84 c0                	test   %al,%al
   12bd4:	0f 85 b5 00 00 00    	jne    12c8f <Allocate_Segment_Descriptor+0xfd>
    }

    End_Int_Atomic(iflag);

    return result;
}
   12bda:	89 f8                	mov    %edi,%eax
   12bdc:	5b                   	pop    %ebx
   12bdd:	5e                   	pop    %esi
   12bde:	5f                   	pop    %edi
   12bdf:	c3                   	ret    
	Disable_Interrupts();
   12be0:	e8 67 d6 ff ff       	call   1024c <Interrupts_Enabled>
   12be5:	84 c0                	test   %al,%al
   12be7:	74 03                	je     12bec <Allocate_Segment_Descriptor+0x5a>
    __asm__ __volatile__ ("cli");
   12be9:	fa                   	cli    
}
   12bea:	eb bf                	jmp    12bab <Allocate_Segment_Descriptor+0x19>
	Disable_Interrupts();
   12bec:	83 ec 0c             	sub    $0xc,%esp
   12bef:	6a 4f                	push   $0x4f
   12bf1:	e8 33 e5 ff ff       	call   11129 <Set_Current_Attr>
   12bf6:	83 c4 0c             	add    $0xc,%esp
   12bf9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12bff:	ff 30                	pushl  (%eax)
   12c01:	ff 74 24 14          	pushl  0x14(%esp)
   12c05:	68 8f 00 00 00       	push   $0x8f
   12c0a:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12c10:	50                   	push   %eax
   12c11:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   12c17:	50                   	push   %eax
   12c18:	8d 83 00 7a ff ff    	lea    -0x8600(%ebx),%eax
   12c1e:	50                   	push   %eax
   12c1f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12c25:	50                   	push   %eax
   12c26:	e8 af e3 ff ff       	call   10fda <Print>
   12c2b:	83 c4 20             	add    $0x20,%esp
   12c2e:	eb fe                	jmp    12c2e <Allocate_Segment_Descriptor+0x9c>
	struct Segment_Descriptor *desc = &s_GDT[ i ];
   12c30:	8d bc c3 c0 0f 00 00 	lea    0xfc0(%ebx,%eax,8),%edi
	    ++s_numAllocated;
   12c37:	83 83 a0 0f 00 00 01 	addl   $0x1,0xfa0(%ebx)
	    desc->avail = 0;
   12c3e:	80 a4 c3 c6 0f 00 00 	andb   $0xef,0xfc6(%ebx,%eax,8)
   12c45:	ef 
	    break;
   12c46:	e9 7c ff ff ff       	jmp    12bc7 <Allocate_Segment_Descriptor+0x35>
    KASSERT(!Interrupts_Enabled());
   12c4b:	83 ec 0c             	sub    $0xc,%esp
   12c4e:	6a 4f                	push   $0x4f
   12c50:	e8 d4 e4 ff ff       	call   11129 <Set_Current_Attr>
   12c55:	83 c4 0c             	add    $0xc,%esp
   12c58:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12c5e:	ff 30                	pushl  (%eax)
   12c60:	ff 74 24 14          	pushl  0x14(%esp)
   12c64:	68 99 00 00 00       	push   $0x99
   12c69:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12c6f:	50                   	push   %eax
   12c70:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12c76:	50                   	push   %eax
   12c77:	8d 83 f0 79 ff ff    	lea    -0x8610(%ebx),%eax
   12c7d:	50                   	push   %eax
   12c7e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12c84:	50                   	push   %eax
   12c85:	e8 50 e3 ff ff       	call   10fda <Print>
   12c8a:	83 c4 20             	add    $0x20,%esp
   12c8d:	eb fe                	jmp    12c8d <Allocate_Segment_Descriptor+0xfb>
	Enable_Interrupts();
   12c8f:	e8 b8 d5 ff ff       	call   1024c <Interrupts_Enabled>
   12c94:	84 c0                	test   %al,%al
   12c96:	75 06                	jne    12c9e <Allocate_Segment_Descriptor+0x10c>
    __asm__ __volatile__ ("sti");
   12c98:	fb                   	sti    
    return result;
   12c99:	e9 3c ff ff ff       	jmp    12bda <Allocate_Segment_Descriptor+0x48>
	Enable_Interrupts();
   12c9e:	83 ec 0c             	sub    $0xc,%esp
   12ca1:	6a 4f                	push   $0x4f
   12ca3:	e8 81 e4 ff ff       	call   11129 <Set_Current_Attr>
   12ca8:	83 c4 0c             	add    $0xc,%esp
   12cab:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12cb1:	ff 30                	pushl  (%eax)
   12cb3:	ff 74 24 14          	pushl  0x14(%esp)
   12cb7:	68 9c 00 00 00       	push   $0x9c
   12cbc:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12cc2:	50                   	push   %eax
   12cc3:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12cc9:	50                   	push   %eax
   12cca:	8d 83 f0 79 ff ff    	lea    -0x8610(%ebx),%eax
   12cd0:	50                   	push   %eax
   12cd1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12cd7:	50                   	push   %eax
   12cd8:	e8 fd e2 ff ff       	call   10fda <Print>
   12cdd:	83 c4 20             	add    $0x20,%esp
   12ce0:	eb fe                	jmp    12ce0 <Allocate_Segment_Descriptor+0x14e>

00012ce2 <Free_Segment_Descriptor>:

/*
 * Free a segment descriptor.
 */
void Free_Segment_Descriptor(struct Segment_Descriptor* desc)
{
   12ce2:	57                   	push   %edi
   12ce3:	56                   	push   %esi
   12ce4:	53                   	push   %ebx
   12ce5:	e8 28 d5 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12cea:	81 c3 16 33 01 00    	add    $0x13316,%ebx
   12cf0:	8b 74 24 10          	mov    0x10(%esp),%esi
    bool enabled = Interrupts_Enabled();
   12cf4:	e8 53 d5 ff ff       	call   1024c <Interrupts_Enabled>
   12cf9:	89 c7                	mov    %eax,%edi
    if (enabled)
   12cfb:	84 c0                	test   %al,%al
   12cfd:	75 4b                	jne    12d4a <Free_Segment_Descriptor+0x68>
    bool iflag = Begin_Int_Atomic();

    KASSERT(!desc->avail);
   12cff:	f6 46 06 10          	testb  $0x10,0x6(%esi)
   12d03:	0f 84 91 00 00 00    	je     12d9a <Free_Segment_Descriptor+0xb8>
   12d09:	83 ec 0c             	sub    $0xc,%esp
   12d0c:	6a 4f                	push   $0x4f
   12d0e:	e8 16 e4 ff ff       	call   11129 <Set_Current_Attr>
   12d13:	83 c4 0c             	add    $0xc,%esp
   12d16:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12d1c:	ff 30                	pushl  (%eax)
   12d1e:	ff 74 24 14          	pushl  0x14(%esp)
   12d22:	6a 4f                	push   $0x4f
   12d24:	8d 83 4a 79 ff ff    	lea    -0x86b6(%ebx),%eax
   12d2a:	50                   	push   %eax
   12d2b:	8d 83 5e 79 ff ff    	lea    -0x86a2(%ebx),%eax
   12d31:	50                   	push   %eax
   12d32:	8d 83 d8 79 ff ff    	lea    -0x8628(%ebx),%eax
   12d38:	50                   	push   %eax
   12d39:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12d3f:	50                   	push   %eax
   12d40:	e8 95 e2 ff ff       	call   10fda <Print>
   12d45:	83 c4 20             	add    $0x20,%esp
   12d48:	eb fe                	jmp    12d48 <Free_Segment_Descriptor+0x66>
	Disable_Interrupts();
   12d4a:	e8 fd d4 ff ff       	call   1024c <Interrupts_Enabled>
   12d4f:	84 c0                	test   %al,%al
   12d51:	74 03                	je     12d56 <Free_Segment_Descriptor+0x74>
    __asm__ __volatile__ ("cli");
   12d53:	fa                   	cli    
}
   12d54:	eb a9                	jmp    12cff <Free_Segment_Descriptor+0x1d>
	Disable_Interrupts();
   12d56:	83 ec 0c             	sub    $0xc,%esp
   12d59:	6a 4f                	push   $0x4f
   12d5b:	e8 c9 e3 ff ff       	call   11129 <Set_Current_Attr>
   12d60:	83 c4 0c             	add    $0xc,%esp
   12d63:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12d69:	ff 30                	pushl  (%eax)
   12d6b:	ff 74 24 14          	pushl  0x14(%esp)
   12d6f:	68 8f 00 00 00       	push   $0x8f
   12d74:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12d7a:	50                   	push   %eax
   12d7b:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   12d81:	50                   	push   %eax
   12d82:	8d 83 00 7a ff ff    	lea    -0x8600(%ebx),%eax
   12d88:	50                   	push   %eax
   12d89:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12d8f:	50                   	push   %eax
   12d90:	e8 45 e2 ff ff       	call   10fda <Print>
   12d95:	83 c4 20             	add    $0x20,%esp
   12d98:	eb fe                	jmp    12d98 <Free_Segment_Descriptor+0xb6>

    Init_Null_Segment_Descriptor(desc);
   12d9a:	83 ec 0c             	sub    $0xc,%esp
   12d9d:	56                   	push   %esi
   12d9e:	e8 f4 02 00 00       	call   13097 <Init_Null_Segment_Descriptor>
    desc->avail = 1;
   12da3:	80 4e 06 10          	orb    $0x10,0x6(%esi)
    --s_numAllocated;
   12da7:	83 ab a0 0f 00 00 01 	subl   $0x1,0xfa0(%ebx)
    KASSERT(!Interrupts_Enabled());
   12dae:	e8 99 d4 ff ff       	call   1024c <Interrupts_Enabled>
   12db3:	83 c4 10             	add    $0x10,%esp
   12db6:	84 c0                	test   %al,%al
   12db8:	75 0a                	jne    12dc4 <Free_Segment_Descriptor+0xe2>
    if (iflag) {
   12dba:	89 f8                	mov    %edi,%eax
   12dbc:	84 c0                	test   %al,%al
   12dbe:	75 48                	jne    12e08 <Free_Segment_Descriptor+0x126>

    End_Int_Atomic(iflag);
}
   12dc0:	5b                   	pop    %ebx
   12dc1:	5e                   	pop    %esi
   12dc2:	5f                   	pop    %edi
   12dc3:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   12dc4:	83 ec 0c             	sub    $0xc,%esp
   12dc7:	6a 4f                	push   $0x4f
   12dc9:	e8 5b e3 ff ff       	call   11129 <Set_Current_Attr>
   12dce:	83 c4 0c             	add    $0xc,%esp
   12dd1:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12dd7:	ff 30                	pushl  (%eax)
   12dd9:	ff 74 24 14          	pushl  0x14(%esp)
   12ddd:	68 99 00 00 00       	push   $0x99
   12de2:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12de8:	50                   	push   %eax
   12de9:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12def:	50                   	push   %eax
   12df0:	8d 83 f0 79 ff ff    	lea    -0x8610(%ebx),%eax
   12df6:	50                   	push   %eax
   12df7:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12dfd:	50                   	push   %eax
   12dfe:	e8 d7 e1 ff ff       	call   10fda <Print>
   12e03:	83 c4 20             	add    $0x20,%esp
   12e06:	eb fe                	jmp    12e06 <Free_Segment_Descriptor+0x124>
	Enable_Interrupts();
   12e08:	e8 3f d4 ff ff       	call   1024c <Interrupts_Enabled>
   12e0d:	84 c0                	test   %al,%al
   12e0f:	75 03                	jne    12e14 <Free_Segment_Descriptor+0x132>
    __asm__ __volatile__ ("sti");
   12e11:	fb                   	sti    
   12e12:	eb ac                	jmp    12dc0 <Free_Segment_Descriptor+0xde>
	Enable_Interrupts();
   12e14:	83 ec 0c             	sub    $0xc,%esp
   12e17:	6a 4f                	push   $0x4f
   12e19:	e8 0b e3 ff ff       	call   11129 <Set_Current_Attr>
   12e1e:	83 c4 0c             	add    $0xc,%esp
   12e21:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12e27:	ff 30                	pushl  (%eax)
   12e29:	ff 74 24 14          	pushl  0x14(%esp)
   12e2d:	68 9c 00 00 00       	push   $0x9c
   12e32:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   12e38:	50                   	push   %eax
   12e39:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   12e3f:	50                   	push   %eax
   12e40:	8d 83 f0 79 ff ff    	lea    -0x8610(%ebx),%eax
   12e46:	50                   	push   %eax
   12e47:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12e4d:	50                   	push   %eax
   12e4e:	e8 87 e1 ff ff       	call   10fda <Print>
   12e53:	83 c4 20             	add    $0x20,%esp
   12e56:	eb fe                	jmp    12e56 <Free_Segment_Descriptor+0x174>

00012e58 <Get_Descriptor_Index>:

/*
 * Get the index (int the GDT) of given segment descriptor.
 */
int Get_Descriptor_Index(struct Segment_Descriptor* desc)
{
   12e58:	e8 69 da ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   12e5d:	05 a3 31 01 00       	add    $0x131a3,%eax
    return (int) (desc - s_GDT);
   12e62:	8d 80 c0 0f 00 00    	lea    0xfc0(%eax),%eax
   12e68:	8b 54 24 04          	mov    0x4(%esp),%edx
   12e6c:	29 c2                	sub    %eax,%edx
   12e6e:	89 d0                	mov    %edx,%eax
   12e70:	c1 f8 03             	sar    $0x3,%eax
}
   12e73:	c3                   	ret    

00012e74 <Init_GDT>:

/*
 * Initialize the kernel's GDT.
 */
void Init_GDT(void)
{
   12e74:	57                   	push   %edi
   12e75:	56                   	push   %esi
   12e76:	53                   	push   %ebx
   12e77:	83 ec 10             	sub    $0x10,%esp
   12e7a:	e8 93 d3 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12e7f:	81 c3 81 31 01 00    	add    $0x13181,%ebx
    int i;

    KASSERT(sizeof(struct Segment_Descriptor) == 8);

    /* Clear out entries. */
    for (i = 0; i < NUM_GDT_ENTRIES; ++i) {
   12e85:	be 00 00 00 00       	mov    $0x0,%esi
   12e8a:	8d bb c0 0f 00 00    	lea    0xfc0(%ebx),%edi
	desc = &s_GDT[ i ];
	Init_Null_Segment_Descriptor(desc);
   12e90:	83 ec 0c             	sub    $0xc,%esp
   12e93:	8d 04 f7             	lea    (%edi,%esi,8),%eax
   12e96:	50                   	push   %eax
   12e97:	e8 fb 01 00 00       	call   13097 <Init_Null_Segment_Descriptor>
	desc->avail = 1;
   12e9c:	80 8c f3 c6 0f 00 00 	orb    $0x10,0xfc6(%ebx,%esi,8)
   12ea3:	10 
    for (i = 0; i < NUM_GDT_ENTRIES; ++i) {
   12ea4:	83 c6 01             	add    $0x1,%esi
   12ea7:	83 c4 10             	add    $0x10,%esp
   12eaa:	83 fe 10             	cmp    $0x10,%esi
   12ead:	75 e1                	jne    12e90 <Init_GDT+0x1c>
    }

    /* Kernel code segment. */
    desc = Allocate_Segment_Descriptor();
   12eaf:	e8 de fc ff ff       	call   12b92 <Allocate_Segment_Descriptor>
   12eb4:	89 c6                	mov    %eax,%esi
    Init_Code_Segment_Descriptor(
   12eb6:	6a 00                	push   $0x0
   12eb8:	68 00 00 10 00       	push   $0x100000
   12ebd:	6a 00                	push   $0x0
   12ebf:	50                   	push   %eax
   12ec0:	e8 e4 01 00 00       	call   130a9 <Init_Code_Segment_Descriptor>
    return (int) (desc - s_GDT);
   12ec5:	8d 83 c0 0f 00 00    	lea    0xfc0(%ebx),%eax
   12ecb:	29 c6                	sub    %eax,%esi
	desc,
	0,		 /* base address */
	0x100000,	 /* num pages (== 2^20) */
	0		 /* privilege level (0 == kernel) */
    );
    KASSERT(Get_Descriptor_Index(desc) == (KERNEL_CS >> 3));
   12ecd:	83 c4 10             	add    $0x10,%esp
   12ed0:	83 fe 08             	cmp    $0x8,%esi
   12ed3:	74 41                	je     12f16 <Init_GDT+0xa2>
   12ed5:	83 ec 0c             	sub    $0xc,%esp
   12ed8:	6a 4f                	push   $0x4f
   12eda:	e8 4a e2 ff ff       	call   11129 <Set_Current_Attr>
   12edf:	83 c4 0c             	add    $0xc,%esp
   12ee2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12ee8:	ff 30                	pushl  (%eax)
   12eea:	ff 74 24 24          	pushl  0x24(%esp)
   12eee:	6a 7b                	push   $0x7b
   12ef0:	8d 83 4a 79 ff ff    	lea    -0x86b6(%ebx),%eax
   12ef6:	50                   	push   %eax
   12ef7:	8d 83 6c 79 ff ff    	lea    -0x8694(%ebx),%eax
   12efd:	50                   	push   %eax
   12efe:	8d 83 cc 79 ff ff    	lea    -0x8634(%ebx),%eax
   12f04:	50                   	push   %eax
   12f05:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12f0b:	50                   	push   %eax
   12f0c:	e8 c9 e0 ff ff       	call   10fda <Print>
   12f11:	83 c4 20             	add    $0x20,%esp
   12f14:	eb fe                	jmp    12f14 <Init_GDT+0xa0>

    /* Kernel data segment. */
    desc = Allocate_Segment_Descriptor();
   12f16:	e8 77 fc ff ff       	call   12b92 <Allocate_Segment_Descriptor>
   12f1b:	89 c6                	mov    %eax,%esi
    Init_Data_Segment_Descriptor(
   12f1d:	6a 00                	push   $0x0
   12f1f:	68 00 00 10 00       	push   $0x100000
   12f24:	6a 00                	push   $0x0
   12f26:	50                   	push   %eax
   12f27:	e8 7b 02 00 00       	call   131a7 <Init_Data_Segment_Descriptor>
    return (int) (desc - s_GDT);
   12f2c:	8d 83 c0 0f 00 00    	lea    0xfc0(%ebx),%eax
   12f32:	29 c6                	sub    %eax,%esi
	desc,
	0,		 /* base address */
	0x100000,	 /* num pages (== 2^20) */
	0		 /* privilege level (0 == kernel) */
    );
    KASSERT(Get_Descriptor_Index(desc) == (KERNEL_DS >> 3));
   12f34:	83 c4 10             	add    $0x10,%esp
   12f37:	83 fe 10             	cmp    $0x10,%esi
   12f3a:	74 44                	je     12f80 <Init_GDT+0x10c>
   12f3c:	83 ec 0c             	sub    $0xc,%esp
   12f3f:	6a 4f                	push   $0x4f
   12f41:	e8 e3 e1 ff ff       	call   11129 <Set_Current_Attr>
   12f46:	83 c4 0c             	add    $0xc,%esp
   12f49:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   12f4f:	ff 30                	pushl  (%eax)
   12f51:	ff 74 24 24          	pushl  0x24(%esp)
   12f55:	68 85 00 00 00       	push   $0x85
   12f5a:	8d 83 4a 79 ff ff    	lea    -0x86b6(%ebx),%eax
   12f60:	50                   	push   %eax
   12f61:	8d 83 9c 79 ff ff    	lea    -0x8664(%ebx),%eax
   12f67:	50                   	push   %eax
   12f68:	8d 83 cc 79 ff ff    	lea    -0x8634(%ebx),%eax
   12f6e:	50                   	push   %eax
   12f6f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   12f75:	50                   	push   %eax
   12f76:	e8 5f e0 ff ff       	call   10fda <Print>
   12f7b:	83 c4 20             	add    $0x20,%esp
   12f7e:	eb fe                	jmp    12f7e <Init_GDT+0x10a>

    /* Activate the kernel GDT. */
    limitAndBase[0] = sizeof(struct Segment_Descriptor) * NUM_GDT_ENTRIES;
   12f80:	66 c7 44 24 0a 80 00 	movw   $0x80,0xa(%esp)
    limitAndBase[1] = gdtBaseAddr & 0xffff;
   12f87:	66 89 7c 24 0c       	mov    %di,0xc(%esp)
    limitAndBase[2] = gdtBaseAddr >> 16;
   12f8c:	c1 ef 10             	shr    $0x10,%edi
   12f8f:	66 89 7c 24 0e       	mov    %di,0xe(%esp)
    Load_GDTR(limitAndBase);
   12f94:	83 ec 0c             	sub    $0xc,%esp
   12f97:	8d 44 24 16          	lea    0x16(%esp),%eax
   12f9b:	50                   	push   %eax
   12f9c:	e8 27 7e 00 00       	call   1adc8 <Load_GDTR>
}
   12fa1:	83 c4 20             	add    $0x20,%esp
   12fa4:	5b                   	pop    %ebx
   12fa5:	5e                   	pop    %esi
   12fa6:	5f                   	pop    %edi
   12fa7:	c3                   	ret    

00012fa8 <Init_TSS>:
/*
 * Initialize the kernel TSS.  This must be done after the memory and
 * GDT initialization, but before the scheduler is started.
 */
void Init_TSS(void)
{
   12fa8:	57                   	push   %edi
   12fa9:	56                   	push   %esi
   12faa:	53                   	push   %ebx
   12fab:	e8 62 d2 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   12fb0:	81 c3 50 30 01 00    	add    $0x13050,%ebx
    s_tssDesc = Allocate_Segment_Descriptor();
   12fb6:	e8 d7 fb ff ff       	call   12b92 <Allocate_Segment_Descriptor>
   12fbb:	89 83 44 10 00 00    	mov    %eax,0x1044(%ebx)
    KASSERT(s_tssDesc != 0);
   12fc1:	85 c0                	test   %eax,%eax
   12fc3:	74 55                	je     1301a <Init_TSS+0x72>
   12fc5:	89 c2                	mov    %eax,%edx

    memset(&s_theTSS, '\0', sizeof(struct TSS));
   12fc7:	8d b3 60 10 00 00    	lea    0x1060(%ebx),%esi
   12fcd:	b9 1a 00 00 00       	mov    $0x1a,%ecx
   12fd2:	b8 00 00 00 00       	mov    $0x0,%eax
   12fd7:	89 f7                	mov    %esi,%edi
   12fd9:	f3 ab                	rep stos %eax,%es:(%edi)
    Init_TSS_Descriptor(s_tssDesc, &s_theTSS);
   12fdb:	83 ec 08             	sub    $0x8,%esp
   12fde:	56                   	push   %esi
   12fdf:	52                   	push   %edx
   12fe0:	e8 c0 02 00 00       	call   132a5 <Init_TSS_Descriptor>

    s_tssSelector = Selector(0, true, Get_Descriptor_Index(s_tssDesc));
   12fe5:	83 c4 04             	add    $0x4,%esp
   12fe8:	ff b3 44 10 00 00    	pushl  0x1044(%ebx)
   12fee:	e8 65 fe ff ff       	call   12e58 <Get_Descriptor_Index>
 * @return the segment selector
 */
static __inline__ ushort_t Selector(int rpl, bool segmentIsInGDT, int index)
{
    ushort_t selector = 0;
    selector = (rpl & 0x3) | ((segmentIsInGDT ? 0 : 1) << 2) | ((index & 0x1FFF) << 3);
   12ff3:	c1 e0 03             	shl    $0x3,%eax
   12ff6:	66 89 83 40 10 00 00 	mov    %ax,0x1040(%ebx)
    s_tssDesc->type = 0x09;
   12ffd:	8b 8b 44 10 00 00    	mov    0x1044(%ebx),%ecx
   13003:	0f b6 51 05          	movzbl 0x5(%ecx),%edx
   13007:	83 e2 f0             	and    $0xfffffff0,%edx
   1300a:	83 ca 09             	or     $0x9,%edx
   1300d:	88 51 05             	mov    %dl,0x5(%ecx)
    __asm__ __volatile__ (
   13010:	0f 00 d8             	ltr    %ax

    Load_Task_Register();
}
   13013:	83 c4 10             	add    $0x10,%esp
   13016:	5b                   	pop    %ebx
   13017:	5e                   	pop    %esi
   13018:	5f                   	pop    %edi
   13019:	c3                   	ret    
    KASSERT(s_tssDesc != 0);
   1301a:	83 ec 0c             	sub    $0xc,%esp
   1301d:	6a 4f                	push   $0x4f
   1301f:	e8 05 e1 ff ff       	call   11129 <Set_Current_Attr>
   13024:	83 c4 0c             	add    $0xc,%esp
   13027:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1302d:	ff 30                	pushl  (%eax)
   1302f:	ff 74 24 14          	pushl  0x14(%esp)
   13033:	6a 31                	push   $0x31
   13035:	8d 83 11 7a ff ff    	lea    -0x85ef(%ebx),%eax
   1303b:	50                   	push   %eax
   1303c:	8d 83 25 7a ff ff    	lea    -0x85db(%ebx),%eax
   13042:	50                   	push   %eax
   13043:	8d 83 34 7a ff ff    	lea    -0x85cc(%ebx),%eax
   13049:	50                   	push   %eax
   1304a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13050:	50                   	push   %eax
   13051:	e8 84 df ff ff       	call   10fda <Print>
   13056:	83 c4 20             	add    $0x20,%esp
   13059:	eb fe                	jmp    13059 <Init_TSS+0xb1>

0001305b <Set_Kernel_Stack_Pointer>:
 * This should be called before switching to a new
 * user process, so that interrupts occurring while executing
 * in user mode will be delivered on the correct stack.
 */
void Set_Kernel_Stack_Pointer(ulong_t esp0)
{
   1305b:	e8 83 ef ff ff       	call   11fe3 <__x86.get_pc_thunk.dx>
   13060:	81 c2 a0 2f 01 00    	add    $0x12fa0,%edx
    s_theTSS.ss0 = KERNEL_DS;
   13066:	66 c7 82 68 10 00 00 	movw   $0x10,0x1068(%edx)
   1306d:	10 00 
    s_theTSS.esp0 = esp0;
   1306f:	8b 44 24 04          	mov    0x4(%esp),%eax
   13073:	89 82 64 10 00 00    	mov    %eax,0x1064(%edx)
    s_tssDesc->type = 0x09;
   13079:	8b 8a 44 10 00 00    	mov    0x1044(%edx),%ecx
   1307f:	0f b6 41 05          	movzbl 0x5(%ecx),%eax
   13083:	83 e0 f0             	and    $0xfffffff0,%eax
   13086:	83 c8 09             	or     $0x9,%eax
   13089:	88 41 05             	mov    %al,0x5(%ecx)
    __asm__ __volatile__ (
   1308c:	0f b7 82 40 10 00 00 	movzwl 0x1040(%edx),%eax
   13093:	0f 00 d8             	ltr    %ax
     * reload the task register after modifying a TSS.
     * I haven't verified this in the IA32 documentation,
     * but there is certainly no harm in being paranoid.
     */
    Load_Task_Register();
}
   13096:	c3                   	ret    

00013097 <Init_Null_Segment_Descriptor>:

/*
 * Initialize an unused segment descriptor.
 */
void Init_Null_Segment_Descriptor(struct Segment_Descriptor* desc)
{
   13097:	8b 44 24 04          	mov    0x4(%esp),%eax
    memset(desc, '\0', sizeof(*desc));
   1309b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   130a1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
   130a8:	c3                   	ret    

000130a9 <Init_Code_Segment_Descriptor>:
    struct Segment_Descriptor* desc,
    ulong_t baseAddr,
    ulong_t numPages,
    int privilegeLevel
)
{
   130a9:	55                   	push   %ebp
   130aa:	57                   	push   %edi
   130ab:	56                   	push   %esi
   130ac:	53                   	push   %ebx
   130ad:	83 ec 0c             	sub    $0xc,%esp
   130b0:	e8 5d d1 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   130b5:	81 c3 4b 2f 01 00    	add    $0x12f4b,%ebx
   130bb:	8b 44 24 20          	mov    0x20(%esp),%eax
   130bf:	8b 74 24 24          	mov    0x24(%esp),%esi
   130c3:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   130c7:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    KASSERT(privilegeLevel >= 0 && privilegeLevel <= 3);
   130cb:	83 fd 03             	cmp    $0x3,%ebp
   130ce:	76 41                	jbe    13111 <Init_Code_Segment_Descriptor+0x68>
   130d0:	83 ec 0c             	sub    $0xc,%esp
   130d3:	6a 4f                	push   $0x4f
   130d5:	e8 4f e0 ff ff       	call   11129 <Set_Current_Attr>
   130da:	83 c4 0c             	add    $0xc,%esp
   130dd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   130e3:	ff 30                	pushl  (%eax)
   130e5:	ff 74 24 24          	pushl  0x24(%esp)
   130e9:	6a 4a                	push   $0x4a
   130eb:	8d 83 3d 7a ff ff    	lea    -0x85c3(%ebx),%eax
   130f1:	50                   	push   %eax
   130f2:	8d 83 64 7a ff ff    	lea    -0x859c(%ebx),%eax
   130f8:	50                   	push   %eax
   130f9:	8d 83 c8 7a ff ff    	lea    -0x8538(%ebx),%eax
   130ff:	50                   	push   %eax
   13100:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13106:	50                   	push   %eax
   13107:	e8 ce de ff ff       	call   10fda <Print>
   1310c:	83 c4 20             	add    $0x20,%esp
   1310f:	eb fe                	jmp    1310f <Init_Code_Segment_Descriptor+0x66>
    KASSERT(numPages > 0);
   13111:	85 c9                	test   %ecx,%ecx
   13113:	74 51                	je     13166 <Init_Code_Segment_Descriptor+0xbd>
    numPages -= 1;
   13115:	83 e9 01             	sub    $0x1,%ecx
    desc->sizeLow     = numPages & 0xFFFF;
   13118:	66 89 08             	mov    %cx,(%eax)
    desc->sizeHigh    = (numPages >> 16) & 0x0F;
   1311b:	c1 e9 10             	shr    $0x10,%ecx
   1311e:	89 cb                	mov    %ecx,%ebx
   13120:	83 e3 0f             	and    $0xf,%ebx
   13123:	0f b6 48 06          	movzbl 0x6(%eax),%ecx
   13127:	83 e1 d0             	and    $0xffffffd0,%ecx
    desc->baseLow     = baseAddr & 0xFFFFFF;
   1312a:	89 f2                	mov    %esi,%edx
   1312c:	88 50 02             	mov    %dl,0x2(%eax)
   1312f:	89 f2                	mov    %esi,%edx
   13131:	88 70 03             	mov    %dh,0x3(%eax)
   13134:	89 f7                	mov    %esi,%edi
   13136:	c1 ef 10             	shr    $0x10,%edi
   13139:	89 fa                	mov    %edi,%edx
   1313b:	88 50 04             	mov    %dl,0x4(%eax)
    desc->baseHigh    = (baseAddr >> 24) & 0xFF;
   1313e:	c1 ee 18             	shr    $0x18,%esi
   13141:	89 f2                	mov    %esi,%edx
   13143:	88 50 07             	mov    %dl,0x7(%eax)

    Set_Size_And_Base_Pages(desc, baseAddr, numPages);
    desc->type     = 0x0A;   /* 1010b: code, !conforming, readable, !accessed */
    desc->system   = 1;
    desc->dpl      = privilegeLevel;
   13146:	89 ea                	mov    %ebp,%edx
   13148:	83 e2 03             	and    $0x3,%edx
   1314b:	c1 e2 05             	shl    $0x5,%edx
    desc->present  = 1;
   1314e:	83 ca 9a             	or     $0xffffff9a,%edx
   13151:	88 50 05             	mov    %dl,0x5(%eax)
    desc->reserved = 0;
   13154:	89 ca                	mov    %ecx,%edx
   13156:	09 da                	or     %ebx,%edx
    desc->dbBit    = 1;  /* 32 bit code segment */
   13158:	83 ca c0             	or     $0xffffffc0,%edx
   1315b:	88 50 06             	mov    %dl,0x6(%eax)
}
   1315e:	83 c4 0c             	add    $0xc,%esp
   13161:	5b                   	pop    %ebx
   13162:	5e                   	pop    %esi
   13163:	5f                   	pop    %edi
   13164:	5d                   	pop    %ebp
   13165:	c3                   	ret    
    KASSERT(numPages > 0);
   13166:	83 ec 0c             	sub    $0xc,%esp
   13169:	6a 4f                	push   $0x4f
   1316b:	e8 b9 df ff ff       	call   11129 <Set_Current_Attr>
   13170:	83 c4 0c             	add    $0xc,%esp
   13173:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13179:	ff 30                	pushl  (%eax)
   1317b:	ff 74 24 24          	pushl  0x24(%esp)
   1317f:	6a 21                	push   $0x21
   13181:	8d 83 3d 7a ff ff    	lea    -0x85c3(%ebx),%eax
   13187:	50                   	push   %eax
   13188:	8d 83 55 7a ff ff    	lea    -0x85ab(%ebx),%eax
   1318e:	50                   	push   %eax
   1318f:	8d 83 b0 7a ff ff    	lea    -0x8550(%ebx),%eax
   13195:	50                   	push   %eax
   13196:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1319c:	50                   	push   %eax
   1319d:	e8 38 de ff ff       	call   10fda <Print>
   131a2:	83 c4 20             	add    $0x20,%esp
   131a5:	eb fe                	jmp    131a5 <Init_Code_Segment_Descriptor+0xfc>

000131a7 <Init_Data_Segment_Descriptor>:
    struct Segment_Descriptor* desc,
    ulong_t baseAddr,
    ulong_t numPages,
    int privilegeLevel
)
{
   131a7:	55                   	push   %ebp
   131a8:	57                   	push   %edi
   131a9:	56                   	push   %esi
   131aa:	53                   	push   %ebx
   131ab:	83 ec 0c             	sub    $0xc,%esp
   131ae:	e8 5f d0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   131b3:	81 c3 4d 2e 01 00    	add    $0x12e4d,%ebx
   131b9:	8b 44 24 20          	mov    0x20(%esp),%eax
   131bd:	8b 74 24 24          	mov    0x24(%esp),%esi
   131c1:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   131c5:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
    KASSERT(privilegeLevel >= 0 && privilegeLevel <= 3);
   131c9:	83 fd 03             	cmp    $0x3,%ebp
   131cc:	76 41                	jbe    1320f <Init_Data_Segment_Descriptor+0x68>
   131ce:	83 ec 0c             	sub    $0xc,%esp
   131d1:	6a 4f                	push   $0x4f
   131d3:	e8 51 df ff ff       	call   11129 <Set_Current_Attr>
   131d8:	83 c4 0c             	add    $0xc,%esp
   131db:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   131e1:	ff 30                	pushl  (%eax)
   131e3:	ff 74 24 24          	pushl  0x24(%esp)
   131e7:	6a 5f                	push   $0x5f
   131e9:	8d 83 3d 7a ff ff    	lea    -0x85c3(%ebx),%eax
   131ef:	50                   	push   %eax
   131f0:	8d 83 64 7a ff ff    	lea    -0x859c(%ebx),%eax
   131f6:	50                   	push   %eax
   131f7:	8d 83 90 7a ff ff    	lea    -0x8570(%ebx),%eax
   131fd:	50                   	push   %eax
   131fe:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13204:	50                   	push   %eax
   13205:	e8 d0 dd ff ff       	call   10fda <Print>
   1320a:	83 c4 20             	add    $0x20,%esp
   1320d:	eb fe                	jmp    1320d <Init_Data_Segment_Descriptor+0x66>
    KASSERT(numPages > 0);
   1320f:	85 c9                	test   %ecx,%ecx
   13211:	74 51                	je     13264 <Init_Data_Segment_Descriptor+0xbd>
    numPages -= 1;
   13213:	83 e9 01             	sub    $0x1,%ecx
    desc->sizeLow     = numPages & 0xFFFF;
   13216:	66 89 08             	mov    %cx,(%eax)
    desc->sizeHigh    = (numPages >> 16) & 0x0F;
   13219:	c1 e9 10             	shr    $0x10,%ecx
   1321c:	89 cb                	mov    %ecx,%ebx
   1321e:	83 e3 0f             	and    $0xf,%ebx
   13221:	0f b6 48 06          	movzbl 0x6(%eax),%ecx
   13225:	83 e1 d0             	and    $0xffffffd0,%ecx
    desc->baseLow     = baseAddr & 0xFFFFFF;
   13228:	89 f2                	mov    %esi,%edx
   1322a:	88 50 02             	mov    %dl,0x2(%eax)
   1322d:	89 f2                	mov    %esi,%edx
   1322f:	88 70 03             	mov    %dh,0x3(%eax)
   13232:	89 f7                	mov    %esi,%edi
   13234:	c1 ef 10             	shr    $0x10,%edi
   13237:	89 fa                	mov    %edi,%edx
   13239:	88 50 04             	mov    %dl,0x4(%eax)
    desc->baseHigh    = (baseAddr >> 24) & 0xFF;
   1323c:	c1 ee 18             	shr    $0x18,%esi
   1323f:	89 f2                	mov    %esi,%edx
   13241:	88 50 07             	mov    %dl,0x7(%eax)

    Set_Size_And_Base_Pages(desc, baseAddr, numPages);
    desc->type     = 0x02;  /* 0010b: data, expand-up, writable, !accessed */
    desc->system   = 1;
    desc->dpl      = privilegeLevel;
   13244:	89 ea                	mov    %ebp,%edx
   13246:	83 e2 03             	and    $0x3,%edx
   13249:	c1 e2 05             	shl    $0x5,%edx
    desc->present  = 1;
   1324c:	83 ca 92             	or     $0xffffff92,%edx
   1324f:	88 50 05             	mov    %dl,0x5(%eax)
    desc->reserved = 0;
   13252:	89 ca                	mov    %ecx,%edx
   13254:	09 da                	or     %ebx,%edx
    desc->dbBit    = 1;  /* 32 bit operands */
   13256:	83 ca c0             	or     $0xffffffc0,%edx
   13259:	88 50 06             	mov    %dl,0x6(%eax)
}
   1325c:	83 c4 0c             	add    $0xc,%esp
   1325f:	5b                   	pop    %ebx
   13260:	5e                   	pop    %esi
   13261:	5f                   	pop    %edi
   13262:	5d                   	pop    %ebp
   13263:	c3                   	ret    
    KASSERT(numPages > 0);
   13264:	83 ec 0c             	sub    $0xc,%esp
   13267:	6a 4f                	push   $0x4f
   13269:	e8 bb de ff ff       	call   11129 <Set_Current_Attr>
   1326e:	83 c4 0c             	add    $0xc,%esp
   13271:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13277:	ff 30                	pushl  (%eax)
   13279:	ff 74 24 24          	pushl  0x24(%esp)
   1327d:	6a 21                	push   $0x21
   1327f:	8d 83 3d 7a ff ff    	lea    -0x85c3(%ebx),%eax
   13285:	50                   	push   %eax
   13286:	8d 83 55 7a ff ff    	lea    -0x85ab(%ebx),%eax
   1328c:	50                   	push   %eax
   1328d:	8d 83 b0 7a ff ff    	lea    -0x8550(%ebx),%eax
   13293:	50                   	push   %eax
   13294:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1329a:	50                   	push   %eax
   1329b:	e8 3a dd ff ff       	call   10fda <Print>
   132a0:	83 c4 20             	add    $0x20,%esp
   132a3:	eb fe                	jmp    132a3 <Init_Data_Segment_Descriptor+0xfc>

000132a5 <Init_TSS_Descriptor>:

/*
 * Initialize a TSS descriptor.
 */
void Init_TSS_Descriptor(struct Segment_Descriptor* desc, struct TSS* theTSS)
{
   132a5:	8b 44 24 04          	mov    0x4(%esp),%eax
   132a9:	8b 54 24 08          	mov    0x8(%esp),%edx
    desc->sizeLow     = numBytes & 0xFFFF;
   132ad:	66 c7 00 68 00       	movw   $0x68,(%eax)
    desc->baseLow     = baseAddr & 0xFFFFFF;
   132b2:	88 50 02             	mov    %dl,0x2(%eax)
   132b5:	88 70 03             	mov    %dh,0x3(%eax)
   132b8:	89 d1                	mov    %edx,%ecx
   132ba:	c1 e9 10             	shr    $0x10,%ecx
   132bd:	88 48 04             	mov    %cl,0x4(%eax)
    desc->baseHigh    = (baseAddr >> 24) & 0xFF;
   132c0:	c1 ea 18             	shr    $0x18,%edx
   132c3:	88 50 07             	mov    %dl,0x7(%eax)
    Set_Size_And_Base_Bytes(desc, (ulong_t) theTSS, sizeof(struct TSS));
    desc->type     = 0x09;  /* 1001b: 32 bit, !busy */
    desc->system   = 0;
    desc->dpl      = 0;
    desc->present  = 1;
   132c6:	c6 40 05 89          	movb   $0x89,0x5(%eax)
    desc->reserved = 0;
    desc->dbBit    = 0;  /* must be 0 in TSS */
   132ca:	80 60 06 10          	andb   $0x10,0x6(%eax)
}
   132ce:	c3                   	ret    

000132cf <Init_LDT_Descriptor>:
void Init_LDT_Descriptor(
    struct Segment_Descriptor* desc,
    struct Segment_Descriptor theLDT[],
    int numEntries
)
{
   132cf:	57                   	push   %edi
   132d0:	56                   	push   %esi
   132d1:	53                   	push   %ebx
   132d2:	8b 44 24 10          	mov    0x10(%esp),%eax
   132d6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    Set_Size_And_Base_Bytes(
	desc, (ulong_t) theLDT, sizeof(struct Segment_Descriptor) * numEntries);
   132da:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   132de:	8d 14 dd 00 00 00 00 	lea    0x0(,%ebx,8),%edx
    desc->sizeLow     = numBytes & 0xFFFF;
   132e5:	66 89 10             	mov    %dx,(%eax)
    desc->sizeHigh    = (numBytes >> 16) & 0x0F;
   132e8:	c1 ea 10             	shr    $0x10,%edx
   132eb:	89 d7                	mov    %edx,%edi
   132ed:	83 e7 0f             	and    $0xf,%edi
   132f0:	0f b6 58 06          	movzbl 0x6(%eax),%ebx
   132f4:	83 e3 10             	and    $0x10,%ebx
    desc->baseLow     = baseAddr & 0xFFFFFF;
   132f7:	88 48 02             	mov    %cl,0x2(%eax)
   132fa:	88 68 03             	mov    %ch,0x3(%eax)
   132fd:	89 ce                	mov    %ecx,%esi
   132ff:	c1 ee 10             	shr    $0x10,%esi
   13302:	89 f2                	mov    %esi,%edx
   13304:	88 50 04             	mov    %dl,0x4(%eax)
    desc->baseHigh    = (baseAddr >> 24) & 0xFF;
   13307:	c1 e9 18             	shr    $0x18,%ecx
   1330a:	88 48 07             	mov    %cl,0x7(%eax)

    desc->type     = 0x02;  /* 0010b */
    desc->system   = 0;
    desc->dpl      = 0;
    desc->present  = 1;
   1330d:	c6 40 05 82          	movb   $0x82,0x5(%eax)
    desc->reserved = 0;
    desc->dbBit    = 0;
   13311:	89 fa                	mov    %edi,%edx
   13313:	09 da                	or     %ebx,%edx
   13315:	88 50 06             	mov    %dl,0x6(%eax)
}
   13318:	5b                   	pop    %ebx
   13319:	5e                   	pop    %esi
   1331a:	5f                   	pop    %edi
   1331b:	c3                   	ret    

0001331c <bget>:

/*  BGET  --  Allocate a buffer.  */

void *bget(requested_size)
  bufsize requested_size;
{
   1331c:	55                   	push   %ebp
   1331d:	57                   	push   %edi
   1331e:	56                   	push   %esi
   1331f:	53                   	push   %ebx
   13320:	83 ec 0c             	sub    $0xc,%esp
   13323:	e8 ea ce ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13328:	81 c3 d8 2c 01 00    	add    $0x12cd8,%ebx
   1332e:	8b 44 24 20          	mov    0x20(%esp),%eax
    void *buf;
#ifdef BECtl
    int compactseq = 0;
#endif

    assert(size > 0);
   13332:	85 c0                	test   %eax,%eax
   13334:	7e 2e                	jle    13364 <bget+0x48>

    if (size < SizeQ) { 	      /* Need at least room for the */
	size = SizeQ;		      /*    queue links.  */
   13336:	83 f8 07             	cmp    $0x7,%eax
   13339:	ba 08 00 00 00       	mov    $0x8,%edx
   1333e:	0f 46 c2             	cmovbe %edx,%eax
    }
#ifdef SizeQuant
#if SizeQuant > 1
    size = (size + (SizeQuant - 1)) & (~(SizeQuant - 1));
   13341:	8d 48 03             	lea    0x3(%eax),%ecx
   13344:	83 e1 fc             	and    $0xfffffffc,%ecx
#endif
#endif

    size += sizeof(struct bhead);     /* Add overhead in allocated buffer
   13347:	83 c1 08             	add    $0x8,%ecx
   1334a:	89 ce                	mov    %ecx,%esi
       a loop around the allocation process  to  allow	compaction  to
       intervene in case we don't find a suitable buffer in the chain. */

    while (1) {
#endif
	b = freelist.ql.flink;
   1334c:	8b 93 38 00 00 00    	mov    0x38(%ebx),%edx

	/* Scan the free list searching for the first buffer big enough
	   to hold the requested size buffer. */

#ifdef BestFit
	while (b != &freelist) {
   13352:	8d 83 30 00 00 00    	lea    0x30(%ebx),%eax
   13358:	39 c2                	cmp    %eax,%edx
   1335a:	0f 84 ff 01 00 00    	je     1355f <bget+0x243>
	    if (b->bh.bsize >= size) {
		if ((best == &freelist) || (b->bh.bsize < best->bh.bsize)) {
   13360:	89 c5                	mov    %eax,%ebp
   13362:	eb 4d                	jmp    133b1 <bget+0x95>
    assert(size > 0);
   13364:	83 ec 0c             	sub    $0xc,%esp
   13367:	6a 4f                	push   $0x4f
   13369:	e8 bb dd ff ff       	call   11129 <Set_Current_Attr>
   1336e:	83 c4 0c             	add    $0xc,%esp
   13371:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13377:	ff 30                	pushl  (%eax)
   13379:	ff 74 24 24          	pushl  0x24(%esp)
   1337d:	68 4d 02 00 00       	push   $0x24d
   13382:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13388:	50                   	push   %eax
   13389:	8d 83 e5 7b ff ff    	lea    -0x841b(%ebx),%eax
   1338f:	50                   	push   %eax
   13390:	8d 83 b0 7d ff ff    	lea    -0x8250(%ebx),%eax
   13396:	50                   	push   %eax
   13397:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1339d:	50                   	push   %eax
   1339e:	e8 37 dc ff ff       	call   10fda <Print>
   133a3:	83 c4 20             	add    $0x20,%esp
   133a6:	eb fe                	jmp    133a6 <bget+0x8a>
   133a8:	89 d0                	mov    %edx,%eax
		    best = b;
		}
	    }
	    b = b->ql.flink;		  /* Link to next buffer */
   133aa:	8b 52 08             	mov    0x8(%edx),%edx
	while (b != &freelist) {
   133ad:	39 ea                	cmp    %ebp,%edx
   133af:	74 13                	je     133c4 <bget+0xa8>
	    if (b->bh.bsize >= size) {
   133b1:	8b 7a 04             	mov    0x4(%edx),%edi
   133b4:	39 f7                	cmp    %esi,%edi
   133b6:	7c f2                	jl     133aa <bget+0x8e>
		if ((best == &freelist) || (b->bh.bsize < best->bh.bsize)) {
   133b8:	39 e8                	cmp    %ebp,%eax
   133ba:	74 ec                	je     133a8 <bget+0x8c>
   133bc:	3b 78 04             	cmp    0x4(%eax),%edi
   133bf:	0f 4c c2             	cmovl  %edx,%eax
   133c2:	eb e6                	jmp    133aa <bget+0x8e>
	}
	b = best;
#endif /* BestFit */

	while (b != &freelist) {
   133c4:	8d 93 30 00 00 00    	lea    0x30(%ebx),%edx
   133ca:	39 d0                	cmp    %edx,%eax
   133cc:	0f 84 97 01 00 00    	je     13569 <bget+0x24d>
   133d2:	89 d7                	mov    %edx,%edi
	    if ((bufsize) b->bh.bsize >= size) {
   133d4:	8b 50 04             	mov    0x4(%eax),%edx
   133d7:	39 f2                	cmp    %esi,%edx
   133d9:	7d 14                	jge    133ef <bget+0xd3>
		    /* Give user buffer starting at queue links. */
		    buf =  (void *) &(b->ql);
		    return buf;
		}
	    }
	    b = b->ql.flink;		  /* Link to next buffer */
   133db:	8b 40 08             	mov    0x8(%eax),%eax
	while (b != &freelist) {
   133de:	39 f8                	cmp    %edi,%eax
   133e0:	75 f2                	jne    133d4 <bget+0xb8>

    /*	Still no buffer available */

#endif /* BECtl */

    return NULL;
   133e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   133e7:	83 c4 0c             	add    $0xc,%esp
   133ea:	5b                   	pop    %ebx
   133eb:	5e                   	pop    %esi
   133ec:	5f                   	pop    %edi
   133ed:	5d                   	pop    %ebp
   133ee:	c3                   	ret    
		if ((b->bh.bsize - size) > (SizeQ + (sizeof(struct bhead)))) {
   133ef:	89 d5                	mov    %edx,%ebp
   133f1:	29 cd                	sub    %ecx,%ebp
   133f3:	83 fd 10             	cmp    $0x10,%ebp
   133f6:	76 63                	jbe    1345b <bget+0x13f>
		    ba = BH(((char *) b) + (b->bh.bsize - size));
   133f8:	8d 34 28             	lea    (%eax,%ebp,1),%esi
		    bn = BH(((char *) ba) + size);
   133fb:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
		    assert(bn->prevfree == b->bh.bsize);
   133fe:	3b 17                	cmp    (%edi),%edx
   13400:	74 44                	je     13446 <bget+0x12a>
   13402:	83 ec 0c             	sub    $0xc,%esp
   13405:	6a 4f                	push   $0x4f
   13407:	e8 1d dd ff ff       	call   11129 <Set_Current_Attr>
   1340c:	83 c4 0c             	add    $0xc,%esp
   1340f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13415:	ff 30                	pushl  (%eax)
   13417:	ff 74 24 24          	pushl  0x24(%esp)
   1341b:	68 88 02 00 00       	push   $0x288
   13420:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13426:	50                   	push   %eax
   13427:	8d 83 fa 7a ff ff    	lea    -0x8506(%ebx),%eax
   1342d:	50                   	push   %eax
   1342e:	8d 83 b0 7d ff ff    	lea    -0x8250(%ebx),%eax
   13434:	50                   	push   %eax
   13435:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1343b:	50                   	push   %eax
   1343c:	e8 99 db ff ff       	call   10fda <Print>
   13441:	83 c4 20             	add    $0x20,%esp
   13444:	eb fe                	jmp    13444 <bget+0x128>
		    b->bh.bsize -= size;
   13446:	89 68 04             	mov    %ebp,0x4(%eax)
		    ba->prevfree = b->bh.bsize;
   13449:	89 2e                	mov    %ebp,(%esi)
		    ba->bsize = -(bufsize) size;
   1344b:	f7 d9                	neg    %ecx
   1344d:	89 4e 04             	mov    %ecx,0x4(%esi)
		    bn->prevfree = 0;
   13450:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		    buf = (void *) ((((char *) ba) + sizeof(struct bhead)));
   13456:	8d 46 08             	lea    0x8(%esi),%eax
		    return buf;
   13459:	eb 8c                	jmp    133e7 <bget+0xcb>
		    ba = BH(((char *) b) + b->bh.bsize);
   1345b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
		    assert(ba->prevfree == b->bh.bsize);
   1345e:	3b 11                	cmp    (%ecx),%edx
   13460:	75 50                	jne    134b2 <bget+0x196>
		    assert(b->ql.blink->ql.flink == b);
   13462:	8b 50 0c             	mov    0xc(%eax),%edx
   13465:	39 42 08             	cmp    %eax,0x8(%edx)
   13468:	0f 84 88 00 00 00    	je     134f6 <bget+0x1da>
   1346e:	83 ec 0c             	sub    $0xc,%esp
   13471:	6a 4f                	push   $0x4f
   13473:	e8 b1 dc ff ff       	call   11129 <Set_Current_Attr>
   13478:	83 c4 0c             	add    $0xc,%esp
   1347b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13481:	ff 30                	pushl  (%eax)
   13483:	ff 74 24 24          	pushl  0x24(%esp)
   13487:	68 a1 02 00 00       	push   $0x2a1
   1348c:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13492:	50                   	push   %eax
   13493:	8d 83 32 7b ff ff    	lea    -0x84ce(%ebx),%eax
   13499:	50                   	push   %eax
   1349a:	8d 83 b0 7d ff ff    	lea    -0x8250(%ebx),%eax
   134a0:	50                   	push   %eax
   134a1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   134a7:	50                   	push   %eax
   134a8:	e8 2d db ff ff       	call   10fda <Print>
   134ad:	83 c4 20             	add    $0x20,%esp
   134b0:	eb fe                	jmp    134b0 <bget+0x194>
		    assert(ba->prevfree == b->bh.bsize);
   134b2:	83 ec 0c             	sub    $0xc,%esp
   134b5:	6a 4f                	push   $0x4f
   134b7:	e8 6d dc ff ff       	call   11129 <Set_Current_Attr>
   134bc:	83 c4 0c             	add    $0xc,%esp
   134bf:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   134c5:	ff 30                	pushl  (%eax)
   134c7:	ff 74 24 24          	pushl  0x24(%esp)
   134cb:	68 9c 02 00 00       	push   $0x29c
   134d0:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   134d6:	50                   	push   %eax
   134d7:	8d 83 16 7b ff ff    	lea    -0x84ea(%ebx),%eax
   134dd:	50                   	push   %eax
   134de:	8d 83 b0 7d ff ff    	lea    -0x8250(%ebx),%eax
   134e4:	50                   	push   %eax
   134e5:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   134eb:	50                   	push   %eax
   134ec:	e8 e9 da ff ff       	call   10fda <Print>
   134f1:	83 c4 20             	add    $0x20,%esp
   134f4:	eb fe                	jmp    134f4 <bget+0x1d8>
		    assert(b->ql.flink->ql.blink == b);
   134f6:	8b 70 08             	mov    0x8(%eax),%esi
   134f9:	39 46 0c             	cmp    %eax,0xc(%esi)
   134fc:	74 44                	je     13542 <bget+0x226>
   134fe:	83 ec 0c             	sub    $0xc,%esp
   13501:	6a 4f                	push   $0x4f
   13503:	e8 21 dc ff ff       	call   11129 <Set_Current_Attr>
   13508:	83 c4 0c             	add    $0xc,%esp
   1350b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13511:	ff 30                	pushl  (%eax)
   13513:	ff 74 24 24          	pushl  0x24(%esp)
   13517:	68 a2 02 00 00       	push   $0x2a2
   1351c:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13522:	50                   	push   %eax
   13523:	8d 83 4d 7b ff ff    	lea    -0x84b3(%ebx),%eax
   13529:	50                   	push   %eax
   1352a:	8d 83 b0 7d ff ff    	lea    -0x8250(%ebx),%eax
   13530:	50                   	push   %eax
   13531:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13537:	50                   	push   %eax
   13538:	e8 9d da ff ff       	call   10fda <Print>
   1353d:	83 c4 20             	add    $0x20,%esp
   13540:	eb fe                	jmp    13540 <bget+0x224>
		    b->ql.blink->ql.flink = b->ql.flink;
   13542:	89 72 08             	mov    %esi,0x8(%edx)
		    b->ql.flink->ql.blink = b->ql.blink;
   13545:	8b 50 08             	mov    0x8(%eax),%edx
   13548:	8b 58 0c             	mov    0xc(%eax),%ebx
   1354b:	89 5a 0c             	mov    %ebx,0xc(%edx)
		    b->bh.bsize = -(b->bh.bsize);
   1354e:	f7 58 04             	negl   0x4(%eax)
		    ba->prevfree = 0;
   13551:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		    buf =  (void *) &(b->ql);
   13557:	83 c0 08             	add    $0x8,%eax
		    return buf;
   1355a:	e9 88 fe ff ff       	jmp    133e7 <bget+0xcb>
    return NULL;
   1355f:	b8 00 00 00 00       	mov    $0x0,%eax
   13564:	e9 7e fe ff ff       	jmp    133e7 <bget+0xcb>
   13569:	b8 00 00 00 00       	mov    $0x0,%eax
   1356e:	e9 74 fe ff ff       	jmp    133e7 <bget+0xcb>

00013573 <bgetz>:
	       the  entire  contents  of  the buffer to zero, not just the
	       region requested by the caller. */

void *bgetz(size)
  bufsize size;
{
   13573:	57                   	push   %edi
   13574:	56                   	push   %esi
   13575:	53                   	push   %ebx
   13576:	e8 97 cc ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1357b:	81 c3 85 2a 01 00    	add    $0x12a85,%ebx
   13581:	8b 7c 24 10          	mov    0x10(%esp),%edi
    char *buf = (char *) bget(size);
   13585:	83 ec 0c             	sub    $0xc,%esp
   13588:	57                   	push   %edi
   13589:	e8 8e fd ff ff       	call   1331c <bget>
   1358e:	89 c6                	mov    %eax,%esi

    if (buf != NULL) {
   13590:	83 c4 10             	add    $0x10,%esp
   13593:	85 c0                	test   %eax,%eax
   13595:	74 6d                	je     13604 <bgetz+0x91>
	struct bhead *b;
	bufsize rsize;

	b = BH(buf - sizeof(struct bhead));
	rsize = -(b->bsize);
   13597:	8b 50 fc             	mov    -0x4(%eax),%edx
	if (rsize == 0) {
   1359a:	85 d2                	test   %edx,%edx
   1359c:	75 4e                	jne    135ec <bgetz+0x79>
	    struct bdhead *bd;

	    bd = BDH(buf - sizeof(struct bdhead));
	    rsize = bd->tsize - sizeof(struct bdhead);
   1359e:	8b 40 f4             	mov    -0xc(%eax),%eax
   135a1:	83 e8 0c             	sub    $0xc,%eax
	} else {
	    rsize -= sizeof(struct bhead);
	}
	assert(rsize >= size);
   135a4:	39 f8                	cmp    %edi,%eax
   135a6:	7d 4d                	jge    135f5 <bgetz+0x82>
   135a8:	83 ec 0c             	sub    $0xc,%esp
   135ab:	6a 4f                	push   $0x4f
   135ad:	e8 77 db ff ff       	call   11129 <Set_Current_Attr>
   135b2:	83 c4 0c             	add    $0xc,%esp
   135b5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   135bb:	ff 30                	pushl  (%eax)
   135bd:	ff 74 24 14          	pushl  0x14(%esp)
   135c1:	68 0d 03 00 00       	push   $0x30d
   135c6:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   135cc:	50                   	push   %eax
   135cd:	8d 83 68 7b ff ff    	lea    -0x8498(%ebx),%eax
   135d3:	50                   	push   %eax
   135d4:	8d 83 a8 7d ff ff    	lea    -0x8258(%ebx),%eax
   135da:	50                   	push   %eax
   135db:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   135e1:	50                   	push   %eax
   135e2:	e8 f3 d9 ff ff       	call   10fda <Print>
   135e7:	83 c4 20             	add    $0x20,%esp
   135ea:	eb fe                	jmp    135ea <bgetz+0x77>
	    rsize -= sizeof(struct bhead);
   135ec:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   135f1:	29 d0                	sub    %edx,%eax
   135f3:	eb af                	jmp    135a4 <bgetz+0x31>
	V memset(buf, 0, (MemSize) rsize);
   135f5:	83 ec 04             	sub    $0x4,%esp
   135f8:	50                   	push   %eax
   135f9:	6a 00                	push   $0x0
   135fb:	56                   	push   %esi
   135fc:	e8 5a 94 00 00       	call   1ca5b <memset>
   13601:	83 c4 10             	add    $0x10,%esp
    }
    return ((void *) buf);
}
   13604:	89 f0                	mov    %esi,%eax
   13606:	5b                   	pop    %ebx
   13607:	5e                   	pop    %esi
   13608:	5f                   	pop    %edi
   13609:	c3                   	ret    

0001360a <brel>:

/*  BREL  --  Release a buffer.  */

void brel(buf)
  void *buf;
{
   1360a:	56                   	push   %esi
   1360b:	53                   	push   %ebx
   1360c:	83 ec 04             	sub    $0x4,%esp
   1360f:	e8 fe cb ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13614:	81 c3 ec 29 01 00    	add    $0x129ec,%ebx
   1361a:	8b 44 24 10          	mov    0x10(%esp),%eax

    b = BFH(((char *) buf) - sizeof(struct bhead));
#ifdef BufStats
    numrel++;			      /* Increment number of brel() calls */
#endif
    assert(buf != NULL);
   1361e:	85 c0                	test   %eax,%eax
   13620:	0f 84 a1 00 00 00    	je     136c7 <brel+0xbd>
#endif /* BECtl */

    /* Buffer size must be negative, indicating that the buffer is
       allocated. */

    if (b->bh.bsize >= 0) {
   13626:	8b 48 fc             	mov    -0x4(%eax),%ecx
	bn = NULL;
    }
    assert(b->bh.bsize < 0);
   13629:	85 c9                	test   %ecx,%ecx
   1362b:	0f 89 da 00 00 00    	jns    1370b <brel+0x101>
    b = BFH(((char *) buf) - sizeof(struct bhead));
   13631:	8d 50 f8             	lea    -0x8(%eax),%edx

    /*	Back pointer in next buffer must be zero, indicating the
	same thing: */

    assert(BH((char *) b - b->bh.bsize)->prevfree == 0);
   13634:	89 d6                	mov    %edx,%esi
   13636:	29 ce                	sub    %ecx,%esi
   13638:	83 3e 00             	cmpl   $0x0,(%esi)
   1363b:	0f 85 0e 01 00 00    	jne    1374f <brel+0x145>
    assert(totalloc >= 0);
#endif

    /* If the back link is nonzero, the previous buffer is free.  */

    if (b->bh.prevfree != 0) {
   13641:	8b 70 f8             	mov    -0x8(%eax),%esi
   13644:	85 f6                	test   %esi,%esi
   13646:	0f 84 8b 01 00 00    	je     137d7 <brel+0x1cd>
	   allocated. */

	register bufsize size = b->bh.bsize;

        /* Make the previous buffer the one we're working on. */
	assert(BH((char *) b - b->bh.prevfree)->bsize == b->bh.prevfree);
   1364c:	29 f2                	sub    %esi,%edx
   1364e:	8b 42 04             	mov    0x4(%edx),%eax
   13651:	39 c6                	cmp    %eax,%esi
   13653:	0f 85 3a 01 00 00    	jne    13793 <brel+0x189>
	b = BFH(((char *) b) - b->bh.prevfree);
	b->bh.bsize -= size;
   13659:	29 c8                	sub    %ecx,%eax
   1365b:	89 42 04             	mov    %eax,0x4(%edx)
    /* Now we look at the next buffer in memory, located by advancing from
       the  start  of  this  buffer  by its size, to see if that buffer is
       free.  If it is, we combine  this  buffer  with	the  next  one	in
       memory, dechaining the second buffer from the free list. */

    bn =  BFH(((char *) b) + b->bh.bsize);
   1365e:	89 d0                	mov    %edx,%eax
   13660:	03 42 04             	add    0x4(%edx),%eax
    if (bn->bh.bsize > 0) {
   13663:	8b 48 04             	mov    0x4(%eax),%ecx
   13666:	85 c9                	test   %ecx,%ecx
   13668:	0f 8e dc 02 00 00    	jle    1394a <brel+0x340>

	/* The buffer is free.	Remove it from the free list and add
	   its size to that of our buffer. */

	assert(BH((char *) bn + bn->bh.bsize)->prevfree == bn->bh.bsize);
   1366e:	3b 0c 08             	cmp    (%eax,%ecx,1),%ecx
   13671:	0f 85 2f 02 00 00    	jne    138a6 <brel+0x29c>
	assert(bn->ql.blink->ql.flink == bn);
   13677:	8b 70 0c             	mov    0xc(%eax),%esi
   1367a:	39 46 08             	cmp    %eax,0x8(%esi)
   1367d:	0f 84 67 02 00 00    	je     138ea <brel+0x2e0>
   13683:	83 ec 0c             	sub    $0xc,%esp
   13686:	6a 4f                	push   $0x4f
   13688:	e8 9c da ff ff       	call   11129 <Set_Current_Attr>
   1368d:	83 c4 0c             	add    $0xc,%esp
   13690:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13696:	ff 30                	pushl  (%eax)
   13698:	ff 74 24 14          	pushl  0x14(%esp)
   1369c:	68 97 03 00 00       	push   $0x397
   136a1:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   136a7:	50                   	push   %eax
   136a8:	8d 83 99 7b ff ff    	lea    -0x8467(%ebx),%eax
   136ae:	50                   	push   %eax
   136af:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   136b5:	50                   	push   %eax
   136b6:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   136bc:	50                   	push   %eax
   136bd:	e8 18 d9 ff ff       	call   10fda <Print>
   136c2:	83 c4 20             	add    $0x20,%esp
   136c5:	eb fe                	jmp    136c5 <brel+0xbb>
    assert(buf != NULL);
   136c7:	83 ec 0c             	sub    $0xc,%esp
   136ca:	6a 4f                	push   $0x4f
   136cc:	e8 58 da ff ff       	call   11129 <Set_Current_Attr>
   136d1:	83 c4 0c             	add    $0xc,%esp
   136d4:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   136da:	ff 30                	pushl  (%eax)
   136dc:	ff 74 24 14          	pushl  0x14(%esp)
   136e0:	68 44 03 00 00       	push   $0x344
   136e5:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   136eb:	50                   	push   %eax
   136ec:	8d 83 76 7b ff ff    	lea    -0x848a(%ebx),%eax
   136f2:	50                   	push   %eax
   136f3:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   136f9:	50                   	push   %eax
   136fa:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13700:	50                   	push   %eax
   13701:	e8 d4 d8 ff ff       	call   10fda <Print>
   13706:	83 c4 20             	add    $0x20,%esp
   13709:	eb fe                	jmp    13709 <brel+0xff>
    assert(b->bh.bsize < 0);
   1370b:	83 ec 0c             	sub    $0xc,%esp
   1370e:	6a 4f                	push   $0x4f
   13710:	e8 14 da ff ff       	call   11129 <Set_Current_Attr>
   13715:	83 c4 0c             	add    $0xc,%esp
   13718:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1371e:	ff 30                	pushl  (%eax)
   13720:	ff 74 24 14          	pushl  0x14(%esp)
   13724:	68 61 03 00 00       	push   $0x361
   13729:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   1372f:	50                   	push   %eax
   13730:	8d 83 89 7b ff ff    	lea    -0x8477(%ebx),%eax
   13736:	50                   	push   %eax
   13737:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   1373d:	50                   	push   %eax
   1373e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13744:	50                   	push   %eax
   13745:	e8 90 d8 ff ff       	call   10fda <Print>
   1374a:	83 c4 20             	add    $0x20,%esp
   1374d:	eb fe                	jmp    1374d <brel+0x143>
    assert(BH((char *) b - b->bh.bsize)->prevfree == 0);
   1374f:	83 ec 0c             	sub    $0xc,%esp
   13752:	6a 4f                	push   $0x4f
   13754:	e8 d0 d9 ff ff       	call   11129 <Set_Current_Attr>
   13759:	83 c4 0c             	add    $0xc,%esp
   1375c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13762:	ff 30                	pushl  (%eax)
   13764:	ff 74 24 14          	pushl  0x14(%esp)
   13768:	68 66 03 00 00       	push   $0x366
   1376d:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13773:	50                   	push   %eax
   13774:	8d 83 f0 7b ff ff    	lea    -0x8410(%ebx),%eax
   1377a:	50                   	push   %eax
   1377b:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   13781:	50                   	push   %eax
   13782:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13788:	50                   	push   %eax
   13789:	e8 4c d8 ff ff       	call   10fda <Print>
   1378e:	83 c4 20             	add    $0x20,%esp
   13791:	eb fe                	jmp    13791 <brel+0x187>
	assert(BH((char *) b - b->bh.prevfree)->bsize == b->bh.prevfree);
   13793:	83 ec 0c             	sub    $0xc,%esp
   13796:	6a 4f                	push   $0x4f
   13798:	e8 8c d9 ff ff       	call   11129 <Set_Current_Attr>
   1379d:	83 c4 0c             	add    $0xc,%esp
   137a0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   137a6:	ff 30                	pushl  (%eax)
   137a8:	ff 74 24 14          	pushl  0x14(%esp)
   137ac:	68 7a 03 00 00       	push   $0x37a
   137b1:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   137b7:	50                   	push   %eax
   137b8:	8d 83 30 7c ff ff    	lea    -0x83d0(%ebx),%eax
   137be:	50                   	push   %eax
   137bf:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   137c5:	50                   	push   %eax
   137c6:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   137cc:	50                   	push   %eax
   137cd:	e8 08 d8 ff ff       	call   10fda <Print>
   137d2:	83 c4 20             	add    $0x20,%esp
   137d5:	eb fe                	jmp    137d5 <brel+0x1cb>
	assert(freelist.ql.blink->ql.flink == &freelist);
   137d7:	8b b3 3c 00 00 00    	mov    0x3c(%ebx),%esi
   137dd:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   137e3:	39 4e 08             	cmp    %ecx,0x8(%esi)
   137e6:	74 44                	je     1382c <brel+0x222>
   137e8:	83 ec 0c             	sub    $0xc,%esp
   137eb:	6a 4f                	push   $0x4f
   137ed:	e8 37 d9 ff ff       	call   11129 <Set_Current_Attr>
   137f2:	83 c4 0c             	add    $0xc,%esp
   137f5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   137fb:	ff 30                	pushl  (%eax)
   137fd:	ff 74 24 14          	pushl  0x14(%esp)
   13801:	68 82 03 00 00       	push   $0x382
   13806:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   1380c:	50                   	push   %eax
   1380d:	8d 83 7c 7c ff ff    	lea    -0x8384(%ebx),%eax
   13813:	50                   	push   %eax
   13814:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   1381a:	50                   	push   %eax
   1381b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13821:	50                   	push   %eax
   13822:	e8 b3 d7 ff ff       	call   10fda <Print>
   13827:	83 c4 20             	add    $0x20,%esp
   1382a:	eb fe                	jmp    1382a <brel+0x220>
	assert(freelist.ql.flink->ql.blink == &freelist);
   1382c:	8b b3 38 00 00 00    	mov    0x38(%ebx),%esi
   13832:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   13838:	39 4e 0c             	cmp    %ecx,0xc(%esi)
   1383b:	74 44                	je     13881 <brel+0x277>
   1383d:	83 ec 0c             	sub    $0xc,%esp
   13840:	6a 4f                	push   $0x4f
   13842:	e8 e2 d8 ff ff       	call   11129 <Set_Current_Attr>
   13847:	83 c4 0c             	add    $0xc,%esp
   1384a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13850:	ff 30                	pushl  (%eax)
   13852:	ff 74 24 14          	pushl  0x14(%esp)
   13856:	68 83 03 00 00       	push   $0x383
   1385b:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13861:	50                   	push   %eax
   13862:	8d 83 a8 7c ff ff    	lea    -0x8358(%ebx),%eax
   13868:	50                   	push   %eax
   13869:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   1386f:	50                   	push   %eax
   13870:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13876:	50                   	push   %eax
   13877:	e8 5e d7 ff ff       	call   10fda <Print>
   1387c:	83 c4 20             	add    $0x20,%esp
   1387f:	eb fe                	jmp    1387f <brel+0x275>
	b->ql.flink = &freelist;
   13881:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   13887:	89 08                	mov    %ecx,(%eax)
	b->ql.blink = freelist.ql.blink;
   13889:	8b 8b 3c 00 00 00    	mov    0x3c(%ebx),%ecx
   1388f:	89 48 04             	mov    %ecx,0x4(%eax)
	freelist.ql.blink = b;
   13892:	89 93 3c 00 00 00    	mov    %edx,0x3c(%ebx)
	b->ql.blink->ql.flink = b;
   13898:	8b 48 04             	mov    0x4(%eax),%ecx
   1389b:	89 51 08             	mov    %edx,0x8(%ecx)
	b->bh.bsize = -b->bh.bsize;
   1389e:	f7 58 fc             	negl   -0x4(%eax)
   138a1:	e9 b8 fd ff ff       	jmp    1365e <brel+0x54>
	assert(BH((char *) bn + bn->bh.bsize)->prevfree == bn->bh.bsize);
   138a6:	83 ec 0c             	sub    $0xc,%esp
   138a9:	6a 4f                	push   $0x4f
   138ab:	e8 79 d8 ff ff       	call   11129 <Set_Current_Attr>
   138b0:	83 c4 0c             	add    $0xc,%esp
   138b3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   138b9:	ff 30                	pushl  (%eax)
   138bb:	ff 74 24 14          	pushl  0x14(%esp)
   138bf:	68 96 03 00 00       	push   $0x396
   138c4:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   138ca:	50                   	push   %eax
   138cb:	8d 83 d4 7c ff ff    	lea    -0x832c(%ebx),%eax
   138d1:	50                   	push   %eax
   138d2:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   138d8:	50                   	push   %eax
   138d9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   138df:	50                   	push   %eax
   138e0:	e8 f5 d6 ff ff       	call   10fda <Print>
   138e5:	83 c4 20             	add    $0x20,%esp
   138e8:	eb fe                	jmp    138e8 <brel+0x2de>
	assert(bn->ql.flink->ql.blink == bn);
   138ea:	8b 48 08             	mov    0x8(%eax),%ecx
   138ed:	39 41 0c             	cmp    %eax,0xc(%ecx)
   138f0:	74 44                	je     13936 <brel+0x32c>
   138f2:	83 ec 0c             	sub    $0xc,%esp
   138f5:	6a 4f                	push   $0x4f
   138f7:	e8 2d d8 ff ff       	call   11129 <Set_Current_Attr>
   138fc:	83 c4 0c             	add    $0xc,%esp
   138ff:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13905:	ff 30                	pushl  (%eax)
   13907:	ff 74 24 14          	pushl  0x14(%esp)
   1390b:	68 98 03 00 00       	push   $0x398
   13910:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13916:	50                   	push   %eax
   13917:	8d 83 b6 7b ff ff    	lea    -0x844a(%ebx),%eax
   1391d:	50                   	push   %eax
   1391e:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   13924:	50                   	push   %eax
   13925:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1392b:	50                   	push   %eax
   1392c:	e8 a9 d6 ff ff       	call   10fda <Print>
   13931:	83 c4 20             	add    $0x20,%esp
   13934:	eb fe                	jmp    13934 <brel+0x32a>
	bn->ql.blink->ql.flink = bn->ql.flink;
   13936:	89 4e 08             	mov    %ecx,0x8(%esi)
	bn->ql.flink->ql.blink = bn->ql.blink;
   13939:	8b 70 0c             	mov    0xc(%eax),%esi
   1393c:	89 71 0c             	mov    %esi,0xc(%ecx)
	b->bh.bsize += bn->bh.bsize;
   1393f:	8b 40 04             	mov    0x4(%eax),%eax
   13942:	03 42 04             	add    0x4(%edx),%eax
   13945:	89 42 04             	mov    %eax,0x4(%edx)
	   head  of  the  consolidated free block.  We know the next block
	   must be an allocated block because the process of recombination
	   guarantees  that  two  free	blocks will never be contiguous in
	   memory.  */

	bn = BFH(((char *) b) + b->bh.bsize);
   13948:	01 d0                	add    %edx,%eax
    }
#ifdef FreeWipe
    V memset(((char *) b) + sizeof(struct bfhead), 0x55,
	    (MemSize) (b->bh.bsize - sizeof(struct bfhead)));
#endif
    assert(bn->bh.bsize < 0);
   1394a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   1394e:	79 0b                	jns    1395b <brel+0x351>

    /* The next buffer is allocated.  Set the backpointer in it  to  point
       to this buffer; the previous free buffer in memory. */

    bn->bh.prevfree = b->bh.bsize;
   13950:	8b 52 04             	mov    0x4(%edx),%edx
   13953:	89 10                	mov    %edx,(%eax)
	numpblk--;		      /* Total number of blocks */
	assert(numpblk == numpget - numprel);
#endif /* BufStats */
    }
#endif /* BECtl */
}
   13955:	83 c4 04             	add    $0x4,%esp
   13958:	5b                   	pop    %ebx
   13959:	5e                   	pop    %esi
   1395a:	c3                   	ret    
    assert(bn->bh.bsize < 0);
   1395b:	83 ec 0c             	sub    $0xc,%esp
   1395e:	6a 4f                	push   $0x4f
   13960:	e8 c4 d7 ff ff       	call   11129 <Set_Current_Attr>
   13965:	83 c4 0c             	add    $0xc,%esp
   13968:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1396e:	ff 30                	pushl  (%eax)
   13970:	ff 74 24 14          	pushl  0x14(%esp)
   13974:	68 aa 03 00 00       	push   $0x3aa
   13979:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   1397f:	50                   	push   %eax
   13980:	8d 83 d3 7b ff ff    	lea    -0x842d(%ebx),%eax
   13986:	50                   	push   %eax
   13987:	8d 83 98 7d ff ff    	lea    -0x8268(%ebx),%eax
   1398d:	50                   	push   %eax
   1398e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13994:	50                   	push   %eax
   13995:	e8 40 d6 ff ff       	call   10fda <Print>
   1399a:	83 c4 20             	add    $0x20,%esp
   1399d:	eb fe                	jmp    1399d <brel+0x393>

0001399f <bgetr>:
{
   1399f:	55                   	push   %ebp
   139a0:	57                   	push   %edi
   139a1:	56                   	push   %esi
   139a2:	53                   	push   %ebx
   139a3:	83 ec 18             	sub    $0x18,%esp
   139a6:	e8 67 c8 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   139ab:	81 c3 55 26 01 00    	add    $0x12655,%ebx
   139b1:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
   139b5:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    if ((nbuf = bget(size)) == NULL) { /* Acquire new buffer */
   139b9:	55                   	push   %ebp
   139ba:	e8 5d f9 ff ff       	call   1331c <bget>
   139bf:	89 c6                	mov    %eax,%esi
   139c1:	83 c4 10             	add    $0x10,%esp
   139c4:	85 c0                	test   %eax,%eax
   139c6:	74 2b                	je     139f3 <bgetr+0x54>
    if (buf == NULL) {
   139c8:	85 ff                	test   %edi,%edi
   139ca:	74 27                	je     139f3 <bgetr+0x54>
	osize -= sizeof(struct bhead);
   139cc:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   139d1:	2b 47 fc             	sub    -0x4(%edi),%eax
    assert(osize > 0);
   139d4:	85 c0                	test   %eax,%eax
   139d6:	7e 25                	jle    139fd <bgetr+0x5e>
	     (MemSize) ((size < osize) ? size : osize));
   139d8:	39 c5                	cmp    %eax,%ebp
   139da:	0f 4e c5             	cmovle %ebp,%eax
    V memcpy((char *) nbuf, (char *) buf, /* Copy the data */
   139dd:	83 ec 04             	sub    $0x4,%esp
   139e0:	50                   	push   %eax
   139e1:	57                   	push   %edi
   139e2:	56                   	push   %esi
   139e3:	e8 96 90 00 00       	call   1ca7e <memcpy>
    brel(buf);
   139e8:	89 3c 24             	mov    %edi,(%esp)
   139eb:	e8 1a fc ff ff       	call   1360a <brel>
    return nbuf;
   139f0:	83 c4 10             	add    $0x10,%esp
}
   139f3:	89 f0                	mov    %esi,%eax
   139f5:	83 c4 0c             	add    $0xc,%esp
   139f8:	5b                   	pop    %ebx
   139f9:	5e                   	pop    %esi
   139fa:	5f                   	pop    %edi
   139fb:	5d                   	pop    %ebp
   139fc:	c3                   	ret    
    assert(osize > 0);
   139fd:	83 ec 0c             	sub    $0xc,%esp
   13a00:	6a 4f                	push   $0x4f
   13a02:	e8 22 d7 ff ff       	call   11129 <Set_Current_Attr>
   13a07:	83 c4 0c             	add    $0xc,%esp
   13a0a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13a10:	ff 30                	pushl  (%eax)
   13a12:	ff 74 24 24          	pushl  0x24(%esp)
   13a16:	68 32 03 00 00       	push   $0x332
   13a1b:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13a21:	50                   	push   %eax
   13a22:	8d 83 e4 7b ff ff    	lea    -0x841c(%ebx),%eax
   13a28:	50                   	push   %eax
   13a29:	8d 83 a0 7d ff ff    	lea    -0x8260(%ebx),%eax
   13a2f:	50                   	push   %eax
   13a30:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13a36:	50                   	push   %eax
   13a37:	e8 9e d5 ff ff       	call   10fda <Print>
   13a3c:	83 c4 20             	add    $0x20,%esp
   13a3f:	eb fe                	jmp    13a3f <bgetr+0xa0>

00013a41 <bpool>:
/*  BPOOL  --  Add a region of memory to the buffer pool.  */

void bpool(buf, len)
  void *buf;
  bufsize len;
{
   13a41:	56                   	push   %esi
   13a42:	53                   	push   %ebx
   13a43:	83 ec 04             	sub    $0x4,%esp
   13a46:	e8 c7 c7 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13a4b:	81 c3 b5 25 01 00    	add    $0x125b5,%ebx
   13a51:	8b 44 24 10          	mov    0x10(%esp),%eax
    struct bfhead *b = BFH(buf);
    struct bhead *bn;

#ifdef SizeQuant
    len &= ~(SizeQuant - 1);
   13a55:	8b 54 24 14          	mov    0x14(%esp),%edx
   13a59:	83 e2 fc             	and    $0xfffffffc,%edx

    /* Since the block is initially occupied by a single free  buffer,
       it  had	better	not  be  (much) larger than the largest buffer
       whose size we can store in bhead.bsize. */

    assert(len - sizeof(struct bhead) <= -((bufsize) ESent + 1));
   13a5c:	83 ea 08             	sub    $0x8,%edx
   13a5f:	78 5f                	js     13ac0 <bpool+0x7f>

    /* Clear  the  backpointer at  the start of the block to indicate that
       there  is  no  free  block  prior  to  this   one.    That   blocks
       recombination when the first block in memory is released. */

    b->bh.prevfree = 0;
   13a61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* Chain the new block to the free list. */

    assert(freelist.ql.blink->ql.flink == &freelist);
   13a67:	8b b3 3c 00 00 00    	mov    0x3c(%ebx),%esi
   13a6d:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   13a73:	39 4e 08             	cmp    %ecx,0x8(%esi)
   13a76:	0f 84 88 00 00 00    	je     13b04 <bpool+0xc3>
   13a7c:	83 ec 0c             	sub    $0xc,%esp
   13a7f:	6a 4f                	push   $0x4f
   13a81:	e8 a3 d6 ff ff       	call   11129 <Set_Current_Attr>
   13a86:	83 c4 0c             	add    $0xc,%esp
   13a89:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13a8f:	ff 30                	pushl  (%eax)
   13a91:	ff 74 24 14          	pushl  0x14(%esp)
   13a95:	68 04 04 00 00       	push   $0x404
   13a9a:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13aa0:	50                   	push   %eax
   13aa1:	8d 83 7c 7c ff ff    	lea    -0x8384(%ebx),%eax
   13aa7:	50                   	push   %eax
   13aa8:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
   13aae:	50                   	push   %eax
   13aaf:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13ab5:	50                   	push   %eax
   13ab6:	e8 1f d5 ff ff       	call   10fda <Print>
   13abb:	83 c4 20             	add    $0x20,%esp
   13abe:	eb fe                	jmp    13abe <bpool+0x7d>
    assert(len - sizeof(struct bhead) <= -((bufsize) ESent + 1));
   13ac0:	83 ec 0c             	sub    $0xc,%esp
   13ac3:	6a 4f                	push   $0x4f
   13ac5:	e8 5f d6 ff ff       	call   11129 <Set_Current_Attr>
   13aca:	83 c4 0c             	add    $0xc,%esp
   13acd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13ad3:	ff 30                	pushl  (%eax)
   13ad5:	ff 74 24 14          	pushl  0x14(%esp)
   13ad9:	68 fa 03 00 00       	push   $0x3fa
   13ade:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13ae4:	50                   	push   %eax
   13ae5:	8d 83 20 7d ff ff    	lea    -0x82e0(%ebx),%eax
   13aeb:	50                   	push   %eax
   13aec:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
   13af2:	50                   	push   %eax
   13af3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13af9:	50                   	push   %eax
   13afa:	e8 db d4 ff ff       	call   10fda <Print>
   13aff:	83 c4 20             	add    $0x20,%esp
   13b02:	eb fe                	jmp    13b02 <bpool+0xc1>
    assert(freelist.ql.flink->ql.blink == &freelist);
   13b04:	8b b3 38 00 00 00    	mov    0x38(%ebx),%esi
   13b0a:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   13b10:	39 4e 0c             	cmp    %ecx,0xc(%esi)
   13b13:	74 44                	je     13b59 <bpool+0x118>
   13b15:	83 ec 0c             	sub    $0xc,%esp
   13b18:	6a 4f                	push   $0x4f
   13b1a:	e8 0a d6 ff ff       	call   11129 <Set_Current_Attr>
   13b1f:	83 c4 0c             	add    $0xc,%esp
   13b22:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13b28:	ff 30                	pushl  (%eax)
   13b2a:	ff 74 24 14          	pushl  0x14(%esp)
   13b2e:	68 05 04 00 00       	push   $0x405
   13b33:	8d 83 e5 7a ff ff    	lea    -0x851b(%ebx),%eax
   13b39:	50                   	push   %eax
   13b3a:	8d 83 a8 7c ff ff    	lea    -0x8358(%ebx),%eax
   13b40:	50                   	push   %eax
   13b41:	8d 83 90 7d ff ff    	lea    -0x8270(%ebx),%eax
   13b47:	50                   	push   %eax
   13b48:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13b4e:	50                   	push   %eax
   13b4f:	e8 86 d4 ff ff       	call   10fda <Print>
   13b54:	83 c4 20             	add    $0x20,%esp
   13b57:	eb fe                	jmp    13b57 <bpool+0x116>
    b->ql.flink = &freelist;
   13b59:	8d 8b 30 00 00 00    	lea    0x30(%ebx),%ecx
   13b5f:	89 48 08             	mov    %ecx,0x8(%eax)
    b->ql.blink = freelist.ql.blink;
   13b62:	8b 8b 3c 00 00 00    	mov    0x3c(%ebx),%ecx
   13b68:	89 48 0c             	mov    %ecx,0xc(%eax)
    freelist.ql.blink = b;
   13b6b:	89 83 3c 00 00 00    	mov    %eax,0x3c(%ebx)
    b->ql.blink->ql.flink = b;
   13b71:	8b 48 0c             	mov    0xc(%eax),%ecx
   13b74:	89 41 08             	mov    %eax,0x8(%ecx)
       negative  number  to  denote  the  end  of  the pool for diagnostic
       routines (this specific value is  not  counted  on  by  the  actual
       allocation and release functions). */

    len -= sizeof(struct bhead);
    b->bh.bsize = (bufsize) len;
   13b77:	89 50 04             	mov    %edx,0x4(%eax)
#ifdef FreeWipe
    V memset(((char *) b) + sizeof(struct bfhead), 0x55,
	     (MemSize) (len - sizeof(struct bfhead)));
#endif
    bn = BH(((char *) b) + len);
   13b7a:	01 d0                	add    %edx,%eax
    bn->prevfree = (bufsize) len;
   13b7c:	89 10                	mov    %edx,(%eax)
    /* Definition of ESent assumes two's complement! */
    assert((~0) == -1);
    bn->bsize = ESent;
   13b7e:	c7 40 04 00 00 00 80 	movl   $0x80000000,0x4(%eax)
}
   13b85:	83 c4 04             	add    $0x4,%esp
   13b88:	5b                   	pop    %ebx
   13b89:	5e                   	pop    %esi
   13b8a:	c3                   	ret    

00013b8b <Init_Heap>:
/*
 * Initialize the heap starting at given address and occupying
 * specified number of bytes.
 */
void Init_Heap(ulong_t start, ulong_t size)
{
   13b8b:	53                   	push   %ebx
   13b8c:	83 ec 10             	sub    $0x10,%esp
   13b8f:	e8 7e c6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13b94:	81 c3 6c 24 01 00    	add    $0x1246c,%ebx
    /*Print("Creating kernel heap: start=%lx, size=%ld\n", start, size);*/
    bpool((void*) start, size);
   13b9a:	ff 74 24 1c          	pushl  0x1c(%esp)
   13b9e:	ff 74 24 1c          	pushl  0x1c(%esp)
   13ba2:	e8 9a fe ff ff       	call   13a41 <bpool>
}
   13ba7:	83 c4 18             	add    $0x18,%esp
   13baa:	5b                   	pop    %ebx
   13bab:	c3                   	ret    

00013bac <Malloc>:
 * Dynamically allocate a buffer of given size.
 * Returns null if there is not enough memory to satisfy the
 * allocation.
 */
void* Malloc(ulong_t size)
{
   13bac:	56                   	push   %esi
   13bad:	53                   	push   %ebx
   13bae:	83 ec 04             	sub    $0x4,%esp
   13bb1:	e8 5c c6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13bb6:	81 c3 4a 24 01 00    	add    $0x1244a,%ebx
   13bbc:	8b 74 24 10          	mov    0x10(%esp),%esi
    void *result;
    bool iflag;

    KASSERT(size > 0);
   13bc0:	85 f6                	test   %esi,%esi
   13bc2:	75 41                	jne    13c05 <Malloc+0x59>
   13bc4:	83 ec 0c             	sub    $0xc,%esp
   13bc7:	6a 4f                	push   $0x4f
   13bc9:	e8 5b d5 ff ff       	call   11129 <Set_Current_Attr>
   13bce:	83 c4 0c             	add    $0xc,%esp
   13bd1:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13bd7:	ff 30                	pushl  (%eax)
   13bd9:	ff 74 24 14          	pushl  0x14(%esp)
   13bdd:	6a 24                	push   $0x24
   13bdf:	8d 83 b5 7d ff ff    	lea    -0x824b(%ebx),%eax
   13be5:	50                   	push   %eax
   13be6:	8d 83 e5 7b ff ff    	lea    -0x841b(%ebx),%eax
   13bec:	50                   	push   %eax
   13bed:	8d 83 f0 7d ff ff    	lea    -0x8210(%ebx),%eax
   13bf3:	50                   	push   %eax
   13bf4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13bfa:	50                   	push   %eax
   13bfb:	e8 da d3 ff ff       	call   10fda <Print>
   13c00:	83 c4 20             	add    $0x20,%esp
   13c03:	eb fe                	jmp    13c03 <Malloc+0x57>
    bool enabled = Interrupts_Enabled();
   13c05:	e8 42 c6 ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   13c0a:	84 c0                	test   %al,%al
   13c0c:	75 1f                	jne    13c2d <Malloc+0x81>

    iflag = Begin_Int_Atomic();
    result = bget(size);
   13c0e:	83 ec 0c             	sub    $0xc,%esp
   13c11:	56                   	push   %esi
   13c12:	e8 05 f7 ff ff       	call   1331c <bget>
   13c17:	89 c6                	mov    %eax,%esi
    KASSERT(!Interrupts_Enabled());
   13c19:	e8 2e c6 ff ff       	call   1024c <Interrupts_Enabled>
   13c1e:	83 c4 10             	add    $0x10,%esp
   13c21:	84 c0                	test   %al,%al
   13c23:	75 7d                	jne    13ca2 <Malloc+0xf6>
    End_Int_Atomic(iflag);

    return result;
}
   13c25:	89 f0                	mov    %esi,%eax
   13c27:	83 c4 04             	add    $0x4,%esp
   13c2a:	5b                   	pop    %ebx
   13c2b:	5e                   	pop    %esi
   13c2c:	c3                   	ret    
	Disable_Interrupts();
   13c2d:	e8 1a c6 ff ff       	call   1024c <Interrupts_Enabled>
   13c32:	84 c0                	test   %al,%al
   13c34:	74 28                	je     13c5e <Malloc+0xb2>
    __asm__ __volatile__ ("cli");
   13c36:	fa                   	cli    
    result = bget(size);
   13c37:	83 ec 0c             	sub    $0xc,%esp
   13c3a:	56                   	push   %esi
   13c3b:	e8 dc f6 ff ff       	call   1331c <bget>
   13c40:	89 c6                	mov    %eax,%esi
    KASSERT(!Interrupts_Enabled());
   13c42:	e8 05 c6 ff ff       	call   1024c <Interrupts_Enabled>
   13c47:	83 c4 10             	add    $0x10,%esp
   13c4a:	84 c0                	test   %al,%al
   13c4c:	75 54                	jne    13ca2 <Malloc+0xf6>
	Enable_Interrupts();
   13c4e:	e8 f9 c5 ff ff       	call   1024c <Interrupts_Enabled>
   13c53:	84 c0                	test   %al,%al
   13c55:	0f 85 8b 00 00 00    	jne    13ce6 <Malloc+0x13a>
    __asm__ __volatile__ ("sti");
   13c5b:	fb                   	sti    
    return result;
   13c5c:	eb c7                	jmp    13c25 <Malloc+0x79>
	Disable_Interrupts();
   13c5e:	83 ec 0c             	sub    $0xc,%esp
   13c61:	6a 4f                	push   $0x4f
   13c63:	e8 c1 d4 ff ff       	call   11129 <Set_Current_Attr>
   13c68:	83 c4 0c             	add    $0xc,%esp
   13c6b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13c71:	ff 30                	pushl  (%eax)
   13c73:	ff 74 24 14          	pushl  0x14(%esp)
   13c77:	68 8f 00 00 00       	push   $0x8f
   13c7c:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13c82:	50                   	push   %eax
   13c83:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   13c89:	50                   	push   %eax
   13c8a:	8d 83 dc 7d ff ff    	lea    -0x8224(%ebx),%eax
   13c90:	50                   	push   %eax
   13c91:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13c97:	50                   	push   %eax
   13c98:	e8 3d d3 ff ff       	call   10fda <Print>
   13c9d:	83 c4 20             	add    $0x20,%esp
   13ca0:	eb fe                	jmp    13ca0 <Malloc+0xf4>
    KASSERT(!Interrupts_Enabled());
   13ca2:	83 ec 0c             	sub    $0xc,%esp
   13ca5:	6a 4f                	push   $0x4f
   13ca7:	e8 7d d4 ff ff       	call   11129 <Set_Current_Attr>
   13cac:	83 c4 0c             	add    $0xc,%esp
   13caf:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13cb5:	ff 30                	pushl  (%eax)
   13cb7:	ff 74 24 14          	pushl  0x14(%esp)
   13cbb:	68 99 00 00 00       	push   $0x99
   13cc0:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13cc6:	50                   	push   %eax
   13cc7:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   13ccd:	50                   	push   %eax
   13cce:	8d 83 cc 7d ff ff    	lea    -0x8234(%ebx),%eax
   13cd4:	50                   	push   %eax
   13cd5:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13cdb:	50                   	push   %eax
   13cdc:	e8 f9 d2 ff ff       	call   10fda <Print>
   13ce1:	83 c4 20             	add    $0x20,%esp
   13ce4:	eb fe                	jmp    13ce4 <Malloc+0x138>
	Enable_Interrupts();
   13ce6:	83 ec 0c             	sub    $0xc,%esp
   13ce9:	6a 4f                	push   $0x4f
   13ceb:	e8 39 d4 ff ff       	call   11129 <Set_Current_Attr>
   13cf0:	83 c4 0c             	add    $0xc,%esp
   13cf3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13cf9:	ff 30                	pushl  (%eax)
   13cfb:	ff 74 24 14          	pushl  0x14(%esp)
   13cff:	68 9c 00 00 00       	push   $0x9c
   13d04:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13d0a:	50                   	push   %eax
   13d0b:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   13d11:	50                   	push   %eax
   13d12:	8d 83 cc 7d ff ff    	lea    -0x8234(%ebx),%eax
   13d18:	50                   	push   %eax
   13d19:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13d1f:	50                   	push   %eax
   13d20:	e8 b5 d2 ff ff       	call   10fda <Print>
   13d25:	83 c4 20             	add    $0x20,%esp
   13d28:	eb fe                	jmp    13d28 <Malloc+0x17c>

00013d2a <Free>:

/*
 * Free a buffer allocated with Malloc() or Malloc().
 */
void Free(void* buf)
{
   13d2a:	53                   	push   %ebx
   13d2b:	83 ec 08             	sub    $0x8,%esp
   13d2e:	e8 df c4 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13d33:	81 c3 cd 22 01 00    	add    $0x122cd,%ebx
    bool enabled = Interrupts_Enabled();
   13d39:	e8 0e c5 ff ff       	call   1024c <Interrupts_Enabled>
    if (enabled)
   13d3e:	84 c0                	test   %al,%al
   13d40:	75 1d                	jne    13d5f <Free+0x35>
    bool iflag;

    iflag = Begin_Int_Atomic();
    brel(buf);
   13d42:	83 ec 0c             	sub    $0xc,%esp
   13d45:	ff 74 24 1c          	pushl  0x1c(%esp)
   13d49:	e8 bc f8 ff ff       	call   1360a <brel>
    KASSERT(!Interrupts_Enabled());
   13d4e:	e8 f9 c4 ff ff       	call   1024c <Interrupts_Enabled>
   13d53:	83 c4 10             	add    $0x10,%esp
   13d56:	84 c0                	test   %al,%al
   13d58:	75 7b                	jne    13dd5 <Free+0xab>
    End_Int_Atomic(iflag);
}
   13d5a:	83 c4 08             	add    $0x8,%esp
   13d5d:	5b                   	pop    %ebx
   13d5e:	c3                   	ret    
	Disable_Interrupts();
   13d5f:	e8 e8 c4 ff ff       	call   1024c <Interrupts_Enabled>
   13d64:	84 c0                	test   %al,%al
   13d66:	74 29                	je     13d91 <Free+0x67>
    __asm__ __volatile__ ("cli");
   13d68:	fa                   	cli    
    brel(buf);
   13d69:	83 ec 0c             	sub    $0xc,%esp
   13d6c:	ff 74 24 1c          	pushl  0x1c(%esp)
   13d70:	e8 95 f8 ff ff       	call   1360a <brel>
    KASSERT(!Interrupts_Enabled());
   13d75:	e8 d2 c4 ff ff       	call   1024c <Interrupts_Enabled>
   13d7a:	83 c4 10             	add    $0x10,%esp
   13d7d:	84 c0                	test   %al,%al
   13d7f:	75 54                	jne    13dd5 <Free+0xab>
	Enable_Interrupts();
   13d81:	e8 c6 c4 ff ff       	call   1024c <Interrupts_Enabled>
   13d86:	84 c0                	test   %al,%al
   13d88:	0f 85 8b 00 00 00    	jne    13e19 <Free+0xef>
    __asm__ __volatile__ ("sti");
   13d8e:	fb                   	sti    
}
   13d8f:	eb c9                	jmp    13d5a <Free+0x30>
	Disable_Interrupts();
   13d91:	83 ec 0c             	sub    $0xc,%esp
   13d94:	6a 4f                	push   $0x4f
   13d96:	e8 8e d3 ff ff       	call   11129 <Set_Current_Attr>
   13d9b:	83 c4 0c             	add    $0xc,%esp
   13d9e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13da4:	ff 30                	pushl  (%eax)
   13da6:	ff 74 24 14          	pushl  0x14(%esp)
   13daa:	68 8f 00 00 00       	push   $0x8f
   13daf:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13db5:	50                   	push   %eax
   13db6:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   13dbc:	50                   	push   %eax
   13dbd:	8d 83 dc 7d ff ff    	lea    -0x8224(%ebx),%eax
   13dc3:	50                   	push   %eax
   13dc4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13dca:	50                   	push   %eax
   13dcb:	e8 0a d2 ff ff       	call   10fda <Print>
   13dd0:	83 c4 20             	add    $0x20,%esp
   13dd3:	eb fe                	jmp    13dd3 <Free+0xa9>
    KASSERT(!Interrupts_Enabled());
   13dd5:	83 ec 0c             	sub    $0xc,%esp
   13dd8:	6a 4f                	push   $0x4f
   13dda:	e8 4a d3 ff ff       	call   11129 <Set_Current_Attr>
   13ddf:	83 c4 0c             	add    $0xc,%esp
   13de2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13de8:	ff 30                	pushl  (%eax)
   13dea:	ff 74 24 14          	pushl  0x14(%esp)
   13dee:	68 99 00 00 00       	push   $0x99
   13df3:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13df9:	50                   	push   %eax
   13dfa:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   13e00:	50                   	push   %eax
   13e01:	8d 83 cc 7d ff ff    	lea    -0x8234(%ebx),%eax
   13e07:	50                   	push   %eax
   13e08:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13e0e:	50                   	push   %eax
   13e0f:	e8 c6 d1 ff ff       	call   10fda <Print>
   13e14:	83 c4 20             	add    $0x20,%esp
   13e17:	eb fe                	jmp    13e17 <Free+0xed>
	Enable_Interrupts();
   13e19:	83 ec 0c             	sub    $0xc,%esp
   13e1c:	6a 4f                	push   $0x4f
   13e1e:	e8 06 d3 ff ff       	call   11129 <Set_Current_Attr>
   13e23:	83 c4 0c             	add    $0xc,%esp
   13e26:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13e2c:	ff 30                	pushl  (%eax)
   13e2e:	ff 74 24 14          	pushl  0x14(%esp)
   13e32:	68 9c 00 00 00       	push   $0x9c
   13e37:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   13e3d:	50                   	push   %eax
   13e3e:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   13e44:	50                   	push   %eax
   13e45:	8d 83 cc 7d ff ff    	lea    -0x8234(%ebx),%eax
   13e4b:	50                   	push   %eax
   13e4c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13e52:	50                   	push   %eax
   13e53:	e8 82 d1 ff ff       	call   10fda <Print>
   13e58:	83 c4 20             	add    $0x20,%esp
   13e5b:	eb fe                	jmp    13e5b <Free+0x131>

00013e5d <Mutex_Wait>:
 * The mutex is currently locked.
 * Atomically reenable preemption and wait in the
 * mutex's wait queue.
 */
static void Mutex_Wait(struct Mutex *mutex)
{
   13e5d:	57                   	push   %edi
   13e5e:	56                   	push   %esi
   13e5f:	53                   	push   %ebx
   13e60:	e8 ad c3 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13e65:	81 c3 9b 21 01 00    	add    $0x1219b,%ebx
    KASSERT(mutex->state == MUTEX_LOCKED);
   13e6b:	83 38 01             	cmpl   $0x1,(%eax)
   13e6e:	75 53                	jne    13ec3 <Mutex_Wait+0x66>
   13e70:	89 c6                	mov    %eax,%esi
    KASSERT(g_preemptionDisabled);
   13e72:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   13e78:	8b 00                	mov    (%eax),%eax
   13e7a:	85 c0                	test   %eax,%eax
   13e7c:	0f 85 82 00 00 00    	jne    13f04 <Mutex_Wait+0xa7>
   13e82:	83 ec 0c             	sub    $0xc,%esp
   13e85:	6a 4f                	push   $0x4f
   13e87:	e8 9d d2 ff ff       	call   11129 <Set_Current_Attr>
   13e8c:	83 c4 0c             	add    $0xc,%esp
   13e8f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13e95:	ff 30                	pushl  (%eax)
   13e97:	ff 74 24 14          	pushl  0x14(%esp)
   13e9b:	6a 26                	push   $0x26
   13e9d:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   13ea3:	50                   	push   %eax
   13ea4:	8d 83 ee 7e ff ff    	lea    -0x8112(%ebx),%eax
   13eaa:	50                   	push   %eax
   13eab:	8d 83 88 7e ff ff    	lea    -0x8178(%ebx),%eax
   13eb1:	50                   	push   %eax
   13eb2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13eb8:	50                   	push   %eax
   13eb9:	e8 1c d1 ff ff       	call   10fda <Print>
   13ebe:	83 c4 20             	add    $0x20,%esp
   13ec1:	eb fe                	jmp    13ec1 <Mutex_Wait+0x64>
    KASSERT(mutex->state == MUTEX_LOCKED);
   13ec3:	83 ec 0c             	sub    $0xc,%esp
   13ec6:	6a 4f                	push   $0x4f
   13ec8:	e8 5c d2 ff ff       	call   11129 <Set_Current_Attr>
   13ecd:	83 c4 0c             	add    $0xc,%esp
   13ed0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13ed6:	ff 30                	pushl  (%eax)
   13ed8:	ff 74 24 14          	pushl  0x14(%esp)
   13edc:	6a 25                	push   $0x25
   13ede:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   13ee4:	50                   	push   %eax
   13ee5:	8d 83 0d 7e ff ff    	lea    -0x81f3(%ebx),%eax
   13eeb:	50                   	push   %eax
   13eec:	8d 83 88 7e ff ff    	lea    -0x8178(%ebx),%eax
   13ef2:	50                   	push   %eax
   13ef3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13ef9:	50                   	push   %eax
   13efa:	e8 db d0 ff ff       	call   10fda <Print>
   13eff:	83 c4 20             	add    $0x20,%esp
   13f02:	eb fe                	jmp    13f02 <Mutex_Wait+0xa5>

    Disable_Interrupts();
   13f04:	e8 43 c3 ff ff       	call   1024c <Interrupts_Enabled>
   13f09:	84 c0                	test   %al,%al
   13f0b:	75 41                	jne    13f4e <Mutex_Wait+0xf1>
   13f0d:	83 ec 0c             	sub    $0xc,%esp
   13f10:	6a 4f                	push   $0x4f
   13f12:	e8 12 d2 ff ff       	call   11129 <Set_Current_Attr>
   13f17:	83 c4 0c             	add    $0xc,%esp
   13f1a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13f20:	ff 30                	pushl  (%eax)
   13f22:	ff 74 24 14          	pushl  0x14(%esp)
   13f26:	6a 28                	push   $0x28
   13f28:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   13f2e:	50                   	push   %eax
   13f2f:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   13f35:	50                   	push   %eax
   13f36:	8d 83 88 7e ff ff    	lea    -0x8178(%ebx),%eax
   13f3c:	50                   	push   %eax
   13f3d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13f43:	50                   	push   %eax
   13f44:	e8 91 d0 ff ff       	call   10fda <Print>
   13f49:	83 c4 20             	add    $0x20,%esp
   13f4c:	eb fe                	jmp    13f4c <Mutex_Wait+0xef>
    __asm__ __volatile__ ("cli");
   13f4e:	fa                   	cli    
    g_preemptionDisabled = false;
   13f4f:	c7 c7 8c 77 02 00    	mov    $0x2778c,%edi
   13f55:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    Wait(&mutex->waitQueue);
   13f5b:	83 ec 0c             	sub    $0xc,%esp
   13f5e:	83 c6 08             	add    $0x8,%esi
   13f61:	56                   	push   %esi
   13f62:	e8 f0 14 00 00       	call   15457 <Wait>
    g_preemptionDisabled = true;
   13f67:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
    Enable_Interrupts();
   13f6d:	e8 da c2 ff ff       	call   1024c <Interrupts_Enabled>
   13f72:	83 c4 10             	add    $0x10,%esp
   13f75:	84 c0                	test   %al,%al
   13f77:	75 05                	jne    13f7e <Mutex_Wait+0x121>
    __asm__ __volatile__ ("sti");
   13f79:	fb                   	sti    
}
   13f7a:	5b                   	pop    %ebx
   13f7b:	5e                   	pop    %esi
   13f7c:	5f                   	pop    %edi
   13f7d:	c3                   	ret    
    Enable_Interrupts();
   13f7e:	83 ec 0c             	sub    $0xc,%esp
   13f81:	6a 4f                	push   $0x4f
   13f83:	e8 a1 d1 ff ff       	call   11129 <Set_Current_Attr>
   13f88:	83 c4 0c             	add    $0xc,%esp
   13f8b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   13f91:	ff 30                	pushl  (%eax)
   13f93:	ff 74 24 14          	pushl  0x14(%esp)
   13f97:	6a 2c                	push   $0x2c
   13f99:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   13f9f:	50                   	push   %eax
   13fa0:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   13fa6:	50                   	push   %eax
   13fa7:	8d 83 88 7e ff ff    	lea    -0x8178(%ebx),%eax
   13fad:	50                   	push   %eax
   13fae:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   13fb4:	50                   	push   %eax
   13fb5:	e8 20 d0 ff ff       	call   10fda <Print>
   13fba:	83 c4 20             	add    $0x20,%esp
   13fbd:	eb fe                	jmp    13fbd <Mutex_Wait+0x160>

00013fbf <Mutex_Init>:

/*
 * Initialize given mutex.
 */
void Mutex_Init(struct Mutex* mutex)
{
   13fbf:	8b 44 24 04          	mov    0x4(%esp),%eax
    mutex->state = MUTEX_UNLOCKED;
   13fc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    mutex->owner = 0;
   13fc9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
};

/*
 * Define Thread_Queue and All_Thread_List access and manipulation functions.
 */
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   13fd0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   13fd7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    Clear_Thread_Queue(&mutex->waitQueue);
}
   13fde:	c3                   	ret    

00013fdf <Mutex_Lock>:

/*
 * Lock given mutex.
 */
void Mutex_Lock(struct Mutex* mutex)
{
   13fdf:	56                   	push   %esi
   13fe0:	53                   	push   %ebx
   13fe1:	83 ec 04             	sub    $0x4,%esp
   13fe4:	e8 29 c2 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   13fe9:	81 c3 17 20 01 00    	add    $0x12017,%ebx
   13fef:	8b 74 24 10          	mov    0x10(%esp),%esi
    KASSERT(Interrupts_Enabled());
   13ff3:	e8 54 c2 ff ff       	call   1024c <Interrupts_Enabled>
   13ff8:	84 c0                	test   %al,%al
   13ffa:	75 41                	jne    1403d <Mutex_Lock+0x5e>
   13ffc:	83 ec 0c             	sub    $0xc,%esp
   13fff:	6a 4f                	push   $0x4f
   14001:	e8 23 d1 ff ff       	call   11129 <Set_Current_Attr>
   14006:	83 c4 0c             	add    $0xc,%esp
   14009:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1400f:	ff 30                	pushl  (%eax)
   14011:	ff 74 24 14          	pushl  0x14(%esp)
   14015:	6a 74                	push   $0x74
   14017:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   1401d:	50                   	push   %eax
   1401e:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14024:	50                   	push   %eax
   14025:	8d 83 a4 7e ff ff    	lea    -0x815c(%ebx),%eax
   1402b:	50                   	push   %eax
   1402c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14032:	50                   	push   %eax
   14033:	e8 a2 cf ff ff       	call   10fda <Print>
   14038:	83 c4 20             	add    $0x20,%esp
   1403b:	eb fe                	jmp    1403b <Mutex_Lock+0x5c>

    g_preemptionDisabled = true;
   1403d:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   14043:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    KASSERT(g_preemptionDisabled);
   14049:	8b 00                	mov    (%eax),%eax
   1404b:	85 c0                	test   %eax,%eax
   1404d:	74 41                	je     14090 <Mutex_Lock+0xb1>
    KASSERT(!IS_HELD(mutex));
   1404f:	83 3e 01             	cmpl   $0x1,(%esi)
   14052:	75 19                	jne    1406d <Mutex_Lock+0x8e>
   14054:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1405a:	8b 00                	mov    (%eax),%eax
   1405c:	39 46 04             	cmp    %eax,0x4(%esi)
   1405f:	74 70                	je     140d1 <Mutex_Lock+0xf2>
	Mutex_Wait(mutex);
   14061:	89 f0                	mov    %esi,%eax
   14063:	e8 f5 fd ff ff       	call   13e5d <Mutex_Wait>
    while (mutex->state == MUTEX_LOCKED) {
   14068:	83 3e 01             	cmpl   $0x1,(%esi)
   1406b:	74 f4                	je     14061 <Mutex_Lock+0x82>
    mutex->state = MUTEX_LOCKED;
   1406d:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    mutex->owner = g_currentThread;
   14073:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14079:	8b 00                	mov    (%eax),%eax
   1407b:	89 46 04             	mov    %eax,0x4(%esi)
    Mutex_Lock_Imp(mutex);
    g_preemptionDisabled = false;
   1407e:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   14084:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   1408a:	83 c4 04             	add    $0x4,%esp
   1408d:	5b                   	pop    %ebx
   1408e:	5e                   	pop    %esi
   1408f:	c3                   	ret    
    KASSERT(g_preemptionDisabled);
   14090:	83 ec 0c             	sub    $0xc,%esp
   14093:	6a 4f                	push   $0x4f
   14095:	e8 8f d0 ff ff       	call   11129 <Set_Current_Attr>
   1409a:	83 c4 0c             	add    $0xc,%esp
   1409d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   140a3:	ff 30                	pushl  (%eax)
   140a5:	ff 74 24 14          	pushl  0x14(%esp)
   140a9:	6a 35                	push   $0x35
   140ab:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   140b1:	50                   	push   %eax
   140b2:	8d 83 ee 7e ff ff    	lea    -0x8112(%ebx),%eax
   140b8:	50                   	push   %eax
   140b9:	8d 83 94 7e ff ff    	lea    -0x816c(%ebx),%eax
   140bf:	50                   	push   %eax
   140c0:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   140c6:	50                   	push   %eax
   140c7:	e8 0e cf ff ff       	call   10fda <Print>
   140cc:	83 c4 20             	add    $0x20,%esp
   140cf:	eb fe                	jmp    140cf <Mutex_Lock+0xf0>
    KASSERT(!IS_HELD(mutex));
   140d1:	83 ec 0c             	sub    $0xc,%esp
   140d4:	6a 4f                	push   $0x4f
   140d6:	e8 4e d0 ff ff       	call   11129 <Set_Current_Attr>
   140db:	83 c4 0c             	add    $0xc,%esp
   140de:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   140e4:	ff 30                	pushl  (%eax)
   140e6:	ff 74 24 14          	pushl  0x14(%esp)
   140ea:	6a 38                	push   $0x38
   140ec:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   140f2:	50                   	push   %eax
   140f3:	8d 83 2a 7e ff ff    	lea    -0x81d6(%ebx),%eax
   140f9:	50                   	push   %eax
   140fa:	8d 83 94 7e ff ff    	lea    -0x816c(%ebx),%eax
   14100:	50                   	push   %eax
   14101:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14107:	50                   	push   %eax
   14108:	e8 cd ce ff ff       	call   10fda <Print>
   1410d:	83 c4 20             	add    $0x20,%esp
   14110:	eb fe                	jmp    14110 <Mutex_Lock+0x131>

00014112 <Mutex_Unlock>:

/*
 * Unlock given mutex.
 */
void Mutex_Unlock(struct Mutex* mutex)
{
   14112:	56                   	push   %esi
   14113:	53                   	push   %ebx
   14114:	83 ec 04             	sub    $0x4,%esp
   14117:	e8 f6 c0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1411c:	81 c3 e4 1e 01 00    	add    $0x11ee4,%ebx
   14122:	8b 74 24 10          	mov    0x10(%esp),%esi
    KASSERT(Interrupts_Enabled());
   14126:	e8 21 c1 ff ff       	call   1024c <Interrupts_Enabled>
   1412b:	84 c0                	test   %al,%al
   1412d:	75 44                	jne    14173 <Mutex_Unlock+0x61>
   1412f:	83 ec 0c             	sub    $0xc,%esp
   14132:	6a 4f                	push   $0x4f
   14134:	e8 f0 cf ff ff       	call   11129 <Set_Current_Attr>
   14139:	83 c4 0c             	add    $0xc,%esp
   1413c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14142:	ff 30                	pushl  (%eax)
   14144:	ff 74 24 14          	pushl  0x14(%esp)
   14148:	68 80 00 00 00       	push   $0x80
   1414d:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14153:	50                   	push   %eax
   14154:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1415a:	50                   	push   %eax
   1415b:	8d 83 78 7e ff ff    	lea    -0x8188(%ebx),%eax
   14161:	50                   	push   %eax
   14162:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14168:	50                   	push   %eax
   14169:	e8 6c ce ff ff       	call   10fda <Print>
   1416e:	83 c4 20             	add    $0x20,%esp
   14171:	eb fe                	jmp    14171 <Mutex_Unlock+0x5f>

    g_preemptionDisabled = true;
   14173:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   14179:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    KASSERT(g_preemptionDisabled);
   1417f:	8b 00                	mov    (%eax),%eax
   14181:	85 c0                	test   %eax,%eax
   14183:	74 57                	je     141dc <Mutex_Unlock+0xca>
    KASSERT(IS_HELD(mutex));
   14185:	83 3e 01             	cmpl   $0x1,(%esi)
   14188:	75 11                	jne    1419b <Mutex_Unlock+0x89>
   1418a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14190:	8b 00                	mov    (%eax),%eax
   14192:	39 46 04             	cmp    %eax,0x4(%esi)
   14195:	0f 84 82 00 00 00    	je     1421d <Mutex_Unlock+0x10b>
   1419b:	83 ec 0c             	sub    $0xc,%esp
   1419e:	6a 4f                	push   $0x4f
   141a0:	e8 84 cf ff ff       	call   11129 <Set_Current_Attr>
   141a5:	83 c4 0c             	add    $0xc,%esp
   141a8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   141ae:	ff 30                	pushl  (%eax)
   141b0:	ff 74 24 14          	pushl  0x14(%esp)
   141b4:	6a 4d                	push   $0x4d
   141b6:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   141bc:	50                   	push   %eax
   141bd:	8d 83 2b 7e ff ff    	lea    -0x81d5(%ebx),%eax
   141c3:	50                   	push   %eax
   141c4:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   141ca:	50                   	push   %eax
   141cb:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   141d1:	50                   	push   %eax
   141d2:	e8 03 ce ff ff       	call   10fda <Print>
   141d7:	83 c4 20             	add    $0x20,%esp
   141da:	eb fe                	jmp    141da <Mutex_Unlock+0xc8>
    KASSERT(g_preemptionDisabled);
   141dc:	83 ec 0c             	sub    $0xc,%esp
   141df:	6a 4f                	push   $0x4f
   141e1:	e8 43 cf ff ff       	call   11129 <Set_Current_Attr>
   141e6:	83 c4 0c             	add    $0xc,%esp
   141e9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   141ef:	ff 30                	pushl  (%eax)
   141f1:	ff 74 24 14          	pushl  0x14(%esp)
   141f5:	6a 4a                	push   $0x4a
   141f7:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   141fd:	50                   	push   %eax
   141fe:	8d 83 ee 7e ff ff    	lea    -0x8112(%ebx),%eax
   14204:	50                   	push   %eax
   14205:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   1420b:	50                   	push   %eax
   1420c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14212:	50                   	push   %eax
   14213:	e8 c2 cd ff ff       	call   10fda <Print>
   14218:	83 c4 20             	add    $0x20,%esp
   1421b:	eb fe                	jmp    1421b <Mutex_Unlock+0x109>
    mutex->state = MUTEX_UNLOCKED;
   1421d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    mutex->owner = 0;
   14223:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    if (!Is_Thread_Queue_Empty(&mutex->waitQueue)) {
   1422a:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
   1422e:	74 64                	je     14294 <Mutex_Unlock+0x182>
	Disable_Interrupts();
   14230:	e8 17 c0 ff ff       	call   1024c <Interrupts_Enabled>
   14235:	84 c0                	test   %al,%al
   14237:	75 41                	jne    1427a <Mutex_Unlock+0x168>
   14239:	83 ec 0c             	sub    $0xc,%esp
   1423c:	6a 4f                	push   $0x4f
   1423e:	e8 e6 ce ff ff       	call   11129 <Set_Current_Attr>
   14243:	83 c4 0c             	add    $0xc,%esp
   14246:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1424c:	ff 30                	pushl  (%eax)
   1424e:	ff 74 24 14          	pushl  0x14(%esp)
   14252:	6a 5b                	push   $0x5b
   14254:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   1425a:	50                   	push   %eax
   1425b:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14261:	50                   	push   %eax
   14262:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   14268:	50                   	push   %eax
   14269:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1426f:	50                   	push   %eax
   14270:	e8 65 cd ff ff       	call   10fda <Print>
   14275:	83 c4 20             	add    $0x20,%esp
   14278:	eb fe                	jmp    14278 <Mutex_Unlock+0x166>
    __asm__ __volatile__ ("cli");
   1427a:	fa                   	cli    
	Wake_Up_One(&mutex->waitQueue);
   1427b:	83 ec 0c             	sub    $0xc,%esp
   1427e:	83 c6 08             	add    $0x8,%esi
   14281:	56                   	push   %esi
   14282:	e8 4d 1b 00 00       	call   15dd4 <Wake_Up_One>
	Enable_Interrupts();
   14287:	e8 c0 bf ff ff       	call   1024c <Interrupts_Enabled>
   1428c:	83 c4 10             	add    $0x10,%esp
   1428f:	84 c0                	test   %al,%al
   14291:	75 13                	jne    142a6 <Mutex_Unlock+0x194>
    __asm__ __volatile__ ("sti");
   14293:	fb                   	sti    
    Mutex_Unlock_Imp(mutex);
    g_preemptionDisabled = false;
   14294:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   1429a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   142a0:	83 c4 04             	add    $0x4,%esp
   142a3:	5b                   	pop    %ebx
   142a4:	5e                   	pop    %esi
   142a5:	c3                   	ret    
	Enable_Interrupts();
   142a6:	83 ec 0c             	sub    $0xc,%esp
   142a9:	6a 4f                	push   $0x4f
   142ab:	e8 79 ce ff ff       	call   11129 <Set_Current_Attr>
   142b0:	83 c4 0c             	add    $0xc,%esp
   142b3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   142b9:	ff 30                	pushl  (%eax)
   142bb:	ff 74 24 14          	pushl  0x14(%esp)
   142bf:	6a 5d                	push   $0x5d
   142c1:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   142c7:	50                   	push   %eax
   142c8:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   142ce:	50                   	push   %eax
   142cf:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   142d5:	50                   	push   %eax
   142d6:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   142dc:	50                   	push   %eax
   142dd:	e8 f8 cc ff ff       	call   10fda <Print>
   142e2:	83 c4 20             	add    $0x20,%esp
   142e5:	eb fe                	jmp    142e5 <Mutex_Unlock+0x1d3>

000142e7 <Cond_Init>:

/*
 * Initialize given condition.
 */
void Cond_Init(struct Condition* cond)
{
   142e7:	8b 44 24 04          	mov    0x4(%esp),%eax
   142eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   142f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    Clear_Thread_Queue(&cond->waitQueue);
}
   142f8:	c3                   	ret    

000142f9 <Cond_Wait>:

/*
 * Wait on given condition (protected by given mutex).
 */
void Cond_Wait(struct Condition* cond, struct Mutex* mutex)
{
   142f9:	57                   	push   %edi
   142fa:	56                   	push   %esi
   142fb:	53                   	push   %ebx
   142fc:	e8 11 bf ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14301:	81 c3 ff 1c 01 00    	add    $0x11cff,%ebx
   14307:	8b 74 24 14          	mov    0x14(%esp),%esi
    KASSERT(Interrupts_Enabled());
   1430b:	e8 3c bf ff ff       	call   1024c <Interrupts_Enabled>
   14310:	84 c0                	test   %al,%al
   14312:	74 5a                	je     1436e <Cond_Wait+0x75>

    /* Ensure mutex is held. */
    KASSERT(IS_HELD(mutex));
   14314:	83 3e 01             	cmpl   $0x1,(%esi)
   14317:	75 11                	jne    1432a <Cond_Wait+0x31>
   14319:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1431f:	8b 00                	mov    (%eax),%eax
   14321:	39 46 04             	cmp    %eax,0x4(%esi)
   14324:	0f 84 88 00 00 00    	je     143b2 <Cond_Wait+0xb9>
   1432a:	83 ec 0c             	sub    $0xc,%esp
   1432d:	6a 4f                	push   $0x4f
   1432f:	e8 f5 cd ff ff       	call   11129 <Set_Current_Attr>
   14334:	83 c4 0c             	add    $0xc,%esp
   14337:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1433d:	ff 30                	pushl  (%eax)
   1433f:	ff 74 24 14          	pushl  0x14(%esp)
   14343:	68 97 00 00 00       	push   $0x97
   14348:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   1434e:	50                   	push   %eax
   1434f:	8d 83 2b 7e ff ff    	lea    -0x81d5(%ebx),%eax
   14355:	50                   	push   %eax
   14356:	8d 83 58 7e ff ff    	lea    -0x81a8(%ebx),%eax
   1435c:	50                   	push   %eax
   1435d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14363:	50                   	push   %eax
   14364:	e8 71 cc ff ff       	call   10fda <Print>
   14369:	83 c4 20             	add    $0x20,%esp
   1436c:	eb fe                	jmp    1436c <Cond_Wait+0x73>
    KASSERT(Interrupts_Enabled());
   1436e:	83 ec 0c             	sub    $0xc,%esp
   14371:	6a 4f                	push   $0x4f
   14373:	e8 b1 cd ff ff       	call   11129 <Set_Current_Attr>
   14378:	83 c4 0c             	add    $0xc,%esp
   1437b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14381:	ff 30                	pushl  (%eax)
   14383:	ff 74 24 14          	pushl  0x14(%esp)
   14387:	68 94 00 00 00       	push   $0x94
   1438c:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14392:	50                   	push   %eax
   14393:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14399:	50                   	push   %eax
   1439a:	8d 83 58 7e ff ff    	lea    -0x81a8(%ebx),%eax
   143a0:	50                   	push   %eax
   143a1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   143a7:	50                   	push   %eax
   143a8:	e8 2d cc ff ff       	call   10fda <Print>
   143ad:	83 c4 20             	add    $0x20,%esp
   143b0:	eb fe                	jmp    143b0 <Cond_Wait+0xb7>

    /* Turn off scheduling. */
    g_preemptionDisabled = true;
   143b2:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   143b8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    KASSERT(g_preemptionDisabled);
   143be:	8b 00                	mov    (%eax),%eax
   143c0:	85 c0                	test   %eax,%eax
   143c2:	74 6e                	je     14432 <Cond_Wait+0x139>
    KASSERT(IS_HELD(mutex));
   143c4:	83 3e 01             	cmpl   $0x1,(%esi)
   143c7:	0f 85 a6 00 00 00    	jne    14473 <Cond_Wait+0x17a>
    mutex->state = MUTEX_UNLOCKED;
   143cd:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    mutex->owner = 0;
   143d3:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    if (!Is_Thread_Queue_Empty(&mutex->waitQueue)) {
   143da:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
   143de:	0f 84 ea 00 00 00    	je     144ce <Cond_Wait+0x1d5>
	Disable_Interrupts();
   143e4:	e8 63 be ff ff       	call   1024c <Interrupts_Enabled>
   143e9:	84 c0                	test   %al,%al
   143eb:	0f 85 c3 00 00 00    	jne    144b4 <Cond_Wait+0x1bb>
   143f1:	83 ec 0c             	sub    $0xc,%esp
   143f4:	6a 4f                	push   $0x4f
   143f6:	e8 2e cd ff ff       	call   11129 <Set_Current_Attr>
   143fb:	83 c4 0c             	add    $0xc,%esp
   143fe:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14404:	ff 30                	pushl  (%eax)
   14406:	ff 74 24 14          	pushl  0x14(%esp)
   1440a:	6a 5b                	push   $0x5b
   1440c:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14412:	50                   	push   %eax
   14413:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14419:	50                   	push   %eax
   1441a:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   14420:	50                   	push   %eax
   14421:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14427:	50                   	push   %eax
   14428:	e8 ad cb ff ff       	call   10fda <Print>
   1442d:	83 c4 20             	add    $0x20,%esp
   14430:	eb fe                	jmp    14430 <Cond_Wait+0x137>
    KASSERT(g_preemptionDisabled);
   14432:	83 ec 0c             	sub    $0xc,%esp
   14435:	6a 4f                	push   $0x4f
   14437:	e8 ed cc ff ff       	call   11129 <Set_Current_Attr>
   1443c:	83 c4 0c             	add    $0xc,%esp
   1443f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14445:	ff 30                	pushl  (%eax)
   14447:	ff 74 24 14          	pushl  0x14(%esp)
   1444b:	6a 4a                	push   $0x4a
   1444d:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14453:	50                   	push   %eax
   14454:	8d 83 ee 7e ff ff    	lea    -0x8112(%ebx),%eax
   1445a:	50                   	push   %eax
   1445b:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   14461:	50                   	push   %eax
   14462:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14468:	50                   	push   %eax
   14469:	e8 6c cb ff ff       	call   10fda <Print>
   1446e:	83 c4 20             	add    $0x20,%esp
   14471:	eb fe                	jmp    14471 <Cond_Wait+0x178>
    KASSERT(IS_HELD(mutex));
   14473:	83 ec 0c             	sub    $0xc,%esp
   14476:	6a 4f                	push   $0x4f
   14478:	e8 ac cc ff ff       	call   11129 <Set_Current_Attr>
   1447d:	83 c4 0c             	add    $0xc,%esp
   14480:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14486:	ff 30                	pushl  (%eax)
   14488:	ff 74 24 14          	pushl  0x14(%esp)
   1448c:	6a 4d                	push   $0x4d
   1448e:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14494:	50                   	push   %eax
   14495:	8d 83 2b 7e ff ff    	lea    -0x81d5(%ebx),%eax
   1449b:	50                   	push   %eax
   1449c:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   144a2:	50                   	push   %eax
   144a3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   144a9:	50                   	push   %eax
   144aa:	e8 2b cb ff ff       	call   10fda <Print>
   144af:	83 c4 20             	add    $0x20,%esp
   144b2:	eb fe                	jmp    144b2 <Cond_Wait+0x1b9>
    __asm__ __volatile__ ("cli");
   144b4:	fa                   	cli    
	Wake_Up_One(&mutex->waitQueue);
   144b5:	83 ec 0c             	sub    $0xc,%esp
   144b8:	8d 46 08             	lea    0x8(%esi),%eax
   144bb:	50                   	push   %eax
   144bc:	e8 13 19 00 00       	call   15dd4 <Wake_Up_One>
	Enable_Interrupts();
   144c1:	e8 86 bd ff ff       	call   1024c <Interrupts_Enabled>
   144c6:	83 c4 10             	add    $0x10,%esp
   144c9:	84 c0                	test   %al,%al
   144cb:	75 52                	jne    1451f <Cond_Wait+0x226>
    __asm__ __volatile__ ("sti");
   144cd:	fb                   	sti    
     * Other threads can run while this thread is waiting,
     * and eventually one of them will call Cond_Signal() or Cond_Broadcast()
     * to wake up this thread.
     * On wakeup, disable preemption again.
     */
    Disable_Interrupts();
   144ce:	e8 79 bd ff ff       	call   1024c <Interrupts_Enabled>
   144d3:	84 c0                	test   %al,%al
   144d5:	0f 85 85 00 00 00    	jne    14560 <Cond_Wait+0x267>
   144db:	83 ec 0c             	sub    $0xc,%esp
   144de:	6a 4f                	push   $0x4f
   144e0:	e8 44 cc ff ff       	call   11129 <Set_Current_Attr>
   144e5:	83 c4 0c             	add    $0xc,%esp
   144e8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   144ee:	ff 30                	pushl  (%eax)
   144f0:	ff 74 24 14          	pushl  0x14(%esp)
   144f4:	68 ab 00 00 00       	push   $0xab
   144f9:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   144ff:	50                   	push   %eax
   14500:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14506:	50                   	push   %eax
   14507:	8d 83 58 7e ff ff    	lea    -0x81a8(%ebx),%eax
   1450d:	50                   	push   %eax
   1450e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14514:	50                   	push   %eax
   14515:	e8 c0 ca ff ff       	call   10fda <Print>
   1451a:	83 c4 20             	add    $0x20,%esp
   1451d:	eb fe                	jmp    1451d <Cond_Wait+0x224>
	Enable_Interrupts();
   1451f:	83 ec 0c             	sub    $0xc,%esp
   14522:	6a 4f                	push   $0x4f
   14524:	e8 00 cc ff ff       	call   11129 <Set_Current_Attr>
   14529:	83 c4 0c             	add    $0xc,%esp
   1452c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14532:	ff 30                	pushl  (%eax)
   14534:	ff 74 24 14          	pushl  0x14(%esp)
   14538:	6a 5d                	push   $0x5d
   1453a:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14540:	50                   	push   %eax
   14541:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   14547:	50                   	push   %eax
   14548:	8d 83 64 7e ff ff    	lea    -0x819c(%ebx),%eax
   1454e:	50                   	push   %eax
   1454f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14555:	50                   	push   %eax
   14556:	e8 7f ca ff ff       	call   10fda <Print>
   1455b:	83 c4 20             	add    $0x20,%esp
   1455e:	eb fe                	jmp    1455e <Cond_Wait+0x265>
    __asm__ __volatile__ ("cli");
   14560:	fa                   	cli    
    g_preemptionDisabled = false;
   14561:	c7 c7 8c 77 02 00    	mov    $0x2778c,%edi
   14567:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    Wait(&cond->waitQueue);
   1456d:	83 ec 0c             	sub    $0xc,%esp
   14570:	ff 74 24 1c          	pushl  0x1c(%esp)
   14574:	e8 de 0e 00 00       	call   15457 <Wait>
    g_preemptionDisabled = true;
   14579:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
    Enable_Interrupts();
   1457f:	e8 c8 bc ff ff       	call   1024c <Interrupts_Enabled>
   14584:	83 c4 10             	add    $0x10,%esp
   14587:	84 c0                	test   %al,%al
   14589:	74 44                	je     145cf <Cond_Wait+0x2d6>
   1458b:	83 ec 0c             	sub    $0xc,%esp
   1458e:	6a 4f                	push   $0x4f
   14590:	e8 94 cb ff ff       	call   11129 <Set_Current_Attr>
   14595:	83 c4 0c             	add    $0xc,%esp
   14598:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1459e:	ff 30                	pushl  (%eax)
   145a0:	ff 74 24 14          	pushl  0x14(%esp)
   145a4:	68 af 00 00 00       	push   $0xaf
   145a9:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   145af:	50                   	push   %eax
   145b0:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   145b6:	50                   	push   %eax
   145b7:	8d 83 58 7e ff ff    	lea    -0x81a8(%ebx),%eax
   145bd:	50                   	push   %eax
   145be:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   145c4:	50                   	push   %eax
   145c5:	e8 10 ca ff ff       	call   10fda <Print>
   145ca:	83 c4 20             	add    $0x20,%esp
   145cd:	eb fe                	jmp    145cd <Cond_Wait+0x2d4>
    __asm__ __volatile__ ("sti");
   145cf:	fb                   	sti    
    KASSERT(g_preemptionDisabled);
   145d0:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   145d6:	8b 00                	mov    (%eax),%eax
   145d8:	85 c0                	test   %eax,%eax
   145da:	74 3f                	je     1461b <Cond_Wait+0x322>
    KASSERT(!IS_HELD(mutex));
   145dc:	83 3e 01             	cmpl   $0x1,(%esi)
   145df:	75 19                	jne    145fa <Cond_Wait+0x301>
   145e1:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   145e7:	8b 00                	mov    (%eax),%eax
   145e9:	39 46 04             	cmp    %eax,0x4(%esi)
   145ec:	74 6e                	je     1465c <Cond_Wait+0x363>
	Mutex_Wait(mutex);
   145ee:	89 f0                	mov    %esi,%eax
   145f0:	e8 68 f8 ff ff       	call   13e5d <Mutex_Wait>
    while (mutex->state == MUTEX_LOCKED) {
   145f5:	83 3e 01             	cmpl   $0x1,(%esi)
   145f8:	74 f4                	je     145ee <Cond_Wait+0x2f5>
    mutex->state = MUTEX_LOCKED;
   145fa:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    mutex->owner = g_currentThread;
   14600:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14606:	8b 00                	mov    (%eax),%eax
   14608:	89 46 04             	mov    %eax,0x4(%esi)

    /* Reacquire the mutex. */
    Mutex_Lock_Imp(mutex);

    /* Turn scheduling back on. */
    g_preemptionDisabled = false;
   1460b:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   14611:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   14617:	5b                   	pop    %ebx
   14618:	5e                   	pop    %esi
   14619:	5f                   	pop    %edi
   1461a:	c3                   	ret    
    KASSERT(g_preemptionDisabled);
   1461b:	83 ec 0c             	sub    $0xc,%esp
   1461e:	6a 4f                	push   $0x4f
   14620:	e8 04 cb ff ff       	call   11129 <Set_Current_Attr>
   14625:	83 c4 0c             	add    $0xc,%esp
   14628:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1462e:	ff 30                	pushl  (%eax)
   14630:	ff 74 24 14          	pushl  0x14(%esp)
   14634:	6a 35                	push   $0x35
   14636:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   1463c:	50                   	push   %eax
   1463d:	8d 83 ee 7e ff ff    	lea    -0x8112(%ebx),%eax
   14643:	50                   	push   %eax
   14644:	8d 83 94 7e ff ff    	lea    -0x816c(%ebx),%eax
   1464a:	50                   	push   %eax
   1464b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14651:	50                   	push   %eax
   14652:	e8 83 c9 ff ff       	call   10fda <Print>
   14657:	83 c4 20             	add    $0x20,%esp
   1465a:	eb fe                	jmp    1465a <Cond_Wait+0x361>
    KASSERT(!IS_HELD(mutex));
   1465c:	83 ec 0c             	sub    $0xc,%esp
   1465f:	6a 4f                	push   $0x4f
   14661:	e8 c3 ca ff ff       	call   11129 <Set_Current_Attr>
   14666:	83 c4 0c             	add    $0xc,%esp
   14669:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1466f:	ff 30                	pushl  (%eax)
   14671:	ff 74 24 14          	pushl  0x14(%esp)
   14675:	6a 38                	push   $0x38
   14677:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   1467d:	50                   	push   %eax
   1467e:	8d 83 2a 7e ff ff    	lea    -0x81d6(%ebx),%eax
   14684:	50                   	push   %eax
   14685:	8d 83 94 7e ff ff    	lea    -0x816c(%ebx),%eax
   1468b:	50                   	push   %eax
   1468c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14692:	50                   	push   %eax
   14693:	e8 42 c9 ff ff       	call   10fda <Print>
   14698:	83 c4 20             	add    $0x20,%esp
   1469b:	eb fe                	jmp    1469b <Cond_Wait+0x3a2>

0001469d <Cond_Signal>:
/*
 * Wake up one thread waiting on the given condition.
 * The mutex guarding the condition should be held!
 */
void Cond_Signal(struct Condition* cond)
{
   1469d:	53                   	push   %ebx
   1469e:	83 ec 08             	sub    $0x8,%esp
   146a1:	e8 6c bb ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   146a6:	81 c3 5a 19 01 00    	add    $0x1195a,%ebx
    KASSERT(Interrupts_Enabled());
   146ac:	e8 9b bb ff ff       	call   1024c <Interrupts_Enabled>
   146b1:	84 c0                	test   %al,%al
   146b3:	75 44                	jne    146f9 <Cond_Signal+0x5c>
   146b5:	83 ec 0c             	sub    $0xc,%esp
   146b8:	6a 4f                	push   $0x4f
   146ba:	e8 6a ca ff ff       	call   11129 <Set_Current_Attr>
   146bf:	83 c4 0c             	add    $0xc,%esp
   146c2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   146c8:	ff 30                	pushl  (%eax)
   146ca:	ff 74 24 14          	pushl  0x14(%esp)
   146ce:	68 be 00 00 00       	push   $0xbe
   146d3:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   146d9:	50                   	push   %eax
   146da:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   146e0:	50                   	push   %eax
   146e1:	8d 83 4c 7e ff ff    	lea    -0x81b4(%ebx),%eax
   146e7:	50                   	push   %eax
   146e8:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   146ee:	50                   	push   %eax
   146ef:	e8 e6 c8 ff ff       	call   10fda <Print>
   146f4:	83 c4 20             	add    $0x20,%esp
   146f7:	eb fe                	jmp    146f7 <Cond_Signal+0x5a>
    Disable_Interrupts();  /* prevent scheduling */
   146f9:	e8 4e bb ff ff       	call   1024c <Interrupts_Enabled>
   146fe:	84 c0                	test   %al,%al
   14700:	75 44                	jne    14746 <Cond_Signal+0xa9>
   14702:	83 ec 0c             	sub    $0xc,%esp
   14705:	6a 4f                	push   $0x4f
   14707:	e8 1d ca ff ff       	call   11129 <Set_Current_Attr>
   1470c:	83 c4 0c             	add    $0xc,%esp
   1470f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14715:	ff 30                	pushl  (%eax)
   14717:	ff 74 24 14          	pushl  0x14(%esp)
   1471b:	68 bf 00 00 00       	push   $0xbf
   14720:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14726:	50                   	push   %eax
   14727:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1472d:	50                   	push   %eax
   1472e:	8d 83 4c 7e ff ff    	lea    -0x81b4(%ebx),%eax
   14734:	50                   	push   %eax
   14735:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1473b:	50                   	push   %eax
   1473c:	e8 99 c8 ff ff       	call   10fda <Print>
   14741:	83 c4 20             	add    $0x20,%esp
   14744:	eb fe                	jmp    14744 <Cond_Signal+0xa7>
    __asm__ __volatile__ ("cli");
   14746:	fa                   	cli    
    Wake_Up_One(&cond->waitQueue);
   14747:	83 ec 0c             	sub    $0xc,%esp
   1474a:	ff 74 24 1c          	pushl  0x1c(%esp)
   1474e:	e8 81 16 00 00       	call   15dd4 <Wake_Up_One>
    Enable_Interrupts();  /* resume scheduling */
   14753:	e8 f4 ba ff ff       	call   1024c <Interrupts_Enabled>
   14758:	83 c4 10             	add    $0x10,%esp
   1475b:	84 c0                	test   %al,%al
   1475d:	75 06                	jne    14765 <Cond_Signal+0xc8>
    __asm__ __volatile__ ("sti");
   1475f:	fb                   	sti    
}
   14760:	83 c4 08             	add    $0x8,%esp
   14763:	5b                   	pop    %ebx
   14764:	c3                   	ret    
    Enable_Interrupts();  /* resume scheduling */
   14765:	83 ec 0c             	sub    $0xc,%esp
   14768:	6a 4f                	push   $0x4f
   1476a:	e8 ba c9 ff ff       	call   11129 <Set_Current_Attr>
   1476f:	83 c4 0c             	add    $0xc,%esp
   14772:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14778:	ff 30                	pushl  (%eax)
   1477a:	ff 74 24 14          	pushl  0x14(%esp)
   1477e:	68 c1 00 00 00       	push   $0xc1
   14783:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14789:	50                   	push   %eax
   1478a:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   14790:	50                   	push   %eax
   14791:	8d 83 4c 7e ff ff    	lea    -0x81b4(%ebx),%eax
   14797:	50                   	push   %eax
   14798:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1479e:	50                   	push   %eax
   1479f:	e8 36 c8 ff ff       	call   10fda <Print>
   147a4:	83 c4 20             	add    $0x20,%esp
   147a7:	eb fe                	jmp    147a7 <Cond_Signal+0x10a>

000147a9 <Cond_Broadcast>:
/*
 * Wake up all threads waiting on the given condition.
 * The mutex guarding the condition should be held!
 */
void Cond_Broadcast(struct Condition* cond)
{
   147a9:	53                   	push   %ebx
   147aa:	83 ec 08             	sub    $0x8,%esp
   147ad:	e8 60 ba ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   147b2:	81 c3 4e 18 01 00    	add    $0x1184e,%ebx
    KASSERT(Interrupts_Enabled());
   147b8:	e8 8f ba ff ff       	call   1024c <Interrupts_Enabled>
   147bd:	84 c0                	test   %al,%al
   147bf:	75 44                	jne    14805 <Cond_Broadcast+0x5c>
   147c1:	83 ec 0c             	sub    $0xc,%esp
   147c4:	6a 4f                	push   $0x4f
   147c6:	e8 5e c9 ff ff       	call   11129 <Set_Current_Attr>
   147cb:	83 c4 0c             	add    $0xc,%esp
   147ce:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   147d4:	ff 30                	pushl  (%eax)
   147d6:	ff 74 24 14          	pushl  0x14(%esp)
   147da:	68 ca 00 00 00       	push   $0xca
   147df:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   147e5:	50                   	push   %eax
   147e6:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   147ec:	50                   	push   %eax
   147ed:	8d 83 3c 7e ff ff    	lea    -0x81c4(%ebx),%eax
   147f3:	50                   	push   %eax
   147f4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   147fa:	50                   	push   %eax
   147fb:	e8 da c7 ff ff       	call   10fda <Print>
   14800:	83 c4 20             	add    $0x20,%esp
   14803:	eb fe                	jmp    14803 <Cond_Broadcast+0x5a>
    Disable_Interrupts();  /* prevent scheduling */
   14805:	e8 42 ba ff ff       	call   1024c <Interrupts_Enabled>
   1480a:	84 c0                	test   %al,%al
   1480c:	75 44                	jne    14852 <Cond_Broadcast+0xa9>
   1480e:	83 ec 0c             	sub    $0xc,%esp
   14811:	6a 4f                	push   $0x4f
   14813:	e8 11 c9 ff ff       	call   11129 <Set_Current_Attr>
   14818:	83 c4 0c             	add    $0xc,%esp
   1481b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14821:	ff 30                	pushl  (%eax)
   14823:	ff 74 24 14          	pushl  0x14(%esp)
   14827:	68 cb 00 00 00       	push   $0xcb
   1482c:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14832:	50                   	push   %eax
   14833:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14839:	50                   	push   %eax
   1483a:	8d 83 3c 7e ff ff    	lea    -0x81c4(%ebx),%eax
   14840:	50                   	push   %eax
   14841:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14847:	50                   	push   %eax
   14848:	e8 8d c7 ff ff       	call   10fda <Print>
   1484d:	83 c4 20             	add    $0x20,%esp
   14850:	eb fe                	jmp    14850 <Cond_Broadcast+0xa7>
    __asm__ __volatile__ ("cli");
   14852:	fa                   	cli    
    Wake_Up(&cond->waitQueue);
   14853:	83 ec 0c             	sub    $0xc,%esp
   14856:	ff 74 24 1c          	pushl  0x1c(%esp)
   1485a:	e8 73 0f 00 00       	call   157d2 <Wake_Up>
    Enable_Interrupts();  /* resume scheduling */
   1485f:	e8 e8 b9 ff ff       	call   1024c <Interrupts_Enabled>
   14864:	83 c4 10             	add    $0x10,%esp
   14867:	84 c0                	test   %al,%al
   14869:	75 06                	jne    14871 <Cond_Broadcast+0xc8>
    __asm__ __volatile__ ("sti");
   1486b:	fb                   	sti    
}
   1486c:	83 c4 08             	add    $0x8,%esp
   1486f:	5b                   	pop    %ebx
   14870:	c3                   	ret    
    Enable_Interrupts();  /* resume scheduling */
   14871:	83 ec 0c             	sub    $0xc,%esp
   14874:	6a 4f                	push   $0x4f
   14876:	e8 ae c8 ff ff       	call   11129 <Set_Current_Attr>
   1487b:	83 c4 0c             	add    $0xc,%esp
   1487e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14884:	ff 30                	pushl  (%eax)
   14886:	ff 74 24 14          	pushl  0x14(%esp)
   1488a:	68 cd 00 00 00       	push   $0xcd
   1488f:	8d 83 f7 7d ff ff    	lea    -0x8209(%ebx),%eax
   14895:	50                   	push   %eax
   14896:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1489c:	50                   	push   %eax
   1489d:	8d 83 3c 7e ff ff    	lea    -0x81c4(%ebx),%eax
   148a3:	50                   	push   %eax
   148a4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   148aa:	50                   	push   %eax
   148ab:	e8 2a c7 ff ff       	call   10fda <Print>
   148b0:	83 c4 20             	add    $0x20,%esp
   148b3:	eb fe                	jmp    148b3 <Cond_Broadcast+0x10a>

000148b5 <Launch_Thread>:
 * a thread start function is executed.  Currently we just use
 * it to enable interrupts (since Schedule() always activates
 * a thread with interrupts disabled).
 */
static void Launch_Thread(void)
{
   148b5:	53                   	push   %ebx
   148b6:	83 ec 08             	sub    $0x8,%esp
   148b9:	e8 54 b9 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   148be:	81 c3 42 17 01 00    	add    $0x11742,%ebx
    Enable_Interrupts();
   148c4:	e8 83 b9 ff ff       	call   1024c <Interrupts_Enabled>
   148c9:	84 c0                	test   %al,%al
   148cb:	75 06                	jne    148d3 <Launch_Thread+0x1e>
   148cd:	fb                   	sti    
}
   148ce:	83 c4 08             	add    $0x8,%esp
   148d1:	5b                   	pop    %ebx
   148d2:	c3                   	ret    
    Enable_Interrupts();
   148d3:	83 ec 0c             	sub    $0xc,%esp
   148d6:	6a 4f                	push   $0x4f
   148d8:	e8 4c c8 ff ff       	call   11129 <Set_Current_Attr>
   148dd:	83 c4 0c             	add    $0xc,%esp
   148e0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   148e6:	ff 30                	pushl  (%eax)
   148e8:	ff 74 24 14          	pushl  0x14(%esp)
   148ec:	68 d2 00 00 00       	push   $0xd2
   148f1:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   148f7:	50                   	push   %eax
   148f8:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   148fe:	50                   	push   %eax
   148ff:	8d 83 d8 81 ff ff    	lea    -0x7e28(%ebx),%eax
   14905:	50                   	push   %eax
   14906:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1490c:	50                   	push   %eax
   1490d:	e8 c8 c6 ff ff       	call   10fda <Print>
   14912:	83 c4 20             	add    $0x20,%esp
   14915:	eb fe                	jmp    14915 <Launch_Thread+0x60>

00014917 <Create_Thread>:
{
   14917:	55                   	push   %ebp
   14918:	57                   	push   %edi
   14919:	56                   	push   %esi
   1491a:	53                   	push   %ebx
   1491b:	83 ec 1c             	sub    $0x1c,%esp
   1491e:	e8 ef b8 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14923:	81 c3 dd 16 01 00    	add    $0x116dd,%ebx
   14929:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1492d:	89 d7                	mov    %edx,%edi
    kthread = Alloc_Page();
   1492f:	e8 20 dd ff ff       	call   12654 <Alloc_Page>
   14934:	89 c6                	mov    %eax,%esi
    if (kthread != 0)
   14936:	85 c0                	test   %eax,%eax
   14938:	0f 84 0d 01 00 00    	je     14a4b <Create_Thread+0x134>
        stackPage = Alloc_Page();    
   1493e:	e8 11 dd ff ff       	call   12654 <Alloc_Page>
   14943:	89 c5                	mov    %eax,%ebp
    if (stackPage == 0) {
   14945:	85 c0                	test   %eax,%eax
   14947:	0f 84 ca 00 00 00    	je     14a17 <Create_Thread+0x100>
    struct Kernel_Thread* owner = detached ? (struct Kernel_Thread*)0 : g_currentThread;
   1494d:	89 f8                	mov    %edi,%eax
   1494f:	84 c0                	test   %al,%al
   14951:	0f 85 fe 00 00 00    	jne    14a55 <Create_Thread+0x13e>
   14957:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1495d:	8b 10                	mov    (%eax),%edx
    memset(kthread, '\0', sizeof(*kthread));
   1495f:	c7 86 3c 02 00 00 00 	movl   $0x0,0x23c(%esi)
   14966:	00 00 00 
   14969:	8d 7e 04             	lea    0x4(%esi),%edi
   1496c:	83 e7 fc             	and    $0xfffffffc,%edi
   1496f:	89 f1                	mov    %esi,%ecx
   14971:	29 f9                	sub    %edi,%ecx
   14973:	81 c1 40 02 00 00    	add    $0x240,%ecx
   14979:	c1 e9 02             	shr    $0x2,%ecx
   1497c:	b8 00 00 00 00       	mov    $0x0,%eax
   14981:	f3 ab                	rep stos %eax,%es:(%edi)
    kthread->stackPage = stackPage;
   14983:	89 6e 14             	mov    %ebp,0x14(%esi)
    kthread->esp = ((ulong_t) kthread->stackPage) + PAGE_SIZE;
   14986:	81 c5 00 10 00 00    	add    $0x1000,%ebp
   1498c:	89 2e                	mov    %ebp,(%esi)
    kthread->numTicks = 0;
   1498e:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    kthread->priority = priority;
   14995:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14999:	89 46 08             	mov    %eax,0x8(%esi)
    kthread->owner = owner;
   1499c:	89 56 1c             	mov    %edx,0x1c(%esi)
    kthread->refCount = detached ? 1 : 2;
   1499f:	b8 02 00 00 00       	mov    $0x2,%eax
   149a4:	89 46 20             	mov    %eax,0x20(%esi)
    kthread->alive = true;
   149a7:	c6 46 24 01          	movb   $0x1,0x24(%esi)
    kthread->pid = nextFreePid++;
   149ab:	8b 83 40 00 00 00    	mov    0x40(%ebx),%eax
   149b1:	8d 50 01             	lea    0x1(%eax),%edx
   149b4:	89 93 40 00 00 00    	mov    %edx,0x40(%ebx)
   149ba:	89 46 34             	mov    %eax,0x34(%esi)
IMPLEMENT_LIST(All_Thread_List, Kernel_Thread);
   149bd:	8b 83 fc 12 00 00    	mov    0x12fc(%ebx),%eax
   149c3:	85 c0                	test   %eax,%eax
   149c5:	74 6e                	je     14a35 <Create_Thread+0x11e>
   149c7:	39 c6                	cmp    %eax,%esi
   149c9:	74 0b                	je     149d6 <Create_Thread+0xbf>
   149cb:	8b 40 3c             	mov    0x3c(%eax),%eax
   149ce:	85 c0                	test   %eax,%eax
   149d0:	74 63                	je     14a35 <Create_Thread+0x11e>
   149d2:	39 c6                	cmp    %eax,%esi
   149d4:	75 f5                	jne    149cb <Create_Thread+0xb4>
   149d6:	83 ec 0c             	sub    $0xc,%esp
   149d9:	6a 4f                	push   $0x4f
   149db:	e8 49 c7 ff ff       	call   11129 <Set_Current_Attr>
   149e0:	83 c4 0c             	add    $0xc,%esp
   149e3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   149e9:	ff 30                	pushl  (%eax)
   149eb:	ff 74 24 34          	pushl  0x34(%esp)
   149ef:	6a 45                	push   $0x45
   149f1:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   149f7:	50                   	push   %eax
   149f8:	8d 83 74 7f ff ff    	lea    -0x808c(%ebx),%eax
   149fe:	50                   	push   %eax
   149ff:	8d 83 e8 81 ff ff    	lea    -0x7e18(%ebx),%eax
   14a05:	50                   	push   %eax
   14a06:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14a0c:	50                   	push   %eax
   14a0d:	e8 c8 c5 ff ff       	call   10fda <Print>
   14a12:	83 c4 20             	add    $0x20,%esp
   14a15:	eb fe                	jmp    14a15 <Create_Thread+0xfe>
	Free_Page(kthread);
   14a17:	83 ec 0c             	sub    $0xc,%esp
   14a1a:	56                   	push   %esi
   14a1b:	e8 df dd ff ff       	call   127ff <Free_Page>
	return 0;
   14a20:	83 c4 10             	add    $0x10,%esp
   14a23:	89 ee                	mov    %ebp,%esi
   14a25:	eb 24                	jmp    14a4b <Create_Thread+0x134>
   14a27:	89 b3 00 13 00 00    	mov    %esi,0x1300(%ebx)
   14a2d:	89 b3 fc 12 00 00    	mov    %esi,0x12fc(%ebx)
   14a33:	eb 16                	jmp    14a4b <Create_Thread+0x134>
   14a35:	8b 83 00 13 00 00    	mov    0x1300(%ebx),%eax
   14a3b:	85 c0                	test   %eax,%eax
   14a3d:	74 e8                	je     14a27 <Create_Thread+0x110>
   14a3f:	89 70 3c             	mov    %esi,0x3c(%eax)
   14a42:	89 46 38             	mov    %eax,0x38(%esi)
   14a45:	89 b3 00 13 00 00    	mov    %esi,0x1300(%ebx)
}
   14a4b:	89 f0                	mov    %esi,%eax
   14a4d:	83 c4 1c             	add    $0x1c,%esp
   14a50:	5b                   	pop    %ebx
   14a51:	5e                   	pop    %esi
   14a52:	5f                   	pop    %edi
   14a53:	5d                   	pop    %ebp
   14a54:	c3                   	ret    
    memset(kthread, '\0', sizeof(*kthread));
   14a55:	c7 86 3c 02 00 00 00 	movl   $0x0,0x23c(%esi)
   14a5c:	00 00 00 
   14a5f:	8d 7e 04             	lea    0x4(%esi),%edi
   14a62:	83 e7 fc             	and    $0xfffffffc,%edi
   14a65:	89 f1                	mov    %esi,%ecx
   14a67:	29 f9                	sub    %edi,%ecx
   14a69:	81 c1 40 02 00 00    	add    $0x240,%ecx
   14a6f:	c1 e9 02             	shr    $0x2,%ecx
   14a72:	b8 00 00 00 00       	mov    $0x0,%eax
   14a77:	f3 ab                	rep stos %eax,%es:(%edi)
    kthread->stackPage = stackPage;
   14a79:	89 6e 14             	mov    %ebp,0x14(%esi)
    kthread->esp = ((ulong_t) kthread->stackPage) + PAGE_SIZE;
   14a7c:	81 c5 00 10 00 00    	add    $0x1000,%ebp
   14a82:	89 2e                	mov    %ebp,(%esi)
    kthread->numTicks = 0;
   14a84:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
    kthread->priority = priority;
   14a8b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14a8f:	89 46 08             	mov    %eax,0x8(%esi)
    kthread->owner = owner;
   14a92:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
    kthread->refCount = detached ? 1 : 2;
   14a99:	b8 01 00 00 00       	mov    $0x1,%eax
   14a9e:	e9 01 ff ff ff       	jmp    149a4 <Create_Thread+0x8d>

00014aa3 <Setup_User_Thread>:
/*
 * Set up the a user mode thread.
 */
/*static*/ void Setup_User_Thread(
    struct Kernel_Thread* kthread, struct User_Context* userContext)
{
   14aa3:	57                   	push   %edi
   14aa4:	56                   	push   %esi
   14aa5:	53                   	push   %ebx
   14aa6:	e8 67 b7 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14aab:	81 c3 55 15 01 00    	add    $0x11555,%ebx
   14ab1:	8b 74 24 10          	mov    0x10(%esp),%esi
   14ab5:	8b 7c 24 14          	mov    0x14(%esp),%edi
     *   just before the entry point instruction was executed
     * - The esi register should contain the address of
     *   the argument block
     */

    Attach_User_Context(kthread, userContext);
   14ab9:	83 ec 08             	sub    $0x8,%esp
   14abc:	57                   	push   %edi
   14abd:	56                   	push   %esi
   14abe:	e8 0d 19 00 00       	call   163d0 <Attach_User_Context>

    Push(kthread, userContext->dsSelector);
   14ac3:	0f b7 57 20          	movzwl 0x20(%edi),%edx
    kthread->esp -= 4;
   14ac7:	8b 06                	mov    (%esi),%eax
   14ac9:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14acc:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14ace:	89 50 fc             	mov    %edx,-0x4(%eax)
    Push(kthread, userContext->stackPointerAddr);
   14ad1:	8b 57 2c             	mov    0x2c(%edi),%edx
    kthread->esp -= 4;
   14ad4:	8b 06                	mov    (%esi),%eax
   14ad6:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14ad9:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14adb:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14ade:	8b 06                	mov    (%esi),%eax
   14ae0:	8d 50 fc             	lea    -0x4(%eax),%edx
   14ae3:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14ae5:	c7 40 fc 00 02 00 00 	movl   $0x200,-0x4(%eax)
    Push(kthread, EFLAGS_IF);
    Push(kthread, userContext->csSelector);
   14aec:	0f b7 57 1e          	movzwl 0x1e(%edi),%edx
    kthread->esp -= 4;
   14af0:	8b 06                	mov    (%esi),%eax
   14af2:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14af5:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14af7:	89 50 fc             	mov    %edx,-0x4(%eax)
    Push(kthread, userContext->entryAddr);
   14afa:	8b 57 24             	mov    0x24(%edi),%edx
    kthread->esp -= 4;
   14afd:	8b 06                	mov    (%esi),%eax
   14aff:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14b02:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b04:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14b07:	8b 06                	mov    (%esi),%eax
   14b09:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b0c:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b0e:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b15:	8b 06                	mov    (%esi),%eax
   14b17:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b1a:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b1c:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b23:	8b 06                	mov    (%esi),%eax
   14b25:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b28:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b2a:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b31:	8b 06                	mov    (%esi),%eax
   14b33:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b36:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b38:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b3f:	8b 06                	mov    (%esi),%eax
   14b41:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b44:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b46:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b4d:	8b 06                	mov    (%esi),%eax
   14b4f:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b52:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b54:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)

    Push(kthread, 0);  // eax
    Push(kthread, 0);  // ebx
    Push(kthread, 0);  // ecx
    Push(kthread, 0);  // edx
    Push(kthread, userContext->argBlockAddr);  // esi
   14b5b:	8b 57 28             	mov    0x28(%edi),%edx
    kthread->esp -= 4;
   14b5e:	8b 06                	mov    (%esi),%eax
   14b60:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14b63:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b65:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14b68:	8b 06                	mov    (%esi),%eax
   14b6a:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b6d:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b6f:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14b76:	8b 06                	mov    (%esi),%eax
   14b78:	8d 50 fc             	lea    -0x4(%eax),%edx
   14b7b:	89 16                	mov    %edx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b7d:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    Push(kthread, 0);  // edi
    Push(kthread, 0);  // ebp
    
    Push(kthread, userContext->dsSelector);  // ds
   14b84:	0f b7 57 20          	movzwl 0x20(%edi),%edx
    kthread->esp -= 4;
   14b88:	8b 06                	mov    (%esi),%eax
   14b8a:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14b8d:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b8f:	89 50 fc             	mov    %edx,-0x4(%eax)
    Push(kthread, userContext->dsSelector);  // es
   14b92:	0f b7 57 20          	movzwl 0x20(%edi),%edx
    kthread->esp -= 4;
   14b96:	8b 06                	mov    (%esi),%eax
   14b98:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14b9b:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14b9d:	89 50 fc             	mov    %edx,-0x4(%eax)
    Push(kthread, userContext->dsSelector);  // fs
   14ba0:	0f b7 57 20          	movzwl 0x20(%edi),%edx
    kthread->esp -= 4;
   14ba4:	8b 06                	mov    (%esi),%eax
   14ba6:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14ba9:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14bab:	89 50 fc             	mov    %edx,-0x4(%eax)
    Push(kthread, userContext->dsSelector);  // gs
   14bae:	0f b7 57 20          	movzwl 0x20(%edi),%edx
    kthread->esp -= 4;
   14bb2:	8b 06                	mov    (%esi),%eax
   14bb4:	8d 48 fc             	lea    -0x4(%eax),%ecx
   14bb7:	89 0e                	mov    %ecx,(%esi)
    *((ulong_t *) kthread->esp) = value;
   14bb9:	89 50 fc             	mov    %edx,-0x4(%eax)
}
   14bbc:	83 c4 10             	add    $0x10,%esp
   14bbf:	5b                   	pop    %ebx
   14bc0:	5e                   	pop    %esi
   14bc1:	5f                   	pop    %edi
   14bc2:	c3                   	ret    

00014bc3 <Make_Runnable>:
/*
 * Add given thread to the run queue, so that it
 * may be scheduled.  Must be called with interrupts disabled!
 */
void Make_Runnable(struct Kernel_Thread* kthread)
{
   14bc3:	56                   	push   %esi
   14bc4:	53                   	push   %ebx
   14bc5:	83 ec 04             	sub    $0x4,%esp
   14bc8:	e8 45 b6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14bcd:	81 c3 33 14 01 00    	add    $0x11433,%ebx
   14bd3:	8b 74 24 10          	mov    0x10(%esp),%esi
    KASSERT(!Interrupts_Enabled());
   14bd7:	e8 70 b6 ff ff       	call   1024c <Interrupts_Enabled>
   14bdc:	84 c0                	test   %al,%al
   14bde:	74 44                	je     14c24 <Make_Runnable+0x61>
   14be0:	83 ec 0c             	sub    $0xc,%esp
   14be3:	6a 4f                	push   $0x4f
   14be5:	e8 3f c5 ff ff       	call   11129 <Set_Current_Attr>
   14bea:	83 c4 0c             	add    $0xc,%esp
   14bed:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14bf3:	ff 30                	pushl  (%eax)
   14bf5:	ff 74 24 14          	pushl  0x14(%esp)
   14bf9:	68 32 02 00 00       	push   $0x232
   14bfe:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   14c04:	50                   	push   %eax
   14c05:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   14c0b:	50                   	push   %eax
   14c0c:	8d 83 c8 81 ff ff    	lea    -0x7e38(%ebx),%eax
   14c12:	50                   	push   %eax
   14c13:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14c19:	50                   	push   %eax
   14c1a:	e8 bb c3 ff ff       	call   10fda <Print>
   14c1f:	83 c4 20             	add    $0x20,%esp
   14c22:	eb fe                	jmp    14c22 <Make_Runnable+0x5f>
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   14c24:	8b 83 f4 12 00 00    	mov    0x12f4(%ebx),%eax
   14c2a:	85 c0                	test   %eax,%eax
   14c2c:	74 65                	je     14c93 <Make_Runnable+0xd0>
   14c2e:	39 c6                	cmp    %eax,%esi
   14c30:	74 0b                	je     14c3d <Make_Runnable+0x7a>
   14c32:	8b 40 10             	mov    0x10(%eax),%eax
   14c35:	85 c0                	test   %eax,%eax
   14c37:	74 5a                	je     14c93 <Make_Runnable+0xd0>
   14c39:	39 c6                	cmp    %eax,%esi
   14c3b:	75 f5                	jne    14c32 <Make_Runnable+0x6f>
   14c3d:	83 ec 0c             	sub    $0xc,%esp
   14c40:	6a 4f                	push   $0x4f
   14c42:	e8 e2 c4 ff ff       	call   11129 <Set_Current_Attr>
   14c47:	83 c4 0c             	add    $0xc,%esp
   14c4a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14c50:	ff 30                	pushl  (%eax)
   14c52:	ff 74 24 14          	pushl  0x14(%esp)
   14c56:	6a 44                	push   $0x44
   14c58:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   14c5e:	50                   	push   %eax
   14c5f:	8d 83 a4 7f ff ff    	lea    -0x805c(%ebx),%eax
   14c65:	50                   	push   %eax
   14c66:	8d 83 ac 81 ff ff    	lea    -0x7e54(%ebx),%eax
   14c6c:	50                   	push   %eax
   14c6d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14c73:	50                   	push   %eax
   14c74:	e8 61 c3 ff ff       	call   10fda <Print>
   14c79:	83 c4 20             	add    $0x20,%esp
   14c7c:	eb fe                	jmp    14c7c <Make_Runnable+0xb9>
   14c7e:	89 b3 f8 12 00 00    	mov    %esi,0x12f8(%ebx)
   14c84:	89 b3 f4 12 00 00    	mov    %esi,0x12f4(%ebx)
   14c8a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
   14c91:	eb 1d                	jmp    14cb0 <Make_Runnable+0xed>
   14c93:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
   14c9a:	8b 83 f8 12 00 00    	mov    0x12f8(%ebx),%eax
   14ca0:	85 c0                	test   %eax,%eax
   14ca2:	74 da                	je     14c7e <Make_Runnable+0xbb>
   14ca4:	89 70 10             	mov    %esi,0x10(%eax)
   14ca7:	89 46 0c             	mov    %eax,0xc(%esi)
   14caa:	89 b3 f8 12 00 00    	mov    %esi,0x12f8(%ebx)

    Enqueue_Thread(&s_runQueue, kthread);
}
   14cb0:	83 c4 04             	add    $0x4,%esp
   14cb3:	5b                   	pop    %ebx
   14cb4:	5e                   	pop    %esi
   14cb5:	c3                   	ret    

00014cb6 <Make_Runnable_Atomic>:
/*
 * Atomically make a thread runnable.
 * Assumes interrupts are currently enabled.
 */
void Make_Runnable_Atomic(struct Kernel_Thread* kthread)
{
   14cb6:	53                   	push   %ebx
   14cb7:	83 ec 08             	sub    $0x8,%esp
   14cba:	e8 53 b5 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14cbf:	81 c3 41 13 01 00    	add    $0x11341,%ebx
    Disable_Interrupts();
   14cc5:	e8 82 b5 ff ff       	call   1024c <Interrupts_Enabled>
   14cca:	84 c0                	test   %al,%al
   14ccc:	75 44                	jne    14d12 <Make_Runnable_Atomic+0x5c>
   14cce:	83 ec 0c             	sub    $0xc,%esp
   14cd1:	6a 4f                	push   $0x4f
   14cd3:	e8 51 c4 ff ff       	call   11129 <Set_Current_Attr>
   14cd8:	83 c4 0c             	add    $0xc,%esp
   14cdb:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14ce1:	ff 30                	pushl  (%eax)
   14ce3:	ff 74 24 14          	pushl  0x14(%esp)
   14ce7:	68 3d 02 00 00       	push   $0x23d
   14cec:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   14cf2:	50                   	push   %eax
   14cf3:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   14cf9:	50                   	push   %eax
   14cfa:	8d 83 94 81 ff ff    	lea    -0x7e6c(%ebx),%eax
   14d00:	50                   	push   %eax
   14d01:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14d07:	50                   	push   %eax
   14d08:	e8 cd c2 ff ff       	call   10fda <Print>
   14d0d:	83 c4 20             	add    $0x20,%esp
   14d10:	eb fe                	jmp    14d10 <Make_Runnable_Atomic+0x5a>
    __asm__ __volatile__ ("cli");
   14d12:	fa                   	cli    
    Make_Runnable(kthread);
   14d13:	83 ec 0c             	sub    $0xc,%esp
   14d16:	ff 74 24 1c          	pushl  0x1c(%esp)
   14d1a:	e8 a4 fe ff ff       	call   14bc3 <Make_Runnable>
    Enable_Interrupts();
   14d1f:	e8 28 b5 ff ff       	call   1024c <Interrupts_Enabled>
   14d24:	83 c4 10             	add    $0x10,%esp
   14d27:	84 c0                	test   %al,%al
   14d29:	75 06                	jne    14d31 <Make_Runnable_Atomic+0x7b>
    __asm__ __volatile__ ("sti");
   14d2b:	fb                   	sti    
}
   14d2c:	83 c4 08             	add    $0x8,%esp
   14d2f:	5b                   	pop    %ebx
   14d30:	c3                   	ret    
    Enable_Interrupts();
   14d31:	83 ec 0c             	sub    $0xc,%esp
   14d34:	6a 4f                	push   $0x4f
   14d36:	e8 ee c3 ff ff       	call   11129 <Set_Current_Attr>
   14d3b:	83 c4 0c             	add    $0xc,%esp
   14d3e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14d44:	ff 30                	pushl  (%eax)
   14d46:	ff 74 24 14          	pushl  0x14(%esp)
   14d4a:	68 3f 02 00 00       	push   $0x23f
   14d4f:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   14d55:	50                   	push   %eax
   14d56:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   14d5c:	50                   	push   %eax
   14d5d:	8d 83 94 81 ff ff    	lea    -0x7e6c(%ebx),%eax
   14d63:	50                   	push   %eax
   14d64:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14d6a:	50                   	push   %eax
   14d6b:	e8 6a c2 ff ff       	call   10fda <Print>
   14d70:	83 c4 20             	add    $0x20,%esp
   14d73:	eb fe                	jmp    14d73 <Make_Runnable_Atomic+0xbd>

00014d75 <Start_Kernel_Thread>:
{
   14d75:	56                   	push   %esi
   14d76:	53                   	push   %ebx
   14d77:	83 ec 04             	sub    $0x4,%esp
   14d7a:	e8 54 b7 ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   14d7f:	81 c6 81 12 01 00    	add    $0x11281,%esi
    struct Kernel_Thread* kthread = Create_Thread(priority, detached);
   14d85:	0f b6 54 24 1c       	movzbl 0x1c(%esp),%edx
   14d8a:	8b 44 24 18          	mov    0x18(%esp),%eax
   14d8e:	e8 84 fb ff ff       	call   14917 <Create_Thread>
   14d93:	89 c3                	mov    %eax,%ebx
    if (kthread != 0) {
   14d95:	85 c0                	test   %eax,%eax
   14d97:	0f 84 1a 01 00 00    	je     14eb7 <Start_Kernel_Thread+0x142>
    kthread->esp -= 4;
   14d9d:	8b 00                	mov    (%eax),%eax
   14d9f:	8d 50 fc             	lea    -0x4(%eax),%edx
   14da2:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14da4:	8b 54 24 14          	mov    0x14(%esp),%edx
   14da8:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14dab:	8b 03                	mov    (%ebx),%eax
   14dad:	8d 50 fc             	lea    -0x4(%eax),%edx
   14db0:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14db2:	8d 96 ca fd fe ff    	lea    -0x10236(%esi),%edx
   14db8:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14dbb:	8b 03                	mov    (%ebx),%eax
   14dbd:	8d 50 fc             	lea    -0x4(%eax),%edx
   14dc0:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14dc2:	8b 54 24 10          	mov    0x10(%esp),%edx
   14dc6:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14dc9:	8b 03                	mov    (%ebx),%eax
   14dcb:	8d 50 fc             	lea    -0x4(%eax),%edx
   14dce:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14dd0:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14dd7:	8b 03                	mov    (%ebx),%eax
   14dd9:	8d 50 fc             	lea    -0x4(%eax),%edx
   14ddc:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14dde:	c7 40 fc 08 00 00 00 	movl   $0x8,-0x4(%eax)
    kthread->esp -= 4;
   14de5:	8b 03                	mov    (%ebx),%eax
   14de7:	8d 50 fc             	lea    -0x4(%eax),%edx
   14dea:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14dec:	8d 96 b5 e8 fe ff    	lea    -0x1174b(%esi),%edx
   14df2:	89 50 fc             	mov    %edx,-0x4(%eax)
    kthread->esp -= 4;
   14df5:	8b 03                	mov    (%ebx),%eax
   14df7:	8d 50 fc             	lea    -0x4(%eax),%edx
   14dfa:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14dfc:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e03:	8b 03                	mov    (%ebx),%eax
   14e05:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e08:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e0a:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e11:	8b 03                	mov    (%ebx),%eax
   14e13:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e16:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e18:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e1f:	8b 03                	mov    (%ebx),%eax
   14e21:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e24:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e26:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e2d:	8b 03                	mov    (%ebx),%eax
   14e2f:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e32:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e34:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e3b:	8b 03                	mov    (%ebx),%eax
   14e3d:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e40:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e42:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e49:	8b 03                	mov    (%ebx),%eax
   14e4b:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e4e:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e50:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e57:	8b 03                	mov    (%ebx),%eax
   14e59:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e5c:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e5e:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e65:	8b 03                	mov    (%ebx),%eax
   14e67:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e6a:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e6c:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e73:	8b 03                	mov    (%ebx),%eax
   14e75:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e78:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e7a:	c7 40 fc 10 00 00 00 	movl   $0x10,-0x4(%eax)
    kthread->esp -= 4;
   14e81:	8b 03                	mov    (%ebx),%eax
   14e83:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e86:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e88:	c7 40 fc 10 00 00 00 	movl   $0x10,-0x4(%eax)
    kthread->esp -= 4;
   14e8f:	8b 03                	mov    (%ebx),%eax
   14e91:	8d 50 fc             	lea    -0x4(%eax),%edx
   14e94:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14e96:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
    kthread->esp -= 4;
   14e9d:	8b 03                	mov    (%ebx),%eax
   14e9f:	8d 50 fc             	lea    -0x4(%eax),%edx
   14ea2:	89 13                	mov    %edx,(%ebx)
    *((ulong_t *) kthread->esp) = value;
   14ea4:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	Make_Runnable_Atomic(kthread);
   14eab:	83 ec 0c             	sub    $0xc,%esp
   14eae:	53                   	push   %ebx
   14eaf:	e8 02 fe ff ff       	call   14cb6 <Make_Runnable_Atomic>
   14eb4:	83 c4 10             	add    $0x10,%esp
}
   14eb7:	89 d8                	mov    %ebx,%eax
   14eb9:	83 c4 04             	add    $0x4,%esp
   14ebc:	5b                   	pop    %ebx
   14ebd:	5e                   	pop    %esi
   14ebe:	c3                   	ret    

00014ebf <Init_Scheduler>:
{
   14ebf:	57                   	push   %edi
   14ec0:	53                   	push   %ebx
   14ec1:	83 ec 04             	sub    $0x4,%esp
   14ec4:	e8 49 b3 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   14ec9:	81 c3 37 11 01 00    	add    $0x11137,%ebx
    memset(kthread, '\0', sizeof(*kthread));
   14ecf:	ba 00 00 10 00       	mov    $0x100000,%edx
   14ed4:	b9 90 00 00 00       	mov    $0x90,%ecx
   14ed9:	b8 00 00 00 00       	mov    $0x0,%eax
   14ede:	89 d7                	mov    %edx,%edi
   14ee0:	f3 ab                	rep stos %eax,%es:(%edi)
    kthread->stackPage = stackPage;
   14ee2:	c7 05 14 00 10 00 00 	movl   $0x101000,0x100014
   14ee9:	10 10 00 
    kthread->esp = ((ulong_t) kthread->stackPage) + PAGE_SIZE;
   14eec:	c7 05 00 00 10 00 00 	movl   $0x102000,0x100000
   14ef3:	20 10 00 
    kthread->numTicks = 0;
   14ef6:	c7 05 04 00 10 00 00 	movl   $0x0,0x100004
   14efd:	00 00 00 
    kthread->priority = priority;
   14f00:	c7 05 08 00 10 00 05 	movl   $0x5,0x100008
   14f07:	00 00 00 
    kthread->owner = owner;
   14f0a:	c7 05 1c 00 10 00 00 	movl   $0x0,0x10001c
   14f11:	00 00 00 
    kthread->refCount = detached ? 1 : 2;
   14f14:	c7 05 20 00 10 00 01 	movl   $0x1,0x100020
   14f1b:	00 00 00 
    kthread->alive = true;
   14f1e:	c6 05 24 00 10 00 01 	movb   $0x1,0x100024
    kthread->pid = nextFreePid++;
   14f25:	8b 83 40 00 00 00    	mov    0x40(%ebx),%eax
   14f2b:	8d 50 01             	lea    0x1(%eax),%edx
   14f2e:	89 93 40 00 00 00    	mov    %edx,0x40(%ebx)
   14f34:	a3 34 00 10 00       	mov    %eax,0x100034
    g_currentThread = mainThread;
   14f39:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14f3f:	c7 00 00 00 10 00    	movl   $0x100000,(%eax)
IMPLEMENT_LIST(All_Thread_List, Kernel_Thread);
   14f45:	8b 83 fc 12 00 00    	mov    0x12fc(%ebx),%eax
   14f4b:	85 c0                	test   %eax,%eax
   14f4d:	74 76                	je     14fc5 <Init_Scheduler+0x106>
   14f4f:	3d 00 00 10 00       	cmp    $0x100000,%eax
   14f54:	74 0e                	je     14f64 <Init_Scheduler+0xa5>
   14f56:	8b 40 3c             	mov    0x3c(%eax),%eax
   14f59:	85 c0                	test   %eax,%eax
   14f5b:	74 68                	je     14fc5 <Init_Scheduler+0x106>
   14f5d:	3d 00 00 10 00       	cmp    $0x100000,%eax
   14f62:	75 f2                	jne    14f56 <Init_Scheduler+0x97>
   14f64:	83 ec 0c             	sub    $0xc,%esp
   14f67:	6a 4f                	push   $0x4f
   14f69:	e8 bb c1 ff ff       	call   11129 <Set_Current_Attr>
   14f6e:	83 c4 0c             	add    $0xc,%esp
   14f71:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   14f77:	ff 30                	pushl  (%eax)
   14f79:	ff 74 24 14          	pushl  0x14(%esp)
   14f7d:	6a 45                	push   $0x45
   14f7f:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   14f85:	50                   	push   %eax
   14f86:	8d 83 74 7f ff ff    	lea    -0x808c(%ebx),%eax
   14f8c:	50                   	push   %eax
   14f8d:	8d 83 e8 81 ff ff    	lea    -0x7e18(%ebx),%eax
   14f93:	50                   	push   %eax
   14f94:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   14f9a:	50                   	push   %eax
   14f9b:	e8 3a c0 ff ff       	call   10fda <Print>
   14fa0:	83 c4 20             	add    $0x20,%esp
   14fa3:	eb fe                	jmp    14fa3 <Init_Scheduler+0xe4>
   14fa5:	c7 83 00 13 00 00 00 	movl   $0x100000,0x1300(%ebx)
   14fac:	00 10 00 
   14faf:	c7 83 fc 12 00 00 00 	movl   $0x100000,0x12fc(%ebx)
   14fb6:	00 10 00 
   14fb9:	c7 05 38 00 10 00 00 	movl   $0x0,0x100038
   14fc0:	00 00 00 
   14fc3:	eb 2a                	jmp    14fef <Init_Scheduler+0x130>
   14fc5:	c7 05 3c 00 10 00 00 	movl   $0x0,0x10003c
   14fcc:	00 00 00 
   14fcf:	8b 83 00 13 00 00    	mov    0x1300(%ebx),%eax
   14fd5:	85 c0                	test   %eax,%eax
   14fd7:	74 cc                	je     14fa5 <Init_Scheduler+0xe6>
   14fd9:	c7 40 3c 00 00 10 00 	movl   $0x100000,0x3c(%eax)
   14fe0:	a3 38 00 10 00       	mov    %eax,0x100038
   14fe5:	c7 83 00 13 00 00 00 	movl   $0x100000,0x1300(%ebx)
   14fec:	00 10 00 
    Start_Kernel_Thread(Idle, 0, PRIORITY_IDLE, true);
   14fef:	6a 01                	push   $0x1
   14ff1:	6a 00                	push   $0x0
   14ff3:	6a 00                	push   $0x0
   14ff5:	8d 83 04 f3 fe ff    	lea    -0x10cfc(%ebx),%eax
   14ffb:	50                   	push   %eax
   14ffc:	e8 74 fd ff ff       	call   14d75 <Start_Kernel_Thread>
    Start_Kernel_Thread(Reaper, 0, PRIORITY_NORMAL, true);
   15001:	6a 01                	push   $0x1
   15003:	6a 05                	push   $0x5
   15005:	6a 00                	push   $0x0
   15007:	8d 83 45 f5 fe ff    	lea    -0x10abb(%ebx),%eax
   1500d:	50                   	push   %eax
   1500e:	e8 62 fd ff ff       	call   14d75 <Start_Kernel_Thread>
}
   15013:	83 c4 24             	add    $0x24,%esp
   15016:	5b                   	pop    %ebx
   15017:	5f                   	pop    %edi
   15018:	c3                   	ret    

00015019 <Start_User_Thread>:
{
   15019:	56                   	push   %esi
   1501a:	53                   	push   %ebx
   1501b:	83 ec 04             	sub    $0x4,%esp
   1501e:	8b 74 24 10          	mov    0x10(%esp),%esi
   15022:	8b 54 24 14          	mov    0x14(%esp),%edx
    if (userContext == NULL) {
   15026:	85 f6                	test   %esi,%esi
   15028:	74 30                	je     1505a <Start_User_Thread+0x41>
    struct Kernel_Thread* thread = Create_Thread(PRIORITY_NORMAL, detached);
   1502a:	0f b6 d2             	movzbl %dl,%edx
   1502d:	b8 05 00 00 00       	mov    $0x5,%eax
   15032:	e8 e0 f8 ff ff       	call   14917 <Create_Thread>
   15037:	89 c3                	mov    %eax,%ebx
    if (thread == NULL) {
   15039:	85 c0                	test   %eax,%eax
   1503b:	74 15                	je     15052 <Start_User_Thread+0x39>
    Setup_User_Thread(thread, userContext);
   1503d:	83 ec 08             	sub    $0x8,%esp
   15040:	56                   	push   %esi
   15041:	50                   	push   %eax
   15042:	e8 5c fa ff ff       	call   14aa3 <Setup_User_Thread>
    Make_Runnable_Atomic(thread);
   15047:	89 1c 24             	mov    %ebx,(%esp)
   1504a:	e8 67 fc ff ff       	call   14cb6 <Make_Runnable_Atomic>
    return thread;
   1504f:	83 c4 10             	add    $0x10,%esp
}
   15052:	89 d8                	mov    %ebx,%eax
   15054:	83 c4 04             	add    $0x4,%esp
   15057:	5b                   	pop    %ebx
   15058:	5e                   	pop    %esi
   15059:	c3                   	ret    
        return NULL;
   1505a:	89 f3                	mov    %esi,%ebx
   1505c:	eb f4                	jmp    15052 <Start_User_Thread+0x39>

0001505e <Get_Current>:

/*
 * Get the thread that currently has the CPU.
 */
struct Kernel_Thread* Get_Current(void)
{
   1505e:	e8 63 b8 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   15063:	05 9d 0f 01 00       	add    $0x10f9d,%eax
    return g_currentThread;
   15068:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1506e:	8b 00                	mov    (%eax),%eax
}
   15070:	c3                   	ret    

00015071 <Get_Next_Runnable>:
/*
 * Get the next runnable thread from the run queue.
 * This is the scheduler.
 */
struct Kernel_Thread* Get_Next_Runnable(void)
{
   15071:	56                   	push   %esi
   15072:	53                   	push   %ebx
   15073:	83 ec 04             	sub    $0x4,%esp
   15076:	e8 97 b1 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1507b:	81 c3 85 0f 01 00    	add    $0x10f85,%ebx
    struct Kernel_Thread *kthread = queue->head, *best = 0;
   15081:	8b 8b f4 12 00 00    	mov    0x12f4(%ebx),%ecx
   15087:	89 ca                	mov    %ecx,%edx
   15089:	89 c8                	mov    %ecx,%eax
    while (kthread != 0) {
   1508b:	85 c9                	test   %ecx,%ecx
   1508d:	75 46                	jne    150d5 <Get_Next_Runnable+0x64>
    struct Kernel_Thread* best = 0;

    best = Find_Best(&s_runQueue);
    KASSERT(best != 0);
   1508f:	83 ec 0c             	sub    $0xc,%esp
   15092:	6a 4f                	push   $0x4f
   15094:	e8 90 c0 ff ff       	call   11129 <Set_Current_Attr>
   15099:	83 c4 0c             	add    $0xc,%esp
   1509c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   150a2:	ff 30                	pushl  (%eax)
   150a4:	ff 74 24 14          	pushl  0x14(%esp)
   150a8:	68 53 02 00 00       	push   $0x253
   150ad:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   150b3:	50                   	push   %eax
   150b4:	8d 83 e3 7e ff ff    	lea    -0x811d(%ebx),%eax
   150ba:	50                   	push   %eax
   150bb:	8d 83 80 81 ff ff    	lea    -0x7e80(%ebx),%eax
   150c1:	50                   	push   %eax
   150c2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   150c8:	50                   	push   %eax
   150c9:	e8 0c bf ff ff       	call   10fda <Print>
   150ce:	83 c4 20             	add    $0x20,%esp
   150d1:	eb fe                	jmp    150d1 <Get_Next_Runnable+0x60>
	kthread = Get_Next_In_Thread_Queue(kthread);
   150d3:	89 d0                	mov    %edx,%eax
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   150d5:	8b 52 10             	mov    0x10(%edx),%edx
    while (kthread != 0) {
   150d8:	85 d2                	test   %edx,%edx
   150da:	74 66                	je     15142 <Get_Next_Runnable+0xd1>
	if (best == 0 || kthread->priority > best->priority)
   150dc:	85 c0                	test   %eax,%eax
   150de:	74 f3                	je     150d3 <Get_Next_Runnable+0x62>
	kthread = Get_Next_In_Thread_Queue(kthread);
   150e0:	8b 70 08             	mov    0x8(%eax),%esi
   150e3:	39 72 08             	cmp    %esi,0x8(%edx)
   150e6:	0f 4f c2             	cmovg  %edx,%eax
   150e9:	eb ea                	jmp    150d5 <Get_Next_Runnable+0x64>
   150eb:	8b 50 10             	mov    0x10(%eax),%edx
   150ee:	89 93 f4 12 00 00    	mov    %edx,0x12f4(%ebx)
   150f4:	eb 70                	jmp    15166 <Get_Next_Runnable+0xf5>
   150f6:	8b 50 0c             	mov    0xc(%eax),%edx
   150f9:	89 93 f8 12 00 00    	mov    %edx,0x12f8(%ebx)
    Remove_Thread(&s_runQueue, best);

/*
 *    Print("Scheduling %x\n", best);
 */
    return best;
   150ff:	eb 72                	jmp    15173 <Get_Next_Runnable+0x102>
   15101:	83 ec 0c             	sub    $0xc,%esp
   15104:	6a 4f                	push   $0x4f
   15106:	e8 1e c0 ff ff       	call   11129 <Set_Current_Attr>
   1510b:	83 c4 0c             	add    $0xc,%esp
   1510e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15114:	ff 30                	pushl  (%eax)
   15116:	ff 74 24 14          	pushl  0x14(%esp)
   1511a:	6a 44                	push   $0x44
   1511c:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   15122:	50                   	push   %eax
   15123:	8d 83 d4 7f ff ff    	lea    -0x802c(%ebx),%eax
   15129:	50                   	push   %eax
   1512a:	8d 83 64 81 ff ff    	lea    -0x7e9c(%ebx),%eax
   15130:	50                   	push   %eax
   15131:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15137:	50                   	push   %eax
   15138:	e8 9d be ff ff       	call   10fda <Print>
   1513d:	83 c4 20             	add    $0x20,%esp
   15140:	eb fe                	jmp    15140 <Get_Next_Runnable+0xcf>
    KASSERT(best != 0);
   15142:	85 c0                	test   %eax,%eax
   15144:	0f 84 45 ff ff ff    	je     1508f <Get_Next_Runnable+0x1e>
   1514a:	39 c1                	cmp    %eax,%ecx
   1514c:	74 0b                	je     15159 <Get_Next_Runnable+0xe8>
   1514e:	8b 49 10             	mov    0x10(%ecx),%ecx
   15151:	85 c9                	test   %ecx,%ecx
   15153:	74 ac                	je     15101 <Get_Next_Runnable+0x90>
   15155:	39 c8                	cmp    %ecx,%eax
   15157:	75 f5                	jne    1514e <Get_Next_Runnable+0xdd>
   15159:	8b 50 0c             	mov    0xc(%eax),%edx
   1515c:	85 d2                	test   %edx,%edx
   1515e:	74 8b                	je     150eb <Get_Next_Runnable+0x7a>
   15160:	8b 48 10             	mov    0x10(%eax),%ecx
   15163:	89 4a 10             	mov    %ecx,0x10(%edx)
   15166:	8b 50 10             	mov    0x10(%eax),%edx
   15169:	85 d2                	test   %edx,%edx
   1516b:	74 89                	je     150f6 <Get_Next_Runnable+0x85>
   1516d:	8b 48 0c             	mov    0xc(%eax),%ecx
   15170:	89 4a 0c             	mov    %ecx,0xc(%edx)
}
   15173:	83 c4 04             	add    $0x4,%esp
   15176:	5b                   	pop    %ebx
   15177:	5e                   	pop    %esi
   15178:	c3                   	ret    

00015179 <Schedule>:
 * on whatever queue is appropriate (i.e., either the
 * run queue if it is still runnable, or a wait queue
 * if it is waiting for an event to occur).
 */
void Schedule(void)
{
   15179:	53                   	push   %ebx
   1517a:	83 ec 08             	sub    $0x8,%esp
   1517d:	e8 90 b0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15182:	81 c3 7e 0e 01 00    	add    $0x10e7e,%ebx
    struct Kernel_Thread* runnable;

    /* Make sure interrupts really are disabled */
    KASSERT(!Interrupts_Enabled());
   15188:	e8 bf b0 ff ff       	call   1024c <Interrupts_Enabled>
   1518d:	84 c0                	test   %al,%al
   1518f:	75 54                	jne    151e5 <Schedule+0x6c>

    /* Preemption should not be disabled. */
    KASSERT(!g_preemptionDisabled);
   15191:	c7 c0 8c 77 02 00    	mov    $0x2778c,%eax
   15197:	8b 00                	mov    (%eax),%eax
   15199:	85 c0                	test   %eax,%eax
   1519b:	0f 84 88 00 00 00    	je     15229 <Schedule+0xb0>
   151a1:	83 ec 0c             	sub    $0xc,%esp
   151a4:	6a 4f                	push   $0x4f
   151a6:	e8 7e bf ff ff       	call   11129 <Set_Current_Attr>
   151ab:	83 c4 0c             	add    $0xc,%esp
   151ae:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   151b4:	ff 30                	pushl  (%eax)
   151b6:	ff 74 24 14          	pushl  0x14(%esp)
   151ba:	68 6c 02 00 00       	push   $0x26c
   151bf:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   151c5:	50                   	push   %eax
   151c6:	8d 83 ed 7e ff ff    	lea    -0x8113(%ebx),%eax
   151cc:	50                   	push   %eax
   151cd:	8d 83 58 81 ff ff    	lea    -0x7ea8(%ebx),%eax
   151d3:	50                   	push   %eax
   151d4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   151da:	50                   	push   %eax
   151db:	e8 fa bd ff ff       	call   10fda <Print>
   151e0:	83 c4 20             	add    $0x20,%esp
   151e3:	eb fe                	jmp    151e3 <Schedule+0x6a>
    KASSERT(!Interrupts_Enabled());
   151e5:	83 ec 0c             	sub    $0xc,%esp
   151e8:	6a 4f                	push   $0x4f
   151ea:	e8 3a bf ff ff       	call   11129 <Set_Current_Attr>
   151ef:	83 c4 0c             	add    $0xc,%esp
   151f2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   151f8:	ff 30                	pushl  (%eax)
   151fa:	ff 74 24 14          	pushl  0x14(%esp)
   151fe:	68 69 02 00 00       	push   $0x269
   15203:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15209:	50                   	push   %eax
   1520a:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15210:	50                   	push   %eax
   15211:	8d 83 58 81 ff ff    	lea    -0x7ea8(%ebx),%eax
   15217:	50                   	push   %eax
   15218:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1521e:	50                   	push   %eax
   1521f:	e8 b6 bd ff ff       	call   10fda <Print>
   15224:	83 c4 20             	add    $0x20,%esp
   15227:	eb fe                	jmp    15227 <Schedule+0xae>

    /* Get next thread to run from the run queue */
    runnable = Get_Next_Runnable();
   15229:	e8 43 fe ff ff       	call   15071 <Get_Next_Runnable>
     * Activate the new thread, saving the context of the current thread.
     * Eventually, this thread will get re-activated and Switch_To_Thread()
     * will "return", and then Schedule() will return to wherever
     * it was called from.
     */
    Switch_To_Thread(runnable);
   1522e:	83 ec 0c             	sub    $0xc,%esp
   15231:	50                   	push   %eax
   15232:	e8 59 5c 00 00       	call   1ae90 <Switch_To_Thread>
}
   15237:	83 c4 18             	add    $0x18,%esp
   1523a:	5b                   	pop    %ebx
   1523b:	c3                   	ret    

0001523c <Yield>:
/*
 * Voluntarily give up the CPU to another thread.
 * Does nothing if no other threads are ready to run.
 */
void Yield(void)
{
   1523c:	53                   	push   %ebx
   1523d:	83 ec 08             	sub    $0x8,%esp
   15240:	e8 cd af ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15245:	81 c3 bb 0d 01 00    	add    $0x10dbb,%ebx
    Disable_Interrupts();
   1524b:	e8 fc af ff ff       	call   1024c <Interrupts_Enabled>
   15250:	84 c0                	test   %al,%al
   15252:	75 44                	jne    15298 <Yield+0x5c>
   15254:	83 ec 0c             	sub    $0xc,%esp
   15257:	6a 4f                	push   $0x4f
   15259:	e8 cb be ff ff       	call   11129 <Set_Current_Attr>
   1525e:	83 c4 0c             	add    $0xc,%esp
   15261:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15267:	ff 30                	pushl  (%eax)
   15269:	ff 74 24 14          	pushl  0x14(%esp)
   1526d:	68 80 02 00 00       	push   $0x280
   15272:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15278:	50                   	push   %eax
   15279:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1527f:	50                   	push   %eax
   15280:	8d 83 50 81 ff ff    	lea    -0x7eb0(%ebx),%eax
   15286:	50                   	push   %eax
   15287:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1528d:	50                   	push   %eax
   1528e:	e8 47 bd ff ff       	call   10fda <Print>
   15293:	83 c4 20             	add    $0x20,%esp
   15296:	eb fe                	jmp    15296 <Yield+0x5a>
    __asm__ __volatile__ ("cli");
   15298:	fa                   	cli    
    Make_Runnable(g_currentThread);
   15299:	83 ec 0c             	sub    $0xc,%esp
   1529c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   152a2:	ff 30                	pushl  (%eax)
   152a4:	e8 1a f9 ff ff       	call   14bc3 <Make_Runnable>
    Schedule();
   152a9:	e8 cb fe ff ff       	call   15179 <Schedule>
    Enable_Interrupts();
   152ae:	e8 99 af ff ff       	call   1024c <Interrupts_Enabled>
   152b3:	83 c4 10             	add    $0x10,%esp
   152b6:	84 c0                	test   %al,%al
   152b8:	75 06                	jne    152c0 <Yield+0x84>
    __asm__ __volatile__ ("sti");
   152ba:	fb                   	sti    
}
   152bb:	83 c4 08             	add    $0x8,%esp
   152be:	5b                   	pop    %ebx
   152bf:	c3                   	ret    
    Enable_Interrupts();
   152c0:	83 ec 0c             	sub    $0xc,%esp
   152c3:	6a 4f                	push   $0x4f
   152c5:	e8 5f be ff ff       	call   11129 <Set_Current_Attr>
   152ca:	83 c4 0c             	add    $0xc,%esp
   152cd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   152d3:	ff 30                	pushl  (%eax)
   152d5:	ff 74 24 14          	pushl  0x14(%esp)
   152d9:	68 83 02 00 00       	push   $0x283
   152de:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   152e4:	50                   	push   %eax
   152e5:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   152eb:	50                   	push   %eax
   152ec:	8d 83 50 81 ff ff    	lea    -0x7eb0(%ebx),%eax
   152f2:	50                   	push   %eax
   152f3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   152f9:	50                   	push   %eax
   152fa:	e8 db bc ff ff       	call   10fda <Print>
   152ff:	83 c4 20             	add    $0x20,%esp
   15302:	eb fe                	jmp    15302 <Yield+0xc6>

00015304 <Idle>:
{
   15304:	83 ec 0c             	sub    $0xc,%esp
	Yield();
   15307:	e8 30 ff ff ff       	call   1523c <Yield>
    while (true)
   1530c:	eb f9                	jmp    15307 <Idle+0x3>

0001530e <Lookup_Thread>:
/*
 * Look up a thread by its process id.
 * The caller must be the thread's owner.
 */
struct Kernel_Thread* Lookup_Thread(int pid)
{
   1530e:	55                   	push   %ebp
   1530f:	57                   	push   %edi
   15310:	56                   	push   %esi
   15311:	53                   	push   %ebx
   15312:	83 ec 0c             	sub    $0xc,%esp
   15315:	e8 f8 ae ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1531a:	81 c3 e6 0c 01 00    	add    $0x10ce6,%ebx
   15320:	8b 7c 24 20          	mov    0x20(%esp),%edi
    bool enabled = Interrupts_Enabled();
   15324:	e8 23 af ff ff       	call   1024c <Interrupts_Enabled>
   15329:	89 c5                	mov    %eax,%ebp
    if (enabled)
   1532b:	84 c0                	test   %al,%al
   1532d:	75 18                	jne    15347 <Lookup_Thread+0x39>
IMPLEMENT_LIST(All_Thread_List, Kernel_Thread);
   1532f:	8b b3 fc 12 00 00    	mov    0x12fc(%ebx),%esi
     * needs to be the thread's owner by specifying that another
     * reference is added to the thread before it is returned.
     */

    result = Get_Front_Of_All_Thread_List(&s_allThreadList);
    while (result != 0) {
   15335:	85 f6                	test   %esi,%esi
   15337:	74 71                	je     153aa <Lookup_Thread+0x9c>
	if (result->pid == pid) {
   15339:	39 7e 34             	cmp    %edi,0x34(%esi)
   1533c:	74 59                	je     15397 <Lookup_Thread+0x89>
   1533e:	8b 76 3c             	mov    0x3c(%esi),%esi
    while (result != 0) {
   15341:	85 f6                	test   %esi,%esi
   15343:	75 f4                	jne    15339 <Lookup_Thread+0x2b>
   15345:	eb 63                	jmp    153aa <Lookup_Thread+0x9c>
	Disable_Interrupts();
   15347:	e8 00 af ff ff       	call   1024c <Interrupts_Enabled>
   1534c:	84 c0                	test   %al,%al
   1534e:	74 03                	je     15353 <Lookup_Thread+0x45>
    __asm__ __volatile__ ("cli");
   15350:	fa                   	cli    
}
   15351:	eb dc                	jmp    1532f <Lookup_Thread+0x21>
	Disable_Interrupts();
   15353:	83 ec 0c             	sub    $0xc,%esp
   15356:	6a 4f                	push   $0x4f
   15358:	e8 cc bd ff ff       	call   11129 <Set_Current_Attr>
   1535d:	83 c4 0c             	add    $0xc,%esp
   15360:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15366:	ff 30                	pushl  (%eax)
   15368:	ff 74 24 24          	pushl  0x24(%esp)
   1536c:	68 8f 00 00 00       	push   $0x8f
   15371:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   15377:	50                   	push   %eax
   15378:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1537e:	50                   	push   %eax
   1537f:	8d 83 04 81 ff ff    	lea    -0x7efc(%ebx),%eax
   15385:	50                   	push   %eax
   15386:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1538c:	50                   	push   %eax
   1538d:	e8 48 bc ff ff       	call   10fda <Print>
   15392:	83 c4 20             	add    $0x20,%esp
   15395:	eb fe                	jmp    15395 <Lookup_Thread+0x87>
	    if (g_currentThread != result->owner)
		result = 0;
   15397:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1539d:	8b 00                	mov    (%eax),%eax
   1539f:	39 46 1c             	cmp    %eax,0x1c(%esi)
   153a2:	b8 00 00 00 00       	mov    $0x0,%eax
   153a7:	0f 45 f0             	cmovne %eax,%esi
    KASSERT(!Interrupts_Enabled());
   153aa:	e8 9d ae ff ff       	call   1024c <Interrupts_Enabled>
   153af:	84 c0                	test   %al,%al
   153b1:	75 10                	jne    153c3 <Lookup_Thread+0xb5>
    if (iflag) {
   153b3:	89 e8                	mov    %ebp,%eax
   153b5:	84 c0                	test   %al,%al
   153b7:	75 4e                	jne    15407 <Lookup_Thread+0xf9>
    }

    End_Int_Atomic(iflag);

    return result;
}
   153b9:	89 f0                	mov    %esi,%eax
   153bb:	83 c4 0c             	add    $0xc,%esp
   153be:	5b                   	pop    %ebx
   153bf:	5e                   	pop    %esi
   153c0:	5f                   	pop    %edi
   153c1:	5d                   	pop    %ebp
   153c2:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   153c3:	83 ec 0c             	sub    $0xc,%esp
   153c6:	6a 4f                	push   $0x4f
   153c8:	e8 5c bd ff ff       	call   11129 <Set_Current_Attr>
   153cd:	83 c4 0c             	add    $0xc,%esp
   153d0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   153d6:	ff 30                	pushl  (%eax)
   153d8:	ff 74 24 24          	pushl  0x24(%esp)
   153dc:	68 99 00 00 00       	push   $0x99
   153e1:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   153e7:	50                   	push   %eax
   153e8:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   153ee:	50                   	push   %eax
   153ef:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   153f5:	50                   	push   %eax
   153f6:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   153fc:	50                   	push   %eax
   153fd:	e8 d8 bb ff ff       	call   10fda <Print>
   15402:	83 c4 20             	add    $0x20,%esp
   15405:	eb fe                	jmp    15405 <Lookup_Thread+0xf7>
	Enable_Interrupts();
   15407:	e8 40 ae ff ff       	call   1024c <Interrupts_Enabled>
   1540c:	84 c0                	test   %al,%al
   1540e:	75 03                	jne    15413 <Lookup_Thread+0x105>
    __asm__ __volatile__ ("sti");
   15410:	fb                   	sti    
    return result;
   15411:	eb a6                	jmp    153b9 <Lookup_Thread+0xab>
	Enable_Interrupts();
   15413:	83 ec 0c             	sub    $0xc,%esp
   15416:	6a 4f                	push   $0x4f
   15418:	e8 0c bd ff ff       	call   11129 <Set_Current_Attr>
   1541d:	83 c4 0c             	add    $0xc,%esp
   15420:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15426:	ff 30                	pushl  (%eax)
   15428:	ff 74 24 24          	pushl  0x24(%esp)
   1542c:	68 9c 00 00 00       	push   $0x9c
   15431:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   15437:	50                   	push   %eax
   15438:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1543e:	50                   	push   %eax
   1543f:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   15445:	50                   	push   %eax
   15446:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1544c:	50                   	push   %eax
   1544d:	e8 88 bb ff ff       	call   10fda <Print>
   15452:	83 c4 20             	add    $0x20,%esp
   15455:	eb fe                	jmp    15455 <Lookup_Thread+0x147>

00015457 <Wait>:
 * and wait for it to be satisfied (if necessary).
 * See the Wait_For_Key() function in keyboard.c
 * for an example.
 */
void Wait(struct Thread_Queue* waitQueue)
{
   15457:	57                   	push   %edi
   15458:	56                   	push   %esi
   15459:	53                   	push   %ebx
   1545a:	e8 b3 ad ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1545f:	81 c3 a1 0b 01 00    	add    $0x10ba1,%ebx
   15465:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct Kernel_Thread* current = g_currentThread;
   15469:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1546f:	8b 30                	mov    (%eax),%esi

    KASSERT(!Interrupts_Enabled());
   15471:	e8 d6 ad ff ff       	call   1024c <Interrupts_Enabled>
   15476:	84 c0                	test   %al,%al
   15478:	74 44                	je     154be <Wait+0x67>
   1547a:	83 ec 0c             	sub    $0xc,%esp
   1547d:	6a 4f                	push   $0x4f
   1547f:	e8 a5 bc ff ff       	call   11129 <Set_Current_Attr>
   15484:	83 c4 0c             	add    $0xc,%esp
   15487:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1548d:	ff 30                	pushl  (%eax)
   1548f:	ff 74 24 14          	pushl  0x14(%esp)
   15493:	68 f7 02 00 00       	push   $0x2f7
   15498:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1549e:	50                   	push   %eax
   1549f:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   154a5:	50                   	push   %eax
   154a6:	8d 83 ec 80 ff ff    	lea    -0x7f14(%ebx),%eax
   154ac:	50                   	push   %eax
   154ad:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   154b3:	50                   	push   %eax
   154b4:	e8 21 bb ff ff       	call   10fda <Print>
   154b9:	83 c4 20             	add    $0x20,%esp
   154bc:	eb fe                	jmp    154bc <Wait+0x65>
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   154be:	8b 07                	mov    (%edi),%eax
   154c0:	85 c0                	test   %eax,%eax
   154c2:	74 5e                	je     15522 <Wait+0xcb>
   154c4:	39 c6                	cmp    %eax,%esi
   154c6:	74 0b                	je     154d3 <Wait+0x7c>
   154c8:	8b 40 10             	mov    0x10(%eax),%eax
   154cb:	85 c0                	test   %eax,%eax
   154cd:	74 53                	je     15522 <Wait+0xcb>
   154cf:	39 c6                	cmp    %eax,%esi
   154d1:	75 f5                	jne    154c8 <Wait+0x71>
   154d3:	83 ec 0c             	sub    $0xc,%esp
   154d6:	6a 4f                	push   $0x4f
   154d8:	e8 4c bc ff ff       	call   11129 <Set_Current_Attr>
   154dd:	83 c4 0c             	add    $0xc,%esp
   154e0:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   154e6:	ff 30                	pushl  (%eax)
   154e8:	ff 74 24 14          	pushl  0x14(%esp)
   154ec:	6a 44                	push   $0x44
   154ee:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   154f4:	50                   	push   %eax
   154f5:	8d 83 a4 7f ff ff    	lea    -0x805c(%ebx),%eax
   154fb:	50                   	push   %eax
   154fc:	8d 83 ac 81 ff ff    	lea    -0x7e54(%ebx),%eax
   15502:	50                   	push   %eax
   15503:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15509:	50                   	push   %eax
   1550a:	e8 cb ba ff ff       	call   10fda <Print>
   1550f:	83 c4 20             	add    $0x20,%esp
   15512:	eb fe                	jmp    15512 <Wait+0xbb>
   15514:	89 77 04             	mov    %esi,0x4(%edi)
   15517:	89 37                	mov    %esi,(%edi)
   15519:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
   15520:	eb 1a                	jmp    1553c <Wait+0xe5>
   15522:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
   15529:	8b 47 04             	mov    0x4(%edi),%eax
   1552c:	85 c0                	test   %eax,%eax
   1552e:	74 e4                	je     15514 <Wait+0xbd>
   15530:	89 70 10             	mov    %esi,0x10(%eax)
   15533:	8b 47 04             	mov    0x4(%edi),%eax
   15536:	89 46 0c             	mov    %eax,0xc(%esi)
   15539:	89 77 04             	mov    %esi,0x4(%edi)

    /* Add the thread to the wait queue. */
    Enqueue_Thread(waitQueue, current);

    /* Find another thread to run. */
    Schedule();
   1553c:	e8 38 fc ff ff       	call   15179 <Schedule>
}
   15541:	5b                   	pop    %ebx
   15542:	5e                   	pop    %esi
   15543:	5f                   	pop    %edi
   15544:	c3                   	ret    

00015545 <Reaper>:
{
   15545:	55                   	push   %ebp
   15546:	57                   	push   %edi
   15547:	56                   	push   %esi
   15548:	53                   	push   %ebx
   15549:	83 ec 0c             	sub    $0xc,%esp
   1554c:	e8 c1 ac ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15551:	81 c3 af 0a 01 00    	add    $0x10aaf,%ebx
    Disable_Interrupts();
   15557:	e8 f0 ac ff ff       	call   1024c <Interrupts_Enabled>
   1555c:	84 c0                	test   %al,%al
   1555e:	74 1f                	je     1557f <Reaper+0x3a>
    __asm__ __volatile__ ("cli");
   15560:	fa                   	cli    
	    Wait(&s_reaperWaitQueue);
   15561:	8d ab e4 12 00 00    	lea    0x12e4(%ebx),%ebp
	if ((kthread = s_graveyardQueue.head) == 0) {
   15567:	8b bb ec 12 00 00    	mov    0x12ec(%ebx),%edi
   1556d:	85 ff                	test   %edi,%edi
   1556f:	75 52                	jne    155c3 <Reaper+0x7e>
	    Wait(&s_reaperWaitQueue);
   15571:	83 ec 0c             	sub    $0xc,%esp
   15574:	55                   	push   %ebp
   15575:	e8 dd fe ff ff       	call   15457 <Wait>
   1557a:	83 c4 10             	add    $0x10,%esp
   1557d:	eb e8                	jmp    15567 <Reaper+0x22>
    Disable_Interrupts();
   1557f:	83 ec 0c             	sub    $0xc,%esp
   15582:	6a 4f                	push   $0x4f
   15584:	e8 a0 bb ff ff       	call   11129 <Set_Current_Attr>
   15589:	83 c4 0c             	add    $0xc,%esp
   1558c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15592:	ff 30                	pushl  (%eax)
   15594:	ff 74 24 24          	pushl  0x24(%esp)
   15598:	68 6b 01 00 00       	push   $0x16b
   1559d:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   155a3:	50                   	push   %eax
   155a4:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   155aa:	50                   	push   %eax
   155ab:	8d 83 34 82 ff ff    	lea    -0x7dcc(%ebx),%eax
   155b1:	50                   	push   %eax
   155b2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   155b8:	50                   	push   %eax
   155b9:	e8 1c ba ff ff       	call   10fda <Print>
   155be:	83 c4 20             	add    $0x20,%esp
   155c1:	eb fe                	jmp    155c1 <Reaper+0x7c>
   155c3:	c7 83 f0 12 00 00 00 	movl   $0x0,0x12f0(%ebx)
   155ca:	00 00 00 
   155cd:	c7 83 ec 12 00 00 00 	movl   $0x0,0x12ec(%ebx)
   155d4:	00 00 00 
	    Enable_Interrupts();
   155d7:	e8 70 ac ff ff       	call   1024c <Interrupts_Enabled>
   155dc:	84 c0                	test   %al,%al
   155de:	75 5c                	jne    1563c <Reaper+0xf7>
    __asm__ __volatile__ ("sti");
   155e0:	fb                   	sti    
	    Yield();   /* allow other threads to run? */
   155e1:	e8 56 fc ff ff       	call   1523c <Yield>
   155e6:	89 fe                	mov    %edi,%esi
   155e8:	8b 7f 10             	mov    0x10(%edi),%edi
    Disable_Interrupts();
   155eb:	e8 5c ac ff ff       	call   1024c <Interrupts_Enabled>
   155f0:	84 c0                	test   %al,%al
   155f2:	0f 85 88 00 00 00    	jne    15680 <Reaper+0x13b>
   155f8:	83 ec 0c             	sub    $0xc,%esp
   155fb:	6a 4f                	push   $0x4f
   155fd:	e8 27 bb ff ff       	call   11129 <Set_Current_Attr>
   15602:	83 c4 0c             	add    $0xc,%esp
   15605:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1560b:	ff 30                	pushl  (%eax)
   1560d:	ff 74 24 24          	pushl  0x24(%esp)
   15611:	68 a6 00 00 00       	push   $0xa6
   15616:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1561c:	50                   	push   %eax
   1561d:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15623:	50                   	push   %eax
   15624:	8d 83 24 82 ff ff    	lea    -0x7ddc(%ebx),%eax
   1562a:	50                   	push   %eax
   1562b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15631:	50                   	push   %eax
   15632:	e8 a3 b9 ff ff       	call   10fda <Print>
   15637:	83 c4 20             	add    $0x20,%esp
   1563a:	eb fe                	jmp    1563a <Reaper+0xf5>
	    Enable_Interrupts();
   1563c:	83 ec 0c             	sub    $0xc,%esp
   1563f:	6a 4f                	push   $0x4f
   15641:	e8 e3 ba ff ff       	call   11129 <Set_Current_Attr>
   15646:	83 c4 0c             	add    $0xc,%esp
   15649:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1564f:	ff 30                	pushl  (%eax)
   15651:	ff 74 24 24          	pushl  0x24(%esp)
   15655:	68 7b 01 00 00       	push   $0x17b
   1565a:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15660:	50                   	push   %eax
   15661:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15667:	50                   	push   %eax
   15668:	8d 83 34 82 ff ff    	lea    -0x7dcc(%ebx),%eax
   1566e:	50                   	push   %eax
   1566f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15675:	50                   	push   %eax
   15676:	e8 5f b9 ff ff       	call   10fda <Print>
   1567b:	83 c4 20             	add    $0x20,%esp
   1567e:	eb fe                	jmp    1567e <Reaper+0x139>
    __asm__ __volatile__ ("cli");
   15680:	fa                   	cli    
    Free_Page(kthread->stackPage);
   15681:	83 ec 0c             	sub    $0xc,%esp
   15684:	ff 76 14             	pushl  0x14(%esi)
   15687:	e8 73 d1 ff ff       	call   127ff <Free_Page>
    Free_Page(kthread);
   1568c:	89 34 24             	mov    %esi,(%esp)
   1568f:	e8 6b d1 ff ff       	call   127ff <Free_Page>
IMPLEMENT_LIST(All_Thread_List, Kernel_Thread);
   15694:	8b 83 fc 12 00 00    	mov    0x12fc(%ebx),%eax
   1569a:	83 c4 10             	add    $0x10,%esp
   1569d:	85 c0                	test   %eax,%eax
   1569f:	0f 84 ec 00 00 00    	je     15791 <Reaper+0x24c>
   156a5:	39 f0                	cmp    %esi,%eax
   156a7:	74 0f                	je     156b8 <Reaper+0x173>
   156a9:	8b 40 3c             	mov    0x3c(%eax),%eax
   156ac:	85 c0                	test   %eax,%eax
   156ae:	0f 84 dd 00 00 00    	je     15791 <Reaper+0x24c>
   156b4:	39 f0                	cmp    %esi,%eax
   156b6:	75 f1                	jne    156a9 <Reaper+0x164>
   156b8:	8b 46 38             	mov    0x38(%esi),%eax
   156bb:	85 c0                	test   %eax,%eax
   156bd:	74 34                	je     156f3 <Reaper+0x1ae>
   156bf:	8b 56 3c             	mov    0x3c(%esi),%edx
   156c2:	89 50 3c             	mov    %edx,0x3c(%eax)
   156c5:	8b 46 3c             	mov    0x3c(%esi),%eax
   156c8:	85 c0                	test   %eax,%eax
   156ca:	74 32                	je     156fe <Reaper+0x1b9>
   156cc:	8b 56 38             	mov    0x38(%esi),%edx
   156cf:	89 50 38             	mov    %edx,0x38(%eax)
    Enable_Interrupts();
   156d2:	e8 75 ab ff ff       	call   1024c <Interrupts_Enabled>
   156d7:	84 c0                	test   %al,%al
   156d9:	75 2e                	jne    15709 <Reaper+0x1c4>
    __asm__ __volatile__ ("sti");
   156db:	fb                   	sti    
	    while (kthread != 0) {
   156dc:	85 ff                	test   %edi,%edi
   156de:	0f 85 02 ff ff ff    	jne    155e6 <Reaper+0xa1>
	    Disable_Interrupts();
   156e4:	e8 63 ab ff ff       	call   1024c <Interrupts_Enabled>
   156e9:	84 c0                	test   %al,%al
   156eb:	74 60                	je     1574d <Reaper+0x208>
    __asm__ __volatile__ ("cli");
   156ed:	fa                   	cli    
}
   156ee:	e9 74 fe ff ff       	jmp    15567 <Reaper+0x22>
   156f3:	8b 46 3c             	mov    0x3c(%esi),%eax
   156f6:	89 83 fc 12 00 00    	mov    %eax,0x12fc(%ebx)
   156fc:	eb c7                	jmp    156c5 <Reaper+0x180>
   156fe:	8b 46 38             	mov    0x38(%esi),%eax
   15701:	89 83 00 13 00 00    	mov    %eax,0x1300(%ebx)
   15707:	eb c9                	jmp    156d2 <Reaper+0x18d>
    Enable_Interrupts();
   15709:	83 ec 0c             	sub    $0xc,%esp
   1570c:	6a 4f                	push   $0x4f
   1570e:	e8 16 ba ff ff       	call   11129 <Set_Current_Attr>
   15713:	83 c4 0c             	add    $0xc,%esp
   15716:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1571c:	ff 30                	pushl  (%eax)
   1571e:	ff 74 24 24          	pushl  0x24(%esp)
   15722:	68 ad 00 00 00       	push   $0xad
   15727:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1572d:	50                   	push   %eax
   1572e:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15734:	50                   	push   %eax
   15735:	8d 83 24 82 ff ff    	lea    -0x7ddc(%ebx),%eax
   1573b:	50                   	push   %eax
   1573c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15742:	50                   	push   %eax
   15743:	e8 92 b8 ff ff       	call   10fda <Print>
   15748:	83 c4 20             	add    $0x20,%esp
   1574b:	eb fe                	jmp    1574b <Reaper+0x206>
	    Disable_Interrupts();
   1574d:	83 ec 0c             	sub    $0xc,%esp
   15750:	6a 4f                	push   $0x4f
   15752:	e8 d2 b9 ff ff       	call   11129 <Set_Current_Attr>
   15757:	83 c4 0c             	add    $0xc,%esp
   1575a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15760:	ff 30                	pushl  (%eax)
   15762:	ff 74 24 24          	pushl  0x24(%esp)
   15766:	68 8d 01 00 00       	push   $0x18d
   1576b:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15771:	50                   	push   %eax
   15772:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15778:	50                   	push   %eax
   15779:	8d 83 34 82 ff ff    	lea    -0x7dcc(%ebx),%eax
   1577f:	50                   	push   %eax
   15780:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15786:	50                   	push   %eax
   15787:	e8 4e b8 ff ff       	call   10fda <Print>
   1578c:	83 c4 20             	add    $0x20,%esp
   1578f:	eb fe                	jmp    1578f <Reaper+0x24a>
   15791:	83 ec 0c             	sub    $0xc,%esp
   15794:	6a 4f                	push   $0x4f
   15796:	e8 8e b9 ff ff       	call   11129 <Set_Current_Attr>
   1579b:	83 c4 0c             	add    $0xc,%esp
   1579e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   157a4:	ff 30                	pushl  (%eax)
   157a6:	ff 74 24 24          	pushl  0x24(%esp)
   157aa:	6a 45                	push   $0x45
   157ac:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   157b2:	50                   	push   %eax
   157b3:	8d 83 00 80 ff ff    	lea    -0x8000(%ebx),%eax
   157b9:	50                   	push   %eax
   157ba:	8d 83 08 82 ff ff    	lea    -0x7df8(%ebx),%eax
   157c0:	50                   	push   %eax
   157c1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   157c7:	50                   	push   %eax
   157c8:	e8 0d b8 ff ff       	call   10fda <Print>
   157cd:	83 c4 20             	add    $0x20,%esp
   157d0:	eb fe                	jmp    157d0 <Reaper+0x28b>

000157d2 <Wake_Up>:
 * Must be called with interrupts disabled!
 * See Keyboard_Interrupt_Handler() function in keyboard.c
 * for an example.
 */
void Wake_Up(struct Thread_Queue* waitQueue)
{
   157d2:	57                   	push   %edi
   157d3:	56                   	push   %esi
   157d4:	53                   	push   %ebx
   157d5:	e8 38 aa ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   157da:	81 c3 26 08 01 00    	add    $0x10826,%ebx
   157e0:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct Kernel_Thread *kthread = waitQueue->head, *next;
   157e4:	8b 37                	mov    (%edi),%esi

    KASSERT(!Interrupts_Enabled());
   157e6:	e8 61 aa ff ff       	call   1024c <Interrupts_Enabled>
   157eb:	84 c0                	test   %al,%al
   157ed:	75 2a                	jne    15819 <Wake_Up+0x47>

    /*
     * Walk throught the list of threads in the wait queue,
     * transferring each one to the run queue.
     */
    while (kthread != 0) {
   157ef:	85 f6                	test   %esi,%esi
   157f1:	74 15                	je     15808 <Wake_Up+0x36>
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   157f3:	89 f0                	mov    %esi,%eax
   157f5:	8b 76 10             	mov    0x10(%esi),%esi
	next = Get_Next_In_Thread_Queue(kthread);
	Make_Runnable(kthread);
   157f8:	83 ec 0c             	sub    $0xc,%esp
   157fb:	50                   	push   %eax
   157fc:	e8 c2 f3 ff ff       	call   14bc3 <Make_Runnable>
    while (kthread != 0) {
   15801:	83 c4 10             	add    $0x10,%esp
   15804:	85 f6                	test   %esi,%esi
   15806:	75 eb                	jne    157f3 <Wake_Up+0x21>
   15808:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
   1580f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	kthread = next;
    }

    /* The wait queue is now empty. */
    Clear_Thread_Queue(waitQueue);
}
   15815:	5b                   	pop    %ebx
   15816:	5e                   	pop    %esi
   15817:	5f                   	pop    %edi
   15818:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   15819:	83 ec 0c             	sub    $0xc,%esp
   1581c:	6a 4f                	push   $0x4f
   1581e:	e8 06 b9 ff ff       	call   11129 <Set_Current_Attr>
   15823:	83 c4 0c             	add    $0xc,%esp
   15826:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1582c:	ff 30                	pushl  (%eax)
   1582e:	ff 74 24 14          	pushl  0x14(%esp)
   15832:	68 0a 03 00 00       	push   $0x30a
   15837:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1583d:	50                   	push   %eax
   1583e:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15844:	50                   	push   %eax
   15845:	8d 83 e4 80 ff ff    	lea    -0x7f1c(%ebx),%eax
   1584b:	50                   	push   %eax
   1584c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15852:	50                   	push   %eax
   15853:	e8 82 b7 ff ff       	call   10fda <Print>
   15858:	83 c4 20             	add    $0x20,%esp
   1585b:	eb fe                	jmp    1585b <Wake_Up+0x89>

0001585d <Detach_Thread>:
{
   1585d:	56                   	push   %esi
   1585e:	53                   	push   %ebx
   1585f:	83 ec 04             	sub    $0x4,%esp
   15862:	e8 ab a9 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15867:	81 c3 99 07 01 00    	add    $0x10799,%ebx
   1586d:	89 c6                	mov    %eax,%esi
    KASSERT(!Interrupts_Enabled());
   1586f:	e8 d8 a9 ff ff       	call   1024c <Interrupts_Enabled>
   15874:	84 c0                	test   %al,%al
   15876:	75 19                	jne    15891 <Detach_Thread+0x34>
    KASSERT(kthread->refCount > 0);
   15878:	8b 46 20             	mov    0x20(%esi),%eax
   1587b:	85 c0                	test   %eax,%eax
   1587d:	7e 56                	jle    158d5 <Detach_Thread+0x78>
    --kthread->refCount;
   1587f:	83 e8 01             	sub    $0x1,%eax
   15882:	89 46 20             	mov    %eax,0x20(%esi)
    if (kthread->refCount == 0) {
   15885:	0f 84 8e 00 00 00    	je     15919 <Detach_Thread+0xbc>
}
   1588b:	83 c4 04             	add    $0x4,%esp
   1588e:	5b                   	pop    %ebx
   1588f:	5e                   	pop    %esi
   15890:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   15891:	83 ec 0c             	sub    $0xc,%esp
   15894:	6a 4f                	push   $0x4f
   15896:	e8 8e b8 ff ff       	call   11129 <Set_Current_Attr>
   1589b:	83 c4 0c             	add    $0xc,%esp
   1589e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   158a4:	ff 30                	pushl  (%eax)
   158a6:	ff 74 24 14          	pushl  0x14(%esp)
   158aa:	68 c1 00 00 00       	push   $0xc1
   158af:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   158b5:	50                   	push   %eax
   158b6:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   158bc:	50                   	push   %eax
   158bd:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
   158c3:	50                   	push   %eax
   158c4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   158ca:	50                   	push   %eax
   158cb:	e8 0a b7 ff ff       	call   10fda <Print>
   158d0:	83 c4 20             	add    $0x20,%esp
   158d3:	eb fe                	jmp    158d3 <Detach_Thread+0x76>
    KASSERT(kthread->refCount > 0);
   158d5:	83 ec 0c             	sub    $0xc,%esp
   158d8:	6a 4f                	push   $0x4f
   158da:	e8 4a b8 ff ff       	call   11129 <Set_Current_Attr>
   158df:	83 c4 0c             	add    $0xc,%esp
   158e2:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   158e8:	ff 30                	pushl  (%eax)
   158ea:	ff 74 24 14          	pushl  0x14(%esp)
   158ee:	68 c2 00 00 00       	push   $0xc2
   158f3:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   158f9:	50                   	push   %eax
   158fa:	8d 83 03 7f ff ff    	lea    -0x80fd(%ebx),%eax
   15900:	50                   	push   %eax
   15901:	8d 83 2c 81 ff ff    	lea    -0x7ed4(%ebx),%eax
   15907:	50                   	push   %eax
   15908:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1590e:	50                   	push   %eax
   1590f:	e8 c6 b6 ff ff       	call   10fda <Print>
   15914:	83 c4 20             	add    $0x20,%esp
   15917:	eb fe                	jmp    15917 <Detach_Thread+0xba>
    KASSERT(!Interrupts_Enabled());
   15919:	e8 2e a9 ff ff       	call   1024c <Interrupts_Enabled>
   1591e:	84 c0                	test   %al,%al
   15920:	74 44                	je     15966 <Detach_Thread+0x109>
   15922:	83 ec 0c             	sub    $0xc,%esp
   15925:	6a 4f                	push   $0x4f
   15927:	e8 fd b7 ff ff       	call   11129 <Set_Current_Attr>
   1592c:	83 c4 0c             	add    $0xc,%esp
   1592f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15935:	ff 30                	pushl  (%eax)
   15937:	ff 74 24 14          	pushl  0x14(%esp)
   1593b:	68 b7 00 00 00       	push   $0xb7
   15940:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15946:	50                   	push   %eax
   15947:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1594d:	50                   	push   %eax
   1594e:	8d 83 20 81 ff ff    	lea    -0x7ee0(%ebx),%eax
   15954:	50                   	push   %eax
   15955:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1595b:	50                   	push   %eax
   1595c:	e8 79 b6 ff ff       	call   10fda <Print>
   15961:	83 c4 20             	add    $0x20,%esp
   15964:	eb fe                	jmp    15964 <Detach_Thread+0x107>
   15966:	8b 83 ec 12 00 00    	mov    0x12ec(%ebx),%eax
   1596c:	85 c0                	test   %eax,%eax
   1596e:	74 65                	je     159d5 <Detach_Thread+0x178>
   15970:	39 c6                	cmp    %eax,%esi
   15972:	74 0b                	je     1597f <Detach_Thread+0x122>
   15974:	8b 40 10             	mov    0x10(%eax),%eax
   15977:	85 c0                	test   %eax,%eax
   15979:	74 5a                	je     159d5 <Detach_Thread+0x178>
   1597b:	39 c6                	cmp    %eax,%esi
   1597d:	75 f5                	jne    15974 <Detach_Thread+0x117>
   1597f:	83 ec 0c             	sub    $0xc,%esp
   15982:	6a 4f                	push   $0x4f
   15984:	e8 a0 b7 ff ff       	call   11129 <Set_Current_Attr>
   15989:	83 c4 0c             	add    $0xc,%esp
   1598c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15992:	ff 30                	pushl  (%eax)
   15994:	ff 74 24 14          	pushl  0x14(%esp)
   15998:	6a 44                	push   $0x44
   1599a:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   159a0:	50                   	push   %eax
   159a1:	8d 83 a4 7f ff ff    	lea    -0x805c(%ebx),%eax
   159a7:	50                   	push   %eax
   159a8:	8d 83 ac 81 ff ff    	lea    -0x7e54(%ebx),%eax
   159ae:	50                   	push   %eax
   159af:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   159b5:	50                   	push   %eax
   159b6:	e8 1f b6 ff ff       	call   10fda <Print>
   159bb:	83 c4 20             	add    $0x20,%esp
   159be:	eb fe                	jmp    159be <Detach_Thread+0x161>
   159c0:	89 b3 f0 12 00 00    	mov    %esi,0x12f0(%ebx)
   159c6:	89 b3 ec 12 00 00    	mov    %esi,0x12ec(%ebx)
   159cc:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
   159d3:	eb 1d                	jmp    159f2 <Detach_Thread+0x195>
   159d5:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
   159dc:	8b 83 f0 12 00 00    	mov    0x12f0(%ebx),%eax
   159e2:	85 c0                	test   %eax,%eax
   159e4:	74 da                	je     159c0 <Detach_Thread+0x163>
   159e6:	89 70 10             	mov    %esi,0x10(%eax)
   159e9:	89 46 0c             	mov    %eax,0xc(%esi)
   159ec:	89 b3 f0 12 00 00    	mov    %esi,0x12f0(%ebx)
    Wake_Up(&s_reaperWaitQueue);
   159f2:	83 ec 0c             	sub    $0xc,%esp
   159f5:	8d 83 e4 12 00 00    	lea    0x12e4(%ebx),%eax
   159fb:	50                   	push   %eax
   159fc:	e8 d1 fd ff ff       	call   157d2 <Wake_Up>
}
   15a01:	83 c4 10             	add    $0x10,%esp
}
   15a04:	e9 82 fe ff ff       	jmp    1588b <Detach_Thread+0x2e>

00015a09 <Join>:
{
   15a09:	57                   	push   %edi
   15a0a:	56                   	push   %esi
   15a0b:	53                   	push   %ebx
   15a0c:	e8 01 a8 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15a11:	81 c3 ef 05 01 00    	add    $0x105ef,%ebx
   15a17:	8b 74 24 10          	mov    0x10(%esp),%esi
    KASSERT(Interrupts_Enabled());
   15a1b:	e8 2c a8 ff ff       	call   1024c <Interrupts_Enabled>
   15a20:	84 c0                	test   %al,%al
   15a22:	74 55                	je     15a79 <Join+0x70>
    KASSERT(kthread->owner == g_currentThread);
   15a24:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15a2a:	8b 00                	mov    (%eax),%eax
   15a2c:	39 46 1c             	cmp    %eax,0x1c(%esi)
   15a2f:	0f 84 88 00 00 00    	je     15abd <Join+0xb4>
   15a35:	83 ec 0c             	sub    $0xc,%esp
   15a38:	6a 4f                	push   $0x4f
   15a3a:	e8 ea b6 ff ff       	call   11129 <Set_Current_Attr>
   15a3f:	83 c4 0c             	add    $0xc,%esp
   15a42:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15a48:	ff 30                	pushl  (%eax)
   15a4a:	ff 74 24 14          	pushl  0x14(%esp)
   15a4e:	68 b5 02 00 00       	push   $0x2b5
   15a53:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15a59:	50                   	push   %eax
   15a5a:	8d 83 30 80 ff ff    	lea    -0x7fd0(%ebx),%eax
   15a60:	50                   	push   %eax
   15a61:	8d 83 18 81 ff ff    	lea    -0x7ee8(%ebx),%eax
   15a67:	50                   	push   %eax
   15a68:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15a6e:	50                   	push   %eax
   15a6f:	e8 66 b5 ff ff       	call   10fda <Print>
   15a74:	83 c4 20             	add    $0x20,%esp
   15a77:	eb fe                	jmp    15a77 <Join+0x6e>
    KASSERT(Interrupts_Enabled());
   15a79:	83 ec 0c             	sub    $0xc,%esp
   15a7c:	6a 4f                	push   $0x4f
   15a7e:	e8 a6 b6 ff ff       	call   11129 <Set_Current_Attr>
   15a83:	83 c4 0c             	add    $0xc,%esp
   15a86:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15a8c:	ff 30                	pushl  (%eax)
   15a8e:	ff 74 24 14          	pushl  0x14(%esp)
   15a92:	68 b2 02 00 00       	push   $0x2b2
   15a97:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15a9d:	50                   	push   %eax
   15a9e:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15aa4:	50                   	push   %eax
   15aa5:	8d 83 18 81 ff ff    	lea    -0x7ee8(%ebx),%eax
   15aab:	50                   	push   %eax
   15aac:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15ab2:	50                   	push   %eax
   15ab3:	e8 22 b5 ff ff       	call   10fda <Print>
   15ab8:	83 c4 20             	add    $0x20,%esp
   15abb:	eb fe                	jmp    15abb <Join+0xb2>
    Disable_Interrupts();
   15abd:	e8 8a a7 ff ff       	call   1024c <Interrupts_Enabled>
   15ac2:	84 c0                	test   %al,%al
   15ac4:	74 36                	je     15afc <Join+0xf3>
    __asm__ __volatile__ ("cli");
   15ac6:	fa                   	cli    
    while (kthread->alive) {
   15ac7:	80 7e 24 00          	cmpb   $0x0,0x24(%esi)
   15acb:	74 15                	je     15ae2 <Join+0xd9>
	Wait(&kthread->joinQueue);
   15acd:	8d 7e 28             	lea    0x28(%esi),%edi
   15ad0:	83 ec 0c             	sub    $0xc,%esp
   15ad3:	57                   	push   %edi
   15ad4:	e8 7e f9 ff ff       	call   15457 <Wait>
    while (kthread->alive) {
   15ad9:	83 c4 10             	add    $0x10,%esp
   15adc:	80 7e 24 00          	cmpb   $0x0,0x24(%esi)
   15ae0:	75 ee                	jne    15ad0 <Join+0xc7>
    exitCode = kthread->exitCode;
   15ae2:	8b 7e 30             	mov    0x30(%esi),%edi
    Detach_Thread(kthread);
   15ae5:	89 f0                	mov    %esi,%eax
   15ae7:	e8 71 fd ff ff       	call   1585d <Detach_Thread>
    Enable_Interrupts();
   15aec:	e8 5b a7 ff ff       	call   1024c <Interrupts_Enabled>
   15af1:	84 c0                	test   %al,%al
   15af3:	75 4b                	jne    15b40 <Join+0x137>
    __asm__ __volatile__ ("sti");
   15af5:	fb                   	sti    
}
   15af6:	89 f8                	mov    %edi,%eax
   15af8:	5b                   	pop    %ebx
   15af9:	5e                   	pop    %esi
   15afa:	5f                   	pop    %edi
   15afb:	c3                   	ret    
    Disable_Interrupts();
   15afc:	83 ec 0c             	sub    $0xc,%esp
   15aff:	6a 4f                	push   $0x4f
   15b01:	e8 23 b6 ff ff       	call   11129 <Set_Current_Attr>
   15b06:	83 c4 0c             	add    $0xc,%esp
   15b09:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15b0f:	ff 30                	pushl  (%eax)
   15b11:	ff 74 24 14          	pushl  0x14(%esp)
   15b15:	68 b7 02 00 00       	push   $0x2b7
   15b1a:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15b20:	50                   	push   %eax
   15b21:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15b27:	50                   	push   %eax
   15b28:	8d 83 18 81 ff ff    	lea    -0x7ee8(%ebx),%eax
   15b2e:	50                   	push   %eax
   15b2f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15b35:	50                   	push   %eax
   15b36:	e8 9f b4 ff ff       	call   10fda <Print>
   15b3b:	83 c4 20             	add    $0x20,%esp
   15b3e:	eb fe                	jmp    15b3e <Join+0x135>
    Enable_Interrupts();
   15b40:	83 ec 0c             	sub    $0xc,%esp
   15b43:	6a 4f                	push   $0x4f
   15b45:	e8 df b5 ff ff       	call   11129 <Set_Current_Attr>
   15b4a:	83 c4 0c             	add    $0xc,%esp
   15b4d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15b53:	ff 30                	pushl  (%eax)
   15b55:	ff 74 24 14          	pushl  0x14(%esp)
   15b59:	68 c4 02 00 00       	push   $0x2c4
   15b5e:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15b64:	50                   	push   %eax
   15b65:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15b6b:	50                   	push   %eax
   15b6c:	8d 83 18 81 ff ff    	lea    -0x7ee8(%ebx),%eax
   15b72:	50                   	push   %eax
   15b73:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15b79:	50                   	push   %eax
   15b7a:	e8 5b b4 ff ff       	call   10fda <Print>
   15b7f:	83 c4 20             	add    $0x20,%esp
   15b82:	eb fe                	jmp    15b82 <Join+0x179>

00015b84 <Exit>:
{
   15b84:	55                   	push   %ebp
   15b85:	57                   	push   %edi
   15b86:	56                   	push   %esi
   15b87:	53                   	push   %ebx
   15b88:	83 ec 2c             	sub    $0x2c,%esp
   15b8b:	e8 82 a6 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15b90:	81 c3 70 04 01 00    	add    $0x10470,%ebx
    struct Kernel_Thread* current = g_currentThread;
   15b96:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15b9c:	8b 28                	mov    (%eax),%ebp
    if (Interrupts_Enabled())
   15b9e:	e8 a9 a6 ff ff       	call   1024c <Interrupts_Enabled>
   15ba3:	84 c0                	test   %al,%al
   15ba5:	74 0a                	je     15bb1 <Exit+0x2d>
	Disable_Interrupts();
   15ba7:	e8 a0 a6 ff ff       	call   1024c <Interrupts_Enabled>
   15bac:	84 c0                	test   %al,%al
   15bae:	74 50                	je     15c00 <Exit+0x7c>
    __asm__ __volatile__ ("cli");
   15bb0:	fa                   	cli    
    current->exitCode = exitCode;
   15bb1:	8b 44 24 40          	mov    0x40(%esp),%eax
   15bb5:	89 45 30             	mov    %eax,0x30(%ebp)
    current->alive = false;
   15bb8:	c6 45 24 00          	movb   $0x0,0x24(%ebp)
    Tlocal_Exit(g_currentThread);
   15bbc:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15bc2:	8b 00                	mov    (%eax),%eax
   15bc4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    KASSERT(!Interrupts_Enabled());
   15bc8:	e8 7f a6 ff ff       	call   1024c <Interrupts_Enabled>
   15bcd:	89 c2                	mov    %eax,%edx
   15bcf:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
   15bd6:	00 
    int i, j, called = 0;
   15bd7:	b8 00 00 00 00       	mov    $0x0,%eax
    KASSERT(!Interrupts_Enabled());
   15bdc:	84 d2                	test   %dl,%dl
   15bde:	75 64                	jne    15c44 <Exit+0xc0>
   15be0:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
        for (i = 0; i<MAX_TLOCAL_KEYS; i++) {
   15be4:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   15be8:	8d 6f 40             	lea    0x40(%edi),%ebp
   15beb:	8d b3 e0 10 00 00    	lea    0x10e0(%ebx),%esi
   15bf1:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
   15bf7:	89 54 24 14          	mov    %edx,0x14(%esp)
   15bfb:	e9 de 00 00 00       	jmp    15cde <Exit+0x15a>
	Disable_Interrupts();
   15c00:	83 ec 0c             	sub    $0xc,%esp
   15c03:	6a 4f                	push   $0x4f
   15c05:	e8 1f b5 ff ff       	call   11129 <Set_Current_Attr>
   15c0a:	83 c4 0c             	add    $0xc,%esp
   15c0d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15c13:	ff 30                	pushl  (%eax)
   15c15:	ff 74 24 44          	pushl  0x44(%esp)
   15c19:	68 8f 02 00 00       	push   $0x28f
   15c1e:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15c24:	50                   	push   %eax
   15c25:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15c2b:	50                   	push   %eax
   15c2c:	8d 83 48 81 ff ff    	lea    -0x7eb8(%ebx),%eax
   15c32:	50                   	push   %eax
   15c33:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15c39:	50                   	push   %eax
   15c3a:	e8 9b b3 ff ff       	call   10fda <Print>
   15c3f:	83 c4 20             	add    $0x20,%esp
   15c42:	eb fe                	jmp    15c42 <Exit+0xbe>
    KASSERT(!Interrupts_Enabled());
   15c44:	83 ec 0c             	sub    $0xc,%esp
   15c47:	6a 4f                	push   $0x4f
   15c49:	e8 db b4 ff ff       	call   11129 <Set_Current_Attr>
   15c4e:	83 c4 0c             	add    $0xc,%esp
   15c51:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15c57:	ff 30                	pushl  (%eax)
   15c59:	ff 74 24 44          	pushl  0x44(%esp)
   15c5d:	68 ba 01 00 00       	push   $0x1ba
   15c62:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15c68:	50                   	push   %eax
   15c69:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15c6f:	50                   	push   %eax
   15c70:	8d 83 3c 81 ff ff    	lea    -0x7ec4(%ebx),%eax
   15c76:	50                   	push   %eax
   15c77:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15c7d:	50                   	push   %eax
   15c7e:	e8 57 b3 ff ff       	call   10fda <Print>
   15c83:	83 c4 20             	add    $0x20,%esp
   15c86:	eb fe                	jmp    15c86 <Exit+0x102>
		Enable_Interrupts();
   15c88:	83 ec 0c             	sub    $0xc,%esp
   15c8b:	6a 4f                	push   $0x4f
   15c8d:	e8 97 b4 ff ff       	call   11129 <Set_Current_Attr>
   15c92:	83 c4 0c             	add    $0xc,%esp
   15c95:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15c9b:	ff 30                	pushl  (%eax)
   15c9d:	ff 74 24 44          	pushl  0x44(%esp)
   15ca1:	68 c6 01 00 00       	push   $0x1c6
   15ca6:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15cac:	50                   	push   %eax
   15cad:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15cb3:	50                   	push   %eax
   15cb4:	8d 83 3c 81 ff ff    	lea    -0x7ec4(%ebx),%eax
   15cba:	50                   	push   %eax
   15cbb:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15cc1:	50                   	push   %eax
   15cc2:	e8 13 b3 ff ff       	call   10fda <Print>
   15cc7:	83 c4 20             	add    $0x20,%esp
   15cca:	eb fe                	jmp    15cca <Exit+0x146>
   15ccc:	fa                   	cli    
		called = 1;
   15ccd:	b8 01 00 00 00       	mov    $0x1,%eax
        for (i = 0; i<MAX_TLOCAL_KEYS; i++) {
   15cd2:	83 c5 04             	add    $0x4,%ebp
   15cd5:	83 c6 04             	add    $0x4,%esi
   15cd8:	3b 74 24 14          	cmp    0x14(%esp),%esi
   15cdc:	74 7b                	je     15d59 <Exit+0x1d5>
	    void *x = (void *)curr->tlocalData[i];
   15cde:	8b 7d 00             	mov    0x0(%ebp),%edi
	    if (x != NULL && s_tlocalDestructors[i] != NULL) {
   15ce1:	85 ff                	test   %edi,%edi
   15ce3:	74 ed                	je     15cd2 <Exit+0x14e>
   15ce5:	89 74 24 18          	mov    %esi,0x18(%esp)
   15ce9:	83 3e 00             	cmpl   $0x0,(%esi)
   15cec:	74 e4                	je     15cd2 <Exit+0x14e>
	        curr->tlocalData[i] = NULL;
   15cee:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
		Enable_Interrupts();
   15cf5:	e8 52 a5 ff ff       	call   1024c <Interrupts_Enabled>
   15cfa:	84 c0                	test   %al,%al
   15cfc:	75 8a                	jne    15c88 <Exit+0x104>
    __asm__ __volatile__ ("sti");
   15cfe:	fb                   	sti    
		s_tlocalDestructors[i](x);
   15cff:	83 ec 0c             	sub    $0xc,%esp
   15d02:	57                   	push   %edi
   15d03:	8b 44 24 28          	mov    0x28(%esp),%eax
   15d07:	ff 10                	call   *(%eax)
		Disable_Interrupts();
   15d09:	e8 3e a5 ff ff       	call   1024c <Interrupts_Enabled>
   15d0e:	83 c4 10             	add    $0x10,%esp
   15d11:	84 c0                	test   %al,%al
   15d13:	75 b7                	jne    15ccc <Exit+0x148>
   15d15:	83 ec 0c             	sub    $0xc,%esp
   15d18:	6a 4f                	push   $0x4f
   15d1a:	e8 0a b4 ff ff       	call   11129 <Set_Current_Attr>
   15d1f:	83 c4 0c             	add    $0xc,%esp
   15d22:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15d28:	ff 30                	pushl  (%eax)
   15d2a:	ff 74 24 44          	pushl  0x44(%esp)
   15d2e:	68 c8 01 00 00       	push   $0x1c8
   15d33:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15d39:	50                   	push   %eax
   15d3a:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15d40:	50                   	push   %eax
   15d41:	8d 83 3c 81 ff ff    	lea    -0x7ec4(%ebx),%eax
   15d47:	50                   	push   %eax
   15d48:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15d4e:	50                   	push   %eax
   15d4f:	e8 86 b2 ff ff       	call   10fda <Print>
   15d54:	83 c4 20             	add    $0x20,%esp
   15d57:	eb fe                	jmp    15d57 <Exit+0x1d3>
	if (!called) break;
   15d59:	85 c0                	test   %eax,%eax
   15d5b:	74 0b                	je     15d68 <Exit+0x1e4>
    for (j = 0; j<MIN_DESTRUCTOR_ITERATIONS; j++) {
   15d5d:	83 6c 24 10 01       	subl   $0x1,0x10(%esp)
   15d62:	0f 85 7c fe ff ff    	jne    15be4 <Exit+0x60>
   15d68:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    Wake_Up(&current->joinQueue);
   15d6c:	83 ec 0c             	sub    $0xc,%esp
   15d6f:	8d 45 28             	lea    0x28(%ebp),%eax
   15d72:	50                   	push   %eax
   15d73:	e8 5a fa ff ff       	call   157d2 <Wake_Up>
    Detach_Thread(g_currentThread);
   15d78:	c7 c6 90 77 02 00    	mov    $0x27790,%esi
   15d7e:	8b 06                	mov    (%esi),%eax
   15d80:	e8 d8 fa ff ff       	call   1585d <Detach_Thread>
    Schedule();
   15d85:	e8 ef f3 ff ff       	call   15179 <Schedule>
    KASSERT(false);
   15d8a:	c7 04 24 4f 00 00 00 	movl   $0x4f,(%esp)
   15d91:	e8 93 b3 ff ff       	call   11129 <Set_Current_Attr>
   15d96:	83 c4 0c             	add    $0xc,%esp
   15d99:	ff 36                	pushl  (%esi)
   15d9b:	ff 74 24 44          	pushl  0x44(%esp)
   15d9f:	68 a6 02 00 00       	push   $0x2a6
   15da4:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15daa:	50                   	push   %eax
   15dab:	8d 83 ab 75 ff ff    	lea    -0x8a55(%ebx),%eax
   15db1:	50                   	push   %eax
   15db2:	8d 83 48 81 ff ff    	lea    -0x7eb8(%ebx),%eax
   15db8:	50                   	push   %eax
   15db9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15dbf:	50                   	push   %eax
   15dc0:	e8 15 b2 ff ff       	call   10fda <Print>
   15dc5:	83 c4 20             	add    $0x20,%esp
   15dc8:	eb fe                	jmp    15dc8 <Exit+0x244>

00015dca <Shutdown_Thread>:
{
   15dca:	83 ec 18             	sub    $0x18,%esp
    Exit(0);
   15dcd:	6a 00                	push   $0x0
   15dcf:	e8 b0 fd ff ff       	call   15b84 <Exit>

00015dd4 <Wake_Up_One>:
 * Wake up a single thread waiting on given wait queue
 * (if there are any threads waiting).  Chooses the highest priority thread.
 * Interrupts must be disabled!
 */
void Wake_Up_One(struct Thread_Queue* waitQueue)
{
   15dd4:	57                   	push   %edi
   15dd5:	56                   	push   %esi
   15dd6:	53                   	push   %ebx
   15dd7:	e8 36 a4 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15ddc:	81 c3 24 02 01 00    	add    $0x10224,%ebx
   15de2:	8b 74 24 10          	mov    0x10(%esp),%esi
    struct Kernel_Thread* best;

    KASSERT(!Interrupts_Enabled());
   15de6:	e8 61 a4 ff ff       	call   1024c <Interrupts_Enabled>
   15deb:	84 c0                	test   %al,%al
   15ded:	75 0f                	jne    15dfe <Wake_Up_One+0x2a>
    struct Kernel_Thread *kthread = queue->head, *best = 0;
   15def:	8b 16                	mov    (%esi),%edx
   15df1:	89 d1                	mov    %edx,%ecx
   15df3:	89 d0                	mov    %edx,%eax
    while (kthread != 0) {
   15df5:	85 d2                	test   %edx,%edx
   15df7:	75 52                	jne    15e4b <Wake_Up_One+0x77>
   15df9:	e9 e5 00 00 00       	jmp    15ee3 <Wake_Up_One+0x10f>
    KASSERT(!Interrupts_Enabled());
   15dfe:	83 ec 0c             	sub    $0xc,%esp
   15e01:	6a 4f                	push   $0x4f
   15e03:	e8 21 b3 ff ff       	call   11129 <Set_Current_Attr>
   15e08:	83 c4 0c             	add    $0xc,%esp
   15e0b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15e11:	ff 30                	pushl  (%eax)
   15e13:	ff 74 24 14          	pushl  0x14(%esp)
   15e17:	68 23 03 00 00       	push   $0x323
   15e1c:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15e22:	50                   	push   %eax
   15e23:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   15e29:	50                   	push   %eax
   15e2a:	8d 83 d8 80 ff ff    	lea    -0x7f28(%ebx),%eax
   15e30:	50                   	push   %eax
   15e31:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15e37:	50                   	push   %eax
   15e38:	e8 9d b1 ff ff       	call   10fda <Print>
   15e3d:	83 c4 20             	add    $0x20,%esp
   15e40:	eb fe                	jmp    15e40 <Wake_Up_One+0x6c>
	kthread = Get_Next_In_Thread_Queue(kthread);
   15e42:	8b 78 08             	mov    0x8(%eax),%edi
   15e45:	39 79 08             	cmp    %edi,0x8(%ecx)
   15e48:	0f 4f c1             	cmovg  %ecx,%eax
   15e4b:	8b 49 10             	mov    0x10(%ecx),%ecx
    while (kthread != 0) {
   15e4e:	85 c9                	test   %ecx,%ecx
   15e50:	74 58                	je     15eaa <Wake_Up_One+0xd6>
	if (best == 0 || kthread->priority > best->priority)
   15e52:	85 c0                	test   %eax,%eax
   15e54:	75 ec                	jne    15e42 <Wake_Up_One+0x6e>
	kthread = Get_Next_In_Thread_Queue(kthread);
   15e56:	89 c8                	mov    %ecx,%eax
   15e58:	eb f1                	jmp    15e4b <Wake_Up_One+0x77>
   15e5a:	8b 50 10             	mov    0x10(%eax),%edx
   15e5d:	89 16                	mov    %edx,(%esi)
   15e5f:	eb 69                	jmp    15eca <Wake_Up_One+0xf6>
   15e61:	8b 50 0c             	mov    0xc(%eax),%edx
   15e64:	89 56 04             	mov    %edx,0x4(%esi)
   15e67:	eb 6e                	jmp    15ed7 <Wake_Up_One+0x103>
   15e69:	83 ec 0c             	sub    $0xc,%esp
   15e6c:	6a 4f                	push   $0x4f
   15e6e:	e8 b6 b2 ff ff       	call   11129 <Set_Current_Attr>
   15e73:	83 c4 0c             	add    $0xc,%esp
   15e76:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15e7c:	ff 30                	pushl  (%eax)
   15e7e:	ff 74 24 14          	pushl  0x14(%esp)
   15e82:	6a 44                	push   $0x44
   15e84:	8d 83 c7 7e ff ff    	lea    -0x8139(%ebx),%eax
   15e8a:	50                   	push   %eax
   15e8b:	8d 83 d4 7f ff ff    	lea    -0x802c(%ebx),%eax
   15e91:	50                   	push   %eax
   15e92:	8d 83 64 81 ff ff    	lea    -0x7e9c(%ebx),%eax
   15e98:	50                   	push   %eax
   15e99:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15e9f:	50                   	push   %eax
   15ea0:	e8 35 b1 ff ff       	call   10fda <Print>
   15ea5:	83 c4 20             	add    $0x20,%esp
   15ea8:	eb fe                	jmp    15ea8 <Wake_Up_One+0xd4>

    best = Find_Best(waitQueue);

    if (best != 0) {
   15eaa:	85 c0                	test   %eax,%eax
   15eac:	74 35                	je     15ee3 <Wake_Up_One+0x10f>
   15eae:	39 c2                	cmp    %eax,%edx
   15eb0:	74 0b                	je     15ebd <Wake_Up_One+0xe9>
   15eb2:	8b 52 10             	mov    0x10(%edx),%edx
   15eb5:	85 d2                	test   %edx,%edx
   15eb7:	74 b0                	je     15e69 <Wake_Up_One+0x95>
   15eb9:	39 d0                	cmp    %edx,%eax
   15ebb:	75 f5                	jne    15eb2 <Wake_Up_One+0xde>
   15ebd:	8b 50 0c             	mov    0xc(%eax),%edx
   15ec0:	85 d2                	test   %edx,%edx
   15ec2:	74 96                	je     15e5a <Wake_Up_One+0x86>
   15ec4:	8b 48 10             	mov    0x10(%eax),%ecx
   15ec7:	89 4a 10             	mov    %ecx,0x10(%edx)
   15eca:	8b 50 10             	mov    0x10(%eax),%edx
   15ecd:	85 d2                	test   %edx,%edx
   15ecf:	74 90                	je     15e61 <Wake_Up_One+0x8d>
   15ed1:	8b 48 0c             	mov    0xc(%eax),%ecx
   15ed4:	89 4a 0c             	mov    %ecx,0xc(%edx)
	Remove_Thread(waitQueue, best);
	Make_Runnable(best);
   15ed7:	83 ec 0c             	sub    $0xc,%esp
   15eda:	50                   	push   %eax
   15edb:	e8 e3 ec ff ff       	call   14bc3 <Make_Runnable>
   15ee0:	83 c4 10             	add    $0x10,%esp
	/*Print("Wake_Up_One: waking up %x from %x\n", best, g_currentThread); */
    }
}
   15ee3:	5b                   	pop    %ebx
   15ee4:	5e                   	pop    %esi
   15ee5:	5f                   	pop    %edi
   15ee6:	c3                   	ret    

00015ee7 <Tlocal_Create>:

/*
 * Allocate a key for accessing thread-local data.
 */
int Tlocal_Create(tlocal_key_t *key, tlocal_destructor_t destructor) 
{
   15ee7:	57                   	push   %edi
   15ee8:	56                   	push   %esi
   15ee9:	53                   	push   %ebx
   15eea:	e8 23 a3 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   15eef:	81 c3 11 01 01 00    	add    $0x10111,%ebx
   15ef5:	8b 7c 24 10          	mov    0x10(%esp),%edi
    KASSERT(key);
   15ef9:	85 ff                	test   %edi,%edi
   15efb:	74 56                	je     15f53 <Tlocal_Create+0x6c>
    bool enabled = Interrupts_Enabled();
   15efd:	e8 4a a3 ff ff       	call   1024c <Interrupts_Enabled>
   15f02:	89 c6                	mov    %eax,%esi
    if (enabled)
   15f04:	84 c0                	test   %al,%al
   15f06:	0f 85 8b 00 00 00    	jne    15f97 <Tlocal_Create+0xb0>

    bool iflag = Begin_Int_Atomic();

    if (s_tlocalKeyCounter == MAX_TLOCAL_KEYS) return -1;
   15f0c:	8b 83 e0 12 00 00    	mov    0x12e0(%ebx),%eax
   15f12:	3d 80 00 00 00       	cmp    $0x80,%eax
   15f17:	0f 84 69 01 00 00    	je     16086 <Tlocal_Create+0x19f>
    s_tlocalDestructors[s_tlocalKeyCounter] = destructor;
   15f1d:	8b 54 24 14          	mov    0x14(%esp),%edx
   15f21:	89 94 83 e0 10 00 00 	mov    %edx,0x10e0(%ebx,%eax,4)
    *key = s_tlocalKeyCounter++;
   15f28:	8d 50 01             	lea    0x1(%eax),%edx
   15f2b:	89 93 e0 12 00 00    	mov    %edx,0x12e0(%ebx)
   15f31:	89 07                	mov    %eax,(%edi)
    KASSERT(!Interrupts_Enabled());
   15f33:	e8 14 a3 ff ff       	call   1024c <Interrupts_Enabled>
   15f38:	84 c0                	test   %al,%al
   15f3a:	0f 85 aa 00 00 00    	jne    15fea <Tlocal_Create+0x103>

    End_Int_Atomic(iflag);
  
    return 0;
   15f40:	b8 00 00 00 00       	mov    $0x0,%eax
    if (iflag) {
   15f45:	89 f1                	mov    %esi,%ecx
   15f47:	84 c9                	test   %cl,%cl
   15f49:	0f 85 df 00 00 00    	jne    1602e <Tlocal_Create+0x147>
}
   15f4f:	5b                   	pop    %ebx
   15f50:	5e                   	pop    %esi
   15f51:	5f                   	pop    %edi
   15f52:	c3                   	ret    
    KASSERT(key);
   15f53:	83 ec 0c             	sub    $0xc,%esp
   15f56:	6a 4f                	push   $0x4f
   15f58:	e8 cc b1 ff ff       	call   11129 <Set_Current_Attr>
   15f5d:	83 c4 0c             	add    $0xc,%esp
   15f60:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15f66:	ff 30                	pushl  (%eax)
   15f68:	ff 74 24 14          	pushl  0x14(%esp)
   15f6c:	68 33 03 00 00       	push   $0x333
   15f71:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   15f77:	50                   	push   %eax
   15f78:	8d 83 19 7f ff ff    	lea    -0x80e7(%ebx),%eax
   15f7e:	50                   	push   %eax
   15f7f:	8d 83 c8 80 ff ff    	lea    -0x7f38(%ebx),%eax
   15f85:	50                   	push   %eax
   15f86:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15f8c:	50                   	push   %eax
   15f8d:	e8 48 b0 ff ff       	call   10fda <Print>
   15f92:	83 c4 20             	add    $0x20,%esp
   15f95:	eb fe                	jmp    15f95 <Tlocal_Create+0xae>
	Disable_Interrupts();
   15f97:	e8 b0 a2 ff ff       	call   1024c <Interrupts_Enabled>
   15f9c:	84 c0                	test   %al,%al
   15f9e:	74 06                	je     15fa6 <Tlocal_Create+0xbf>
    __asm__ __volatile__ ("cli");
   15fa0:	fa                   	cli    
}
   15fa1:	e9 66 ff ff ff       	jmp    15f0c <Tlocal_Create+0x25>
	Disable_Interrupts();
   15fa6:	83 ec 0c             	sub    $0xc,%esp
   15fa9:	6a 4f                	push   $0x4f
   15fab:	e8 79 b1 ff ff       	call   11129 <Set_Current_Attr>
   15fb0:	83 c4 0c             	add    $0xc,%esp
   15fb3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15fb9:	ff 30                	pushl  (%eax)
   15fbb:	ff 74 24 14          	pushl  0x14(%esp)
   15fbf:	68 8f 00 00 00       	push   $0x8f
   15fc4:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   15fca:	50                   	push   %eax
   15fcb:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   15fd1:	50                   	push   %eax
   15fd2:	8d 83 04 81 ff ff    	lea    -0x7efc(%ebx),%eax
   15fd8:	50                   	push   %eax
   15fd9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   15fdf:	50                   	push   %eax
   15fe0:	e8 f5 af ff ff       	call   10fda <Print>
   15fe5:	83 c4 20             	add    $0x20,%esp
   15fe8:	eb fe                	jmp    15fe8 <Tlocal_Create+0x101>
    KASSERT(!Interrupts_Enabled());
   15fea:	83 ec 0c             	sub    $0xc,%esp
   15fed:	6a 4f                	push   $0x4f
   15fef:	e8 35 b1 ff ff       	call   11129 <Set_Current_Attr>
   15ff4:	83 c4 0c             	add    $0xc,%esp
   15ff7:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   15ffd:	ff 30                	pushl  (%eax)
   15fff:	ff 74 24 14          	pushl  0x14(%esp)
   16003:	68 99 00 00 00       	push   $0x99
   16008:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1600e:	50                   	push   %eax
   1600f:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   16015:	50                   	push   %eax
   16016:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   1601c:	50                   	push   %eax
   1601d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16023:	50                   	push   %eax
   16024:	e8 b1 af ff ff       	call   10fda <Print>
   16029:	83 c4 20             	add    $0x20,%esp
   1602c:	eb fe                	jmp    1602c <Tlocal_Create+0x145>
	Enable_Interrupts();
   1602e:	e8 19 a2 ff ff       	call   1024c <Interrupts_Enabled>
   16033:	84 c0                	test   %al,%al
   16035:	75 0b                	jne    16042 <Tlocal_Create+0x15b>
    __asm__ __volatile__ ("sti");
   16037:	fb                   	sti    
    return 0;
   16038:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1603d:	e9 0d ff ff ff       	jmp    15f4f <Tlocal_Create+0x68>
	Enable_Interrupts();
   16042:	83 ec 0c             	sub    $0xc,%esp
   16045:	6a 4f                	push   $0x4f
   16047:	e8 dd b0 ff ff       	call   11129 <Set_Current_Attr>
   1604c:	83 c4 0c             	add    $0xc,%esp
   1604f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16055:	ff 30                	pushl  (%eax)
   16057:	ff 74 24 14          	pushl  0x14(%esp)
   1605b:	68 9c 00 00 00       	push   $0x9c
   16060:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   16066:	50                   	push   %eax
   16067:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1606d:	50                   	push   %eax
   1606e:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   16074:	50                   	push   %eax
   16075:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1607b:	50                   	push   %eax
   1607c:	e8 59 af ff ff       	call   10fda <Print>
   16081:	83 c4 20             	add    $0x20,%esp
   16084:	eb fe                	jmp    16084 <Tlocal_Create+0x19d>
    if (s_tlocalKeyCounter == MAX_TLOCAL_KEYS) return -1;
   16086:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1608b:	e9 bf fe ff ff       	jmp    15f4f <Tlocal_Create+0x68>

00016090 <Tlocal_Put>:

/*
 * Store a value for a thread-local item
 */
void Tlocal_Put(tlocal_key_t k, const void *v) 
{
   16090:	53                   	push   %ebx
   16091:	83 ec 08             	sub    $0x8,%esp
   16094:	e8 79 a1 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16099:	81 c3 67 ff 00 00    	add    $0xff67,%ebx
   1609f:	8b 44 24 10          	mov    0x10(%esp),%eax
    const void **pv;

    KASSERT(k < s_tlocalKeyCounter);
   160a3:	39 83 e0 12 00 00    	cmp    %eax,0x12e0(%ebx)
   160a9:	77 44                	ja     160ef <Tlocal_Put+0x5f>
   160ab:	83 ec 0c             	sub    $0xc,%esp
   160ae:	6a 4f                	push   $0x4f
   160b0:	e8 74 b0 ff ff       	call   11129 <Set_Current_Attr>
   160b5:	83 c4 0c             	add    $0xc,%esp
   160b8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   160be:	ff 30                	pushl  (%eax)
   160c0:	ff 74 24 14          	pushl  0x14(%esp)
   160c4:	68 47 03 00 00       	push   $0x347
   160c9:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   160cf:	50                   	push   %eax
   160d0:	8d 83 1d 7f ff ff    	lea    -0x80e3(%ebx),%eax
   160d6:	50                   	push   %eax
   160d7:	8d 83 bc 80 ff ff    	lea    -0x7f44(%ebx),%eax
   160dd:	50                   	push   %eax
   160de:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   160e4:	50                   	push   %eax
   160e5:	e8 f0 ae ff ff       	call   10fda <Print>
   160ea:	83 c4 20             	add    $0x20,%esp
   160ed:	eb fe                	jmp    160ed <Tlocal_Put+0x5d>
    KASSERT(k < MAX_TLOCAL_KEYS);
   160ef:	83 f8 7f             	cmp    $0x7f,%eax
   160f2:	77 15                	ja     16109 <Tlocal_Put+0x79>

    pv = Get_Tlocal_Pointer(k);
    *pv = v;
   160f4:	c7 c2 90 77 02 00    	mov    $0x27790,%edx
   160fa:	8b 12                	mov    (%edx),%edx
   160fc:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   16100:	89 4c 82 40          	mov    %ecx,0x40(%edx,%eax,4)
}
   16104:	83 c4 08             	add    $0x8,%esp
   16107:	5b                   	pop    %ebx
   16108:	c3                   	ret    
    KASSERT(k < MAX_TLOCAL_KEYS);
   16109:	83 ec 0c             	sub    $0xc,%esp
   1610c:	6a 4f                	push   $0x4f
   1610e:	e8 16 b0 ff ff       	call   11129 <Set_Current_Attr>
   16113:	83 c4 0c             	add    $0xc,%esp
   16116:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1611c:	ff 30                	pushl  (%eax)
   1611e:	ff 74 24 14          	pushl  0x14(%esp)
   16122:	68 aa 01 00 00       	push   $0x1aa
   16127:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1612d:	50                   	push   %eax
   1612e:	8d 83 34 7f ff ff    	lea    -0x80cc(%ebx),%eax
   16134:	50                   	push   %eax
   16135:	8d 83 a8 80 ff ff    	lea    -0x7f58(%ebx),%eax
   1613b:	50                   	push   %eax
   1613c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16142:	50                   	push   %eax
   16143:	e8 92 ae ff ff       	call   10fda <Print>
   16148:	83 c4 20             	add    $0x20,%esp
   1614b:	eb fe                	jmp    1614b <Tlocal_Put+0xbb>

0001614d <Tlocal_Get>:

/*
 * Acquire a thread-local value
 */
void *Tlocal_Get(tlocal_key_t k) 
{
   1614d:	53                   	push   %ebx
   1614e:	83 ec 08             	sub    $0x8,%esp
   16151:	e8 bc a0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16156:	81 c3 aa fe 00 00    	add    $0xfeaa,%ebx
   1615c:	8b 44 24 10          	mov    0x10(%esp),%eax
    const void **pv;

    KASSERT(k < s_tlocalKeyCounter);
   16160:	39 83 e0 12 00 00    	cmp    %eax,0x12e0(%ebx)
   16166:	77 44                	ja     161ac <Tlocal_Get+0x5f>
   16168:	83 ec 0c             	sub    $0xc,%esp
   1616b:	6a 4f                	push   $0x4f
   1616d:	e8 b7 af ff ff       	call   11129 <Set_Current_Attr>
   16172:	83 c4 0c             	add    $0xc,%esp
   16175:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1617b:	ff 30                	pushl  (%eax)
   1617d:	ff 74 24 14          	pushl  0x14(%esp)
   16181:	68 54 03 00 00       	push   $0x354
   16186:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   1618c:	50                   	push   %eax
   1618d:	8d 83 1d 7f ff ff    	lea    -0x80e3(%ebx),%eax
   16193:	50                   	push   %eax
   16194:	8d 83 9c 80 ff ff    	lea    -0x7f64(%ebx),%eax
   1619a:	50                   	push   %eax
   1619b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   161a1:	50                   	push   %eax
   161a2:	e8 33 ae ff ff       	call   10fda <Print>
   161a7:	83 c4 20             	add    $0x20,%esp
   161aa:	eb fe                	jmp    161aa <Tlocal_Get+0x5d>
    KASSERT(k < MAX_TLOCAL_KEYS);
   161ac:	83 f8 7f             	cmp    $0x7f,%eax
   161af:	77 11                	ja     161c2 <Tlocal_Get+0x75>

    pv = Get_Tlocal_Pointer(k);
    return (void *)*pv;
   161b1:	c7 c2 90 77 02 00    	mov    $0x27790,%edx
   161b7:	8b 12                	mov    (%edx),%edx
   161b9:	8b 44 82 40          	mov    0x40(%edx,%eax,4),%eax
}
   161bd:	83 c4 08             	add    $0x8,%esp
   161c0:	5b                   	pop    %ebx
   161c1:	c3                   	ret    
    KASSERT(k < MAX_TLOCAL_KEYS);
   161c2:	83 ec 0c             	sub    $0xc,%esp
   161c5:	6a 4f                	push   $0x4f
   161c7:	e8 5d af ff ff       	call   11129 <Set_Current_Attr>
   161cc:	83 c4 0c             	add    $0xc,%esp
   161cf:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   161d5:	ff 30                	pushl  (%eax)
   161d7:	ff 74 24 14          	pushl  0x14(%esp)
   161db:	68 aa 01 00 00       	push   $0x1aa
   161e0:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   161e6:	50                   	push   %eax
   161e7:	8d 83 34 7f ff ff    	lea    -0x80cc(%ebx),%eax
   161ed:	50                   	push   %eax
   161ee:	8d 83 a8 80 ff ff    	lea    -0x7f58(%ebx),%eax
   161f4:	50                   	push   %eax
   161f5:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   161fb:	50                   	push   %eax
   161fc:	e8 d9 ad ff ff       	call   10fda <Print>
   16201:	83 c4 20             	add    $0x20,%esp
   16204:	eb fe                	jmp    16204 <Tlocal_Get+0xb7>

00016206 <Dump_All_Thread_List>:
/*
 * Print list of all threads in system.
 * For debugging.
 */
void Dump_All_Thread_List(void)
{
   16206:	55                   	push   %ebp
   16207:	57                   	push   %edi
   16208:	56                   	push   %esi
   16209:	53                   	push   %ebx
   1620a:	83 ec 1c             	sub    $0x1c,%esp
   1620d:	e8 00 a0 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16212:	81 c3 ee fd 00 00    	add    $0xfdee,%ebx
    bool enabled = Interrupts_Enabled();
   16218:	e8 2f a0 ff ff       	call   1024c <Interrupts_Enabled>
   1621d:	88 44 24 0f          	mov    %al,0xf(%esp)
    if (enabled)
   16221:	84 c0                	test   %al,%al
   16223:	75 49                	jne    1626e <Dump_All_Thread_List+0x68>
IMPLEMENT_LIST(All_Thread_List, Kernel_Thread);
   16225:	8b b3 fc 12 00 00    	mov    0x12fc(%ebx),%esi
    int count = 0;
    bool iflag = Begin_Int_Atomic();

    kthread = Get_Front_Of_All_Thread_List(&s_allThreadList);

    Print("[");
   1622b:	83 ec 0c             	sub    $0xc,%esp
   1622e:	8d 83 48 7f ff ff    	lea    -0x80b8(%ebx),%eax
   16234:	50                   	push   %eax
   16235:	e8 a0 ad ff ff       	call   10fda <Print>
    while (kthread != 0) {
   1623a:	83 c4 10             	add    $0x10,%esp
    int count = 0;
   1623d:	bf 00 00 00 00       	mov    $0x0,%edi
	++count;
	Print("<%lx,%lx,%lx>",
   16242:	8d ab 4a 7f ff ff    	lea    -0x80b6(%ebx),%ebp
    while (kthread != 0) {
   16248:	85 f6                	test   %esi,%esi
   1624a:	0f 84 b2 00 00 00    	je     16302 <Dump_All_Thread_List+0xfc>
	++count;
   16250:	83 c7 01             	add    $0x1,%edi
	Print("<%lx,%lx,%lx>",
   16253:	ff 76 3c             	pushl  0x3c(%esi)
   16256:	56                   	push   %esi
   16257:	ff 76 38             	pushl  0x38(%esi)
   1625a:	55                   	push   %ebp
   1625b:	e8 7a ad ff ff       	call   10fda <Print>
   16260:	8b 46 3c             	mov    0x3c(%esi),%eax
	    (ulong_t) Get_Prev_In_All_Thread_List(kthread),
	    (ulong_t) kthread,
	    (ulong_t) Get_Next_In_All_Thread_List(kthread));
	KASSERT(kthread != Get_Next_In_All_Thread_List(kthread));
   16263:	83 c4 10             	add    $0x10,%esp
   16266:	39 c6                	cmp    %eax,%esi
   16268:	74 54                	je     162be <Dump_All_Thread_List+0xb8>
	kthread = Get_Next_In_All_Thread_List(kthread);
   1626a:	89 c6                	mov    %eax,%esi
   1626c:	eb da                	jmp    16248 <Dump_All_Thread_List+0x42>
	Disable_Interrupts();
   1626e:	e8 d9 9f ff ff       	call   1024c <Interrupts_Enabled>
   16273:	84 c0                	test   %al,%al
   16275:	74 03                	je     1627a <Dump_All_Thread_List+0x74>
    __asm__ __volatile__ ("cli");
   16277:	fa                   	cli    
}
   16278:	eb ab                	jmp    16225 <Dump_All_Thread_List+0x1f>
	Disable_Interrupts();
   1627a:	83 ec 0c             	sub    $0xc,%esp
   1627d:	6a 4f                	push   $0x4f
   1627f:	e8 a5 ae ff ff       	call   11129 <Set_Current_Attr>
   16284:	83 c4 0c             	add    $0xc,%esp
   16287:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1628d:	ff 30                	pushl  (%eax)
   1628f:	ff 74 24 34          	pushl  0x34(%esp)
   16293:	68 8f 00 00 00       	push   $0x8f
   16298:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1629e:	50                   	push   %eax
   1629f:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   162a5:	50                   	push   %eax
   162a6:	8d 83 04 81 ff ff    	lea    -0x7efc(%ebx),%eax
   162ac:	50                   	push   %eax
   162ad:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   162b3:	50                   	push   %eax
   162b4:	e8 21 ad ff ff       	call   10fda <Print>
   162b9:	83 c4 20             	add    $0x20,%esp
   162bc:	eb fe                	jmp    162bc <Dump_All_Thread_List+0xb6>
	KASSERT(kthread != Get_Next_In_All_Thread_List(kthread));
   162be:	83 ec 0c             	sub    $0xc,%esp
   162c1:	6a 4f                	push   $0x4f
   162c3:	e8 61 ae ff ff       	call   11129 <Set_Current_Attr>
   162c8:	83 c4 0c             	add    $0xc,%esp
   162cb:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   162d1:	ff 30                	pushl  (%eax)
   162d3:	ff 74 24 34          	pushl  0x34(%esp)
   162d7:	68 6d 03 00 00       	push   $0x36d
   162dc:	8d 83 af 7e ff ff    	lea    -0x8151(%ebx),%eax
   162e2:	50                   	push   %eax
   162e3:	8d 83 54 80 ff ff    	lea    -0x7fac(%ebx),%eax
   162e9:	50                   	push   %eax
   162ea:	8d 83 84 80 ff ff    	lea    -0x7f7c(%ebx),%eax
   162f0:	50                   	push   %eax
   162f1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   162f7:	50                   	push   %eax
   162f8:	e8 dd ac ff ff       	call   10fda <Print>
   162fd:	83 c4 20             	add    $0x20,%esp
   16300:	eb fe                	jmp    16300 <Dump_All_Thread_List+0xfa>
    }
    Print("]\n");
   16302:	83 ec 0c             	sub    $0xc,%esp
   16305:	8d 83 58 7f ff ff    	lea    -0x80a8(%ebx),%eax
   1630b:	50                   	push   %eax
   1630c:	e8 c9 ac ff ff       	call   10fda <Print>
    Print("%d threads are running\n", count);
   16311:	83 c4 08             	add    $0x8,%esp
   16314:	57                   	push   %edi
   16315:	8d 83 5b 7f ff ff    	lea    -0x80a5(%ebx),%eax
   1631b:	50                   	push   %eax
   1631c:	e8 b9 ac ff ff       	call   10fda <Print>
    KASSERT(!Interrupts_Enabled());
   16321:	e8 26 9f ff ff       	call   1024c <Interrupts_Enabled>
   16326:	83 c4 10             	add    $0x10,%esp
   16329:	84 c0                	test   %al,%al
   1632b:	75 0f                	jne    1633c <Dump_All_Thread_List+0x136>
    if (iflag) {
   1632d:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
   16332:	75 4c                	jne    16380 <Dump_All_Thread_List+0x17a>

    End_Int_Atomic(iflag);
}
   16334:	83 c4 1c             	add    $0x1c,%esp
   16337:	5b                   	pop    %ebx
   16338:	5e                   	pop    %esi
   16339:	5f                   	pop    %edi
   1633a:	5d                   	pop    %ebp
   1633b:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   1633c:	83 ec 0c             	sub    $0xc,%esp
   1633f:	6a 4f                	push   $0x4f
   16341:	e8 e3 ad ff ff       	call   11129 <Set_Current_Attr>
   16346:	83 c4 0c             	add    $0xc,%esp
   16349:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1634f:	ff 30                	pushl  (%eax)
   16351:	ff 74 24 34          	pushl  0x34(%esp)
   16355:	68 99 00 00 00       	push   $0x99
   1635a:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   16360:	50                   	push   %eax
   16361:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   16367:	50                   	push   %eax
   16368:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   1636e:	50                   	push   %eax
   1636f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16375:	50                   	push   %eax
   16376:	e8 5f ac ff ff       	call   10fda <Print>
   1637b:	83 c4 20             	add    $0x20,%esp
   1637e:	eb fe                	jmp    1637e <Dump_All_Thread_List+0x178>
	Enable_Interrupts();
   16380:	e8 c7 9e ff ff       	call   1024c <Interrupts_Enabled>
   16385:	84 c0                	test   %al,%al
   16387:	75 03                	jne    1638c <Dump_All_Thread_List+0x186>
    __asm__ __volatile__ ("sti");
   16389:	fb                   	sti    
   1638a:	eb a8                	jmp    16334 <Dump_All_Thread_List+0x12e>
	Enable_Interrupts();
   1638c:	83 ec 0c             	sub    $0xc,%esp
   1638f:	6a 4f                	push   $0x4f
   16391:	e8 93 ad ff ff       	call   11129 <Set_Current_Attr>
   16396:	83 c4 0c             	add    $0xc,%esp
   16399:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1639f:	ff 30                	pushl  (%eax)
   163a1:	ff 74 24 34          	pushl  0x34(%esp)
   163a5:	68 9c 00 00 00       	push   $0x9c
   163aa:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   163b0:	50                   	push   %eax
   163b1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   163b7:	50                   	push   %eax
   163b8:	8d 83 f4 80 ff ff    	lea    -0x7f0c(%ebx),%eax
   163be:	50                   	push   %eax
   163bf:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   163c5:	50                   	push   %eax
   163c6:	e8 0f ac ff ff       	call   10fda <Print>
   163cb:	83 c4 20             	add    $0x20,%esp
   163ce:	eb fe                	jmp    163ce <Dump_All_Thread_List+0x1c8>

000163d0 <Attach_User_Context>:
/*
 * Associate the given user context with a kernel thread.
 * This makes the thread a user process.
 */
void Attach_User_Context(struct Kernel_Thread* kthread, struct User_Context* context)
{
   163d0:	56                   	push   %esi
   163d1:	53                   	push   %ebx
   163d2:	83 ec 04             	sub    $0x4,%esp
   163d5:	e8 38 9e ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   163da:	81 c3 26 fc 00 00    	add    $0xfc26,%ebx
   163e0:	8b 74 24 14          	mov    0x14(%esp),%esi
    KASSERT(context != 0);
   163e4:	85 f6                	test   %esi,%esi
   163e6:	74 60                	je     16448 <Attach_User_Context+0x78>
    kthread->userContext = context;
   163e8:	8b 44 24 10          	mov    0x10(%esp),%eax
   163ec:	89 70 18             	mov    %esi,0x18(%eax)

    Disable_Interrupts();
   163ef:	e8 58 9e ff ff       	call   1024c <Interrupts_Enabled>
   163f4:	84 c0                	test   %al,%al
   163f6:	0f 84 8d 00 00 00    	je     16489 <Attach_User_Context+0xb9>
    __asm__ __volatile__ ("cli");
   163fc:	fa                   	cli    

    /*
     * We don't actually allow multiple threads
     * to share a user context (yet)
     */
    KASSERT(context->refCount == 0);
   163fd:	83 7e 30 00          	cmpl   $0x0,0x30(%esi)
   16401:	0f 84 c3 00 00 00    	je     164ca <Attach_User_Context+0xfa>
   16407:	83 ec 0c             	sub    $0xc,%esp
   1640a:	6a 4f                	push   $0x4f
   1640c:	e8 18 ad ff ff       	call   11129 <Set_Current_Attr>
   16411:	83 c4 0c             	add    $0xc,%esp
   16414:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1641a:	ff 30                	pushl  (%eax)
   1641c:	ff 74 24 14          	pushl  0x14(%esp)
   16420:	6a 29                	push   $0x29
   16422:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   16428:	50                   	push   %eax
   16429:	8d 83 5d 82 ff ff    	lea    -0x7da3(%ebx),%eax
   1642f:	50                   	push   %eax
   16430:	8d 83 a0 82 ff ff    	lea    -0x7d60(%ebx),%eax
   16436:	50                   	push   %eax
   16437:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1643d:	50                   	push   %eax
   1643e:	e8 97 ab ff ff       	call   10fda <Print>
   16443:	83 c4 20             	add    $0x20,%esp
   16446:	eb fe                	jmp    16446 <Attach_User_Context+0x76>
    KASSERT(context != 0);
   16448:	83 ec 0c             	sub    $0xc,%esp
   1644b:	6a 4f                	push   $0x4f
   1644d:	e8 d7 ac ff ff       	call   11129 <Set_Current_Attr>
   16452:	83 c4 0c             	add    $0xc,%esp
   16455:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1645b:	ff 30                	pushl  (%eax)
   1645d:	ff 74 24 14          	pushl  0x14(%esp)
   16461:	6a 20                	push   $0x20
   16463:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   16469:	50                   	push   %eax
   1646a:	8d 83 50 82 ff ff    	lea    -0x7db0(%ebx),%eax
   16470:	50                   	push   %eax
   16471:	8d 83 a0 82 ff ff    	lea    -0x7d60(%ebx),%eax
   16477:	50                   	push   %eax
   16478:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1647e:	50                   	push   %eax
   1647f:	e8 56 ab ff ff       	call   10fda <Print>
   16484:	83 c4 20             	add    $0x20,%esp
   16487:	eb fe                	jmp    16487 <Attach_User_Context+0xb7>
    Disable_Interrupts();
   16489:	83 ec 0c             	sub    $0xc,%esp
   1648c:	6a 4f                	push   $0x4f
   1648e:	e8 96 ac ff ff       	call   11129 <Set_Current_Attr>
   16493:	83 c4 0c             	add    $0xc,%esp
   16496:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1649c:	ff 30                	pushl  (%eax)
   1649e:	ff 74 24 14          	pushl  0x14(%esp)
   164a2:	6a 23                	push   $0x23
   164a4:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   164aa:	50                   	push   %eax
   164ab:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   164b1:	50                   	push   %eax
   164b2:	8d 83 a0 82 ff ff    	lea    -0x7d60(%ebx),%eax
   164b8:	50                   	push   %eax
   164b9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   164bf:	50                   	push   %eax
   164c0:	e8 15 ab ff ff       	call   10fda <Print>
   164c5:	83 c4 20             	add    $0x20,%esp
   164c8:	eb fe                	jmp    164c8 <Attach_User_Context+0xf8>

    ++context->refCount;
   164ca:	c7 46 30 01 00 00 00 	movl   $0x1,0x30(%esi)
    Enable_Interrupts();
   164d1:	e8 76 9d ff ff       	call   1024c <Interrupts_Enabled>
   164d6:	84 c0                	test   %al,%al
   164d8:	75 07                	jne    164e1 <Attach_User_Context+0x111>
    __asm__ __volatile__ ("sti");
   164da:	fb                   	sti    
}
   164db:	83 c4 04             	add    $0x4,%esp
   164de:	5b                   	pop    %ebx
   164df:	5e                   	pop    %esi
   164e0:	c3                   	ret    
    Enable_Interrupts();
   164e1:	83 ec 0c             	sub    $0xc,%esp
   164e4:	6a 4f                	push   $0x4f
   164e6:	e8 3e ac ff ff       	call   11129 <Set_Current_Attr>
   164eb:	83 c4 0c             	add    $0xc,%esp
   164ee:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   164f4:	ff 30                	pushl  (%eax)
   164f6:	ff 74 24 14          	pushl  0x14(%esp)
   164fa:	6a 2c                	push   $0x2c
   164fc:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   16502:	50                   	push   %eax
   16503:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   16509:	50                   	push   %eax
   1650a:	8d 83 a0 82 ff ff    	lea    -0x7d60(%ebx),%eax
   16510:	50                   	push   %eax
   16511:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16517:	50                   	push   %eax
   16518:	e8 bd aa ff ff       	call   10fda <Print>
   1651d:	83 c4 20             	add    $0x20,%esp
   16520:	eb fe                	jmp    16520 <Attach_User_Context+0x150>

00016522 <Detach_User_Context>:
 * If the given thread has a user context, detach it
 * and destroy it.  This is called when a thread is
 * being destroyed.
 */
void Detach_User_Context(struct Kernel_Thread* kthread)
{
   16522:	57                   	push   %edi
   16523:	56                   	push   %esi
   16524:	53                   	push   %ebx
   16525:	e8 e8 9c ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1652a:	81 c3 d6 fa 00 00    	add    $0xfad6,%ebx
   16530:	8b 44 24 10          	mov    0x10(%esp),%eax
    struct User_Context* old = kthread->userContext;
   16534:	8b 70 18             	mov    0x18(%eax),%esi

    kthread->userContext = 0;
   16537:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

    if (old != 0) {
   1653e:	85 f6                	test   %esi,%esi
   16540:	74 62                	je     165a4 <Detach_User_Context+0x82>
	int refCount;

	Disable_Interrupts();
   16542:	e8 05 9d ff ff       	call   1024c <Interrupts_Enabled>
   16547:	84 c0                	test   %al,%al
   16549:	75 41                	jne    1658c <Detach_User_Context+0x6a>
   1654b:	83 ec 0c             	sub    $0xc,%esp
   1654e:	6a 4f                	push   $0x4f
   16550:	e8 d4 ab ff ff       	call   11129 <Set_Current_Attr>
   16555:	83 c4 0c             	add    $0xc,%esp
   16558:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1655e:	ff 30                	pushl  (%eax)
   16560:	ff 74 24 14          	pushl  0x14(%esp)
   16564:	6a 3d                	push   $0x3d
   16566:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   1656c:	50                   	push   %eax
   1656d:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   16573:	50                   	push   %eax
   16574:	8d 83 8c 82 ff ff    	lea    -0x7d74(%ebx),%eax
   1657a:	50                   	push   %eax
   1657b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16581:	50                   	push   %eax
   16582:	e8 53 aa ff ff       	call   10fda <Print>
   16587:	83 c4 20             	add    $0x20,%esp
   1658a:	eb fe                	jmp    1658a <Detach_User_Context+0x68>
    __asm__ __volatile__ ("cli");
   1658c:	fa                   	cli    
        --old->refCount;
   1658d:	8b 46 30             	mov    0x30(%esi),%eax
   16590:	8d 78 ff             	lea    -0x1(%eax),%edi
   16593:	89 7e 30             	mov    %edi,0x30(%esi)
	refCount = old->refCount;
	Enable_Interrupts();
   16596:	e8 b1 9c ff ff       	call   1024c <Interrupts_Enabled>
   1659b:	84 c0                	test   %al,%al
   1659d:	75 09                	jne    165a8 <Detach_User_Context+0x86>
    __asm__ __volatile__ ("sti");
   1659f:	fb                   	sti    

	/*Print("User context refcount == %d\n", refCount);*/
        if (refCount == 0)
   165a0:	85 ff                	test   %edi,%edi
   165a2:	74 45                	je     165e9 <Detach_User_Context+0xc7>
            Destroy_User_Context(old);
    }
}
   165a4:	5b                   	pop    %ebx
   165a5:	5e                   	pop    %esi
   165a6:	5f                   	pop    %edi
   165a7:	c3                   	ret    
	Enable_Interrupts();
   165a8:	83 ec 0c             	sub    $0xc,%esp
   165ab:	6a 4f                	push   $0x4f
   165ad:	e8 77 ab ff ff       	call   11129 <Set_Current_Attr>
   165b2:	83 c4 0c             	add    $0xc,%esp
   165b5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   165bb:	ff 30                	pushl  (%eax)
   165bd:	ff 74 24 14          	pushl  0x14(%esp)
   165c1:	6a 40                	push   $0x40
   165c3:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   165c9:	50                   	push   %eax
   165ca:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   165d0:	50                   	push   %eax
   165d1:	8d 83 8c 82 ff ff    	lea    -0x7d74(%ebx),%eax
   165d7:	50                   	push   %eax
   165d8:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   165de:	50                   	push   %eax
   165df:	e8 f6 a9 ff ff       	call   10fda <Print>
   165e4:	83 c4 20             	add    $0x20,%esp
   165e7:	eb fe                	jmp    165e7 <Detach_User_Context+0xc5>
            Destroy_User_Context(old);
   165e9:	83 ec 0c             	sub    $0xc,%esp
   165ec:	56                   	push   %esi
   165ed:	e8 eb 01 00 00       	call   167dd <Destroy_User_Context>
   165f2:	83 c4 10             	add    $0x10,%esp
}
   165f5:	eb ad                	jmp    165a4 <Detach_User_Context+0x82>

000165f7 <Spawn>:
 *   if the process couldn't be created.  Note that this function
 *   should return ENOTFOUND if the reason for failure is that
 *   the executable file doesn't exist.
 */
int Spawn(const char *program, const char *command, struct Kernel_Thread **pThread)
{
   165f7:	56                   	push   %esi
   165f8:	53                   	push   %ebx
   165f9:	81 ec 88 00 00 00    	sub    $0x88,%esp
   165ff:	e8 0e 9c ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16604:	81 c3 fc f9 00 00    	add    $0xf9fc,%ebx
     *
     * If all goes well, store the pointer to the new thread in
     * pThread and return 0.  Otherwise, return an error code.
     */
    int rc;
    char* fileData = 0;
   1660a:	c7 84 24 80 00 00 00 	movl   $0x0,0x80(%esp)
   16611:	00 00 00 00 
    ulong_t len = 0;
   16615:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%esp)
   1661c:	00 
    rc = Read_Fully(program, &fileData, &len);
   1661d:	8d 44 24 7c          	lea    0x7c(%esp),%eax
   16621:	50                   	push   %eax
   16622:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
   16629:	50                   	push   %eax
   1662a:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
   16631:	e8 82 3e 00 00       	call   1a4b8 <Read_Fully>
    if (rc) {
   16636:	83 c4 10             	add    $0x10,%esp
   16639:	85 c0                	test   %eax,%eax
   1663b:	75 43                	jne    16680 <Spawn+0x89>
        if (fileData) Free(fileData);
        return ENOTFOUND;
    }

    struct Exe_Format exeFormat;
    rc = Parse_ELF_Executable(fileData, len, &exeFormat);
   1663d:	83 ec 04             	sub    $0x4,%esp
   16640:	8d 44 24 10          	lea    0x10(%esp),%eax
   16644:	50                   	push   %eax
   16645:	ff b4 24 80 00 00 00 	pushl  0x80(%esp)
   1664c:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   16653:	e8 fa 1d 00 00       	call   18452 <Parse_ELF_Executable>
   16658:	89 c6                	mov    %eax,%esi
    if (rc) {
   1665a:	83 c4 10             	add    $0x10,%esp
   1665d:	85 c0                	test   %eax,%eax
   1665f:	74 3a                	je     1669b <Spawn+0xa4>
        if (fileData) Free(fileData);
   16661:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   16665:	85 c0                	test   %eax,%eax
   16667:	74 0c                	je     16675 <Spawn+0x7e>
   16669:	83 ec 0c             	sub    $0xc,%esp
   1666c:	50                   	push   %eax
   1666d:	e8 b8 d6 ff ff       	call   13d2a <Free>
   16672:	83 c4 10             	add    $0x10,%esp
        return -1;
    }

    *pThread = thread;
    return 0;
}
   16675:	89 f0                	mov    %esi,%eax
   16677:	81 c4 84 00 00 00    	add    $0x84,%esp
   1667d:	5b                   	pop    %ebx
   1667e:	5e                   	pop    %esi
   1667f:	c3                   	ret    
        if (fileData) Free(fileData);
   16680:	8b 44 24 7c          	mov    0x7c(%esp),%eax
        return ENOTFOUND;
   16684:	be fe ff ff ff       	mov    $0xfffffffe,%esi
        if (fileData) Free(fileData);
   16689:	85 c0                	test   %eax,%eax
   1668b:	74 e8                	je     16675 <Spawn+0x7e>
   1668d:	83 ec 0c             	sub    $0xc,%esp
   16690:	50                   	push   %eax
   16691:	e8 94 d6 ff ff       	call   13d2a <Free>
   16696:	83 c4 10             	add    $0x10,%esp
   16699:	eb da                	jmp    16675 <Spawn+0x7e>
    rc = Load_User_Program(fileData, len, &exeFormat, command, &userContext);
   1669b:	83 ec 0c             	sub    $0xc,%esp
   1669e:	8d 44 24 14          	lea    0x14(%esp),%eax
   166a2:	50                   	push   %eax
   166a3:	ff b4 24 a4 00 00 00 	pushl  0xa4(%esp)
   166aa:	8d 44 24 20          	lea    0x20(%esp),%eax
   166ae:	50                   	push   %eax
   166af:	ff b4 24 90 00 00 00 	pushl  0x90(%esp)
   166b6:	ff b4 24 98 00 00 00 	pushl  0x98(%esp)
   166bd:	e8 9a 01 00 00       	call   1685c <Load_User_Program>
   166c2:	89 c6                	mov    %eax,%esi
    if (rc) {
   166c4:	83 c4 20             	add    $0x20,%esp
   166c7:	85 c0                	test   %eax,%eax
   166c9:	74 2a                	je     166f5 <Spawn+0xfe>
        if (fileData) Free(fileData);
   166cb:	8b 44 24 7c          	mov    0x7c(%esp),%eax
   166cf:	85 c0                	test   %eax,%eax
   166d1:	74 0c                	je     166df <Spawn+0xe8>
   166d3:	83 ec 0c             	sub    $0xc,%esp
   166d6:	50                   	push   %eax
   166d7:	e8 4e d6 ff ff       	call   13d2a <Free>
   166dc:	83 c4 10             	add    $0x10,%esp
        if (userContext) Destroy_User_Context(userContext);
   166df:	8b 44 24 08          	mov    0x8(%esp),%eax
   166e3:	85 c0                	test   %eax,%eax
   166e5:	74 8e                	je     16675 <Spawn+0x7e>
   166e7:	83 ec 0c             	sub    $0xc,%esp
   166ea:	50                   	push   %eax
   166eb:	e8 ed 00 00 00       	call   167dd <Destroy_User_Context>
   166f0:	83 c4 10             	add    $0x10,%esp
   166f3:	eb 80                	jmp    16675 <Spawn+0x7e>
    Free(fileData);
   166f5:	83 ec 0c             	sub    $0xc,%esp
   166f8:	ff b4 24 88 00 00 00 	pushl  0x88(%esp)
   166ff:	e8 26 d6 ff ff       	call   13d2a <Free>
    thread = Start_User_Thread(userContext, false);
   16704:	83 c4 08             	add    $0x8,%esp
   16707:	6a 00                	push   $0x0
   16709:	ff 74 24 14          	pushl  0x14(%esp)
   1670d:	e8 07 e9 ff ff       	call   15019 <Start_User_Thread>
    if (!thread) {
   16712:	83 c4 10             	add    $0x10,%esp
   16715:	85 c0                	test   %eax,%eax
   16717:	74 0e                	je     16727 <Spawn+0x130>
    *pThread = thread;
   16719:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
   16720:	89 02                	mov    %eax,(%edx)
    return 0;
   16722:	e9 4e ff ff ff       	jmp    16675 <Spawn+0x7e>
        if (userContext) Destroy_User_Context(userContext);
   16727:	8b 44 24 08          	mov    0x8(%esp),%eax
        return -1;
   1672b:	be ff ff ff ff       	mov    $0xffffffff,%esi
        if (userContext) Destroy_User_Context(userContext);
   16730:	85 c0                	test   %eax,%eax
   16732:	0f 84 3d ff ff ff    	je     16675 <Spawn+0x7e>
   16738:	83 ec 0c             	sub    $0xc,%esp
   1673b:	50                   	push   %eax
   1673c:	e8 9c 00 00 00       	call   167dd <Destroy_User_Context>
   16741:	83 c4 10             	add    $0x10,%esp
   16744:	e9 2c ff ff ff       	jmp    16675 <Spawn+0x7e>

00016749 <Switch_To_User_Context>:
 *   kthread - the thread that is about to execute
 *   state - saved processor registers describing the state when
 *      the thread was interrupted
 */
void Switch_To_User_Context(struct Kernel_Thread* kthread, struct Interrupt_State* state)
{
   16749:	57                   	push   %edi
   1674a:	56                   	push   %esi
   1674b:	53                   	push   %ebx
   1674c:	e8 c1 9a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16751:	81 c3 af f8 00 00    	add    $0xf8af,%ebx
   16757:	8b 7c 24 10          	mov    0x10(%esp),%edi
     * Hint: Before executing in user mode, you will need to call
     * the Set_Kernel_Stack_Pointer() and Switch_To_Address_Space()
     * functions.
     */
    static struct User_Context* last_usercontext;
    struct User_Context* current_user_context = kthread->userContext;
   1675b:	8b 77 18             	mov    0x18(%edi),%esi

    // Interrupts should be disabled
    KASSERT(!Interrupts_Enabled());
   1675e:	e8 e9 9a ff ff       	call   1024c <Interrupts_Enabled>
   16763:	84 c0                	test   %al,%al
   16765:	75 32                	jne    16799 <Switch_To_User_Context+0x50>
    // No user context
    if (!current_user_context) return;
   16767:	85 f6                	test   %esi,%esi
   16769:	74 2a                	je     16795 <Switch_To_User_Context+0x4c>
    // Same user context
    if (current_user_context == last_usercontext) return;
   1676b:	39 b3 04 13 00 00    	cmp    %esi,0x1304(%ebx)
   16771:	74 22                	je     16795 <Switch_To_User_Context+0x4c>

    Switch_To_Address_Space(current_user_context);
   16773:	83 ec 0c             	sub    $0xc,%esp
   16776:	56                   	push   %esi
   16777:	e8 d7 03 00 00       	call   16b53 <Switch_To_Address_Space>
    ulong_t pointer = ((ulong_t)kthread->stackPage) + PAGE_SIZE;
   1677c:	8b 47 14             	mov    0x14(%edi),%eax
   1677f:	05 00 10 00 00       	add    $0x1000,%eax
    Set_Kernel_Stack_Pointer(pointer);
   16784:	89 04 24             	mov    %eax,(%esp)
   16787:	e8 cf c8 ff ff       	call   1305b <Set_Kernel_Stack_Pointer>
    last_usercontext = current_user_context;
   1678c:	89 b3 04 13 00 00    	mov    %esi,0x1304(%ebx)
   16792:	83 c4 10             	add    $0x10,%esp
}
   16795:	5b                   	pop    %ebx
   16796:	5e                   	pop    %esi
   16797:	5f                   	pop    %edi
   16798:	c3                   	ret    
    KASSERT(!Interrupts_Enabled());
   16799:	83 ec 0c             	sub    $0xc,%esp
   1679c:	6a 4f                	push   $0x4f
   1679e:	e8 86 a9 ff ff       	call   11129 <Set_Current_Attr>
   167a3:	83 c4 0c             	add    $0xc,%esp
   167a6:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   167ac:	ff 30                	pushl  (%eax)
   167ae:	ff 74 24 14          	pushl  0x14(%esp)
   167b2:	68 9d 00 00 00       	push   $0x9d
   167b7:	8d 83 3b 82 ff ff    	lea    -0x7dc5(%ebx),%eax
   167bd:	50                   	push   %eax
   167be:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   167c4:	50                   	push   %eax
   167c5:	8d 83 74 82 ff ff    	lea    -0x7d8c(%ebx),%eax
   167cb:	50                   	push   %eax
   167cc:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   167d2:	50                   	push   %eax
   167d3:	e8 02 a8 ff ff       	call   10fda <Print>
   167d8:	83 c4 20             	add    $0x20,%esp
   167db:	eb fe                	jmp    167db <Switch_To_User_Context+0x92>

000167dd <Destroy_User_Context>:
/*
 * Destroy a User_Context object, including all memory
 * and other resources allocated within it.
 */
void Destroy_User_Context(struct User_Context* userContext)
{
   167dd:	56                   	push   %esi
   167de:	53                   	push   %ebx
   167df:	83 ec 04             	sub    $0x4,%esp
   167e2:	e8 2b 9a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   167e7:	81 c3 19 f8 00 00    	add    $0xf819,%ebx
   167ed:	8b 74 24 10          	mov    0x10(%esp),%esi
     * Hints:
     * - you need to free the memory allocated for the user process
     * - don't forget to free the segment descriptor allocated
     *   for the process's LDT
     */
    KASSERT(userContext->refCount == 0);
   167f1:	83 7e 30 00          	cmpl   $0x0,0x30(%esi)
   167f5:	74 41                	je     16838 <Destroy_User_Context+0x5b>
   167f7:	83 ec 0c             	sub    $0xc,%esp
   167fa:	6a 4f                	push   $0x4f
   167fc:	e8 28 a9 ff ff       	call   11129 <Set_Current_Attr>
   16801:	83 c4 0c             	add    $0xc,%esp
   16804:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1680a:	ff 30                	pushl  (%eax)
   1680c:	ff 74 24 14          	pushl  0x14(%esp)
   16810:	6a 6d                	push   $0x6d
   16812:	8d 83 b4 82 ff ff    	lea    -0x7d4c(%ebx),%eax
   16818:	50                   	push   %eax
   16819:	8d 83 cc 82 ff ff    	lea    -0x7d34(%ebx),%eax
   1681f:	50                   	push   %eax
   16820:	8d 83 08 83 ff ff    	lea    -0x7cf8(%ebx),%eax
   16826:	50                   	push   %eax
   16827:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1682d:	50                   	push   %eax
   1682e:	e8 a7 a7 ff ff       	call   10fda <Print>
   16833:	83 c4 20             	add    $0x20,%esp
   16836:	eb fe                	jmp    16836 <Destroy_User_Context+0x59>
    Free(userContext->memory);
   16838:	83 ec 0c             	sub    $0xc,%esp
   1683b:	ff 76 14             	pushl  0x14(%esi)
   1683e:	e8 e7 d4 ff ff       	call   13d2a <Free>
    Free_Segment_Descriptor(userContext->ldtDescriptor);
   16843:	83 c4 04             	add    $0x4,%esp
   16846:	ff 76 10             	pushl  0x10(%esi)
   16849:	e8 94 c4 ff ff       	call   12ce2 <Free_Segment_Descriptor>
    Free(userContext);
   1684e:	89 34 24             	mov    %esi,(%esp)
   16851:	e8 d4 d4 ff ff       	call   13d2a <Free>
}
   16856:	83 c4 14             	add    $0x14,%esp
   16859:	5b                   	pop    %ebx
   1685a:	5e                   	pop    %esi
   1685b:	c3                   	ret    

0001685c <Load_User_Program>:
 *   0 if successful, or an error code (< 0) if unsuccessful
 */
int Load_User_Program(char *exeFileData, ulong_t exeFileLength,
    struct Exe_Format *exeFormat, const char *command,
    struct User_Context **pUserContext)
{
   1685c:	55                   	push   %ebp
   1685d:	57                   	push   %edi
   1685e:	56                   	push   %esi
   1685f:	53                   	push   %ebx
   16860:	83 ec 2c             	sub    $0x2c,%esp
   16863:	e8 aa 99 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16868:	81 c3 98 f7 00 00    	add    $0xf798,%ebx
     *   address, argument block address, and initial kernel stack pointer
     *   address
     */
    uint_t i = 0;
    ulong_t maxva = 0;
    for (i = 0; i < exeFormat->numSegments; i++) {
   1686e:	8b 44 24 48          	mov    0x48(%esp),%eax
   16872:	8b 78 64             	mov    0x64(%eax),%edi
   16875:	85 ff                	test   %edi,%edi
   16877:	0f 84 c3 01 00 00    	je     16a40 <Load_User_Program+0x1e4>
   1687d:	83 c0 08             	add    $0x8,%eax
    ulong_t maxva = 0;
   16880:	be 00 00 00 00       	mov    $0x0,%esi
    for (i = 0; i < exeFormat->numSegments; i++) {
   16885:	b9 00 00 00 00       	mov    $0x0,%ecx
        struct Exe_Segment* seg = exeFormat->segmentList + i;
        ulong_t tmp = seg->startAddress + seg->sizeInMemory;
   1688a:	8b 50 04             	mov    0x4(%eax),%edx
   1688d:	03 10                	add    (%eax),%edx
   1688f:	39 d6                	cmp    %edx,%esi
   16891:	0f 42 f2             	cmovb  %edx,%esi
    for (i = 0; i < exeFormat->numSegments; i++) {
   16894:	83 c1 01             	add    $0x1,%ecx
   16897:	83 c0 14             	add    $0x14,%eax
   1689a:	39 f9                	cmp    %edi,%ecx
   1689c:	75 ec                	jne    1688a <Load_User_Program+0x2e>
        if (tmp > maxva) {
            maxva = tmp;
        }
    }
    KASSERT(maxva > 0);
   1689e:	85 f6                	test   %esi,%esi
   168a0:	0f 84 9a 01 00 00    	je     16a40 <Load_User_Program+0x1e4>

    uint_t numarg;
    ulong_t argSize;
    Get_Argument_Block_Size(command, &numarg, &argSize);
   168a6:	83 ec 04             	sub    $0x4,%esp
   168a9:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   168ad:	50                   	push   %eax
   168ae:	8d 44 24 24          	lea    0x24(%esp),%eax
   168b2:	50                   	push   %eax
   168b3:	ff 74 24 58          	pushl  0x58(%esp)
   168b7:	e8 ea 02 00 00       	call   16ba6 <Get_Argument_Block_Size>
	addr += PAGE_SIZE;
   168bc:	89 f0                	mov    %esi,%eax
   168be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
   168c3:	05 00 10 00 00       	add    $0x1000,%eax
   168c8:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
   168ce:	0f 45 f0             	cmovne %eax,%esi
    * |  Argument Block
    *    User Stack
    *        |
    *    User Memory
    */
    ulong_t argBlockAddr = Round_Up_To_Page(maxva) + DEFAULT_USER_STACK_SIZE;
   168d1:	8d 8e 00 20 00 00    	lea    0x2000(%esi),%ecx
   168d7:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    ulong_t size = argBlockAddr + argSize;
   168db:	8b 44 24 28          	mov    0x28(%esp),%eax
   168df:	8d 2c 01             	lea    (%ecx,%eax,1),%ebp
   168e2:	89 ea                	mov    %ebp,%edx
   168e4:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
   168ea:	81 c2 00 10 00 00    	add    $0x1000,%edx
   168f0:	f7 c5 ff 0f 00 00    	test   $0xfff,%ebp
   168f6:	0f 44 d5             	cmove  %ebp,%edx
   168f9:	89 d5                	mov    %edx,%ebp
    userContext = (struct User_Context*)Malloc(sizeof(struct User_Context));
   168fb:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
   16902:	e8 a5 d2 ff ff       	call   13bac <Malloc>
   16907:	89 c6                	mov    %eax,%esi
    if (!userContext) return NULL;
   16909:	83 c4 10             	add    $0x10,%esp
   1690c:	85 c0                	test   %eax,%eax
   1690e:	0f 84 7c 01 00 00    	je     16a90 <Load_User_Program+0x234>
    memset(userContext, 0, sizeof(struct User_Context));
   16914:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1691a:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
   16921:	8d 78 04             	lea    0x4(%eax),%edi
   16924:	83 e7 fc             	and    $0xfffffffc,%edi
   16927:	89 c1                	mov    %eax,%ecx
   16929:	29 f9                	sub    %edi,%ecx
   1692b:	83 c1 34             	add    $0x34,%ecx
   1692e:	c1 e9 02             	shr    $0x2,%ecx
   16931:	b8 00 00 00 00       	mov    $0x0,%eax
   16936:	f3 ab                	rep stos %eax,%es:(%edi)
    userContext->memory = Malloc(size);
   16938:	83 ec 0c             	sub    $0xc,%esp
   1693b:	55                   	push   %ebp
   1693c:	e8 6b d2 ff ff       	call   13bac <Malloc>
   16941:	89 46 14             	mov    %eax,0x14(%esi)
    if (userContext->memory == NULL) {
   16944:	83 c4 10             	add    $0x10,%esp
   16947:	85 c0                	test   %eax,%eax
   16949:	0f 84 35 01 00 00    	je     16a84 <Load_User_Program+0x228>
    memset(userContext->memory, 0, size);
   1694f:	83 ec 04             	sub    $0x4,%esp
   16952:	55                   	push   %ebp
   16953:	6a 00                	push   $0x0
   16955:	50                   	push   %eax
   16956:	e8 00 61 00 00       	call   1ca5b <memset>
    userContext->size = size;
   1695b:	89 6e 18             	mov    %ebp,0x18(%esi)
    userContext->ldtDescriptor = Allocate_Segment_Descriptor();
   1695e:	e8 2f c2 ff ff       	call   12b92 <Allocate_Segment_Descriptor>
   16963:	89 46 10             	mov    %eax,0x10(%esi)
    if (!userContext->ldtDescriptor) {
   16966:	83 c4 10             	add    $0x10,%esp
   16969:	85 c0                	test   %eax,%eax
   1696b:	0f 84 26 01 00 00    	je     16a97 <Load_User_Program+0x23b>
    Init_LDT_Descriptor(userContext->ldtDescriptor, userContext->ldt, NUM_USER_LDT_ENTRIES);
   16971:	83 ec 04             	sub    $0x4,%esp
   16974:	6a 02                	push   $0x2
   16976:	56                   	push   %esi
   16977:	50                   	push   %eax
   16978:	e8 52 c9 ff ff       	call   132cf <Init_LDT_Descriptor>
    userContext->csSelector = Selector(USER_PRIVILEGE, false, 0);
   1697d:	66 c7 46 1e 07 00    	movw   $0x7,0x1e(%esi)
    userContext->dsSelector = Selector(USER_PRIVILEGE, false, 1);
   16983:	66 c7 46 20 0f 00    	movw   $0xf,0x20(%esi)
    userContext->ldtSelector = Selector(KERNEL_PRIVILEGE, true, Get_Descriptor_Index(userContext->ldtDescriptor));
   16989:	83 c4 04             	add    $0x4,%esp
   1698c:	ff 76 10             	pushl  0x10(%esi)
   1698f:	e8 c4 c4 ff ff       	call   12e58 <Get_Descriptor_Index>
   16994:	c1 e0 03             	shl    $0x3,%eax
   16997:	66 89 46 1c          	mov    %ax,0x1c(%esi)
    ulong_t base_addr = (ulong_t)userContext->memory;
   1699b:	8b 7e 14             	mov    0x14(%esi),%edi
    ulong_t num_page = size / PAGE_SIZE;
   1699e:	c1 ed 0c             	shr    $0xc,%ebp
    Init_Code_Segment_Descriptor(userContext->ldt, base_addr, num_page, USER_PRIVILEGE);
   169a1:	6a 03                	push   $0x3
   169a3:	55                   	push   %ebp
   169a4:	57                   	push   %edi
   169a5:	56                   	push   %esi
   169a6:	e8 fe c6 ff ff       	call   130a9 <Init_Code_Segment_Descriptor>
    Init_Data_Segment_Descriptor(userContext->ldt+1, base_addr, num_page, USER_PRIVILEGE);
   169ab:	83 c4 20             	add    $0x20,%esp
   169ae:	6a 03                	push   $0x3
   169b0:	55                   	push   %ebp
   169b1:	57                   	push   %edi
   169b2:	8d 46 08             	lea    0x8(%esi),%eax
   169b5:	50                   	push   %eax
   169b6:	e8 ec c7 ff ff       	call   131a7 <Init_Data_Segment_Descriptor>
    userContext->refCount = 0;
   169bb:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
    struct User_Context* userContext = Create_User_Context(size);
    if (userContext == 0) {
        return -1;
    }
    for (i = 0; i < exeFormat->numSegments; i++) {
   169c2:	83 c4 10             	add    $0x10,%esp
   169c5:	8b 44 24 48          	mov    0x48(%esp),%eax
   169c9:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
   169cd:	74 33                	je     16a02 <Load_User_Program+0x1a6>
   169cf:	89 c5                	mov    %eax,%ebp
   169d1:	bf 00 00 00 00       	mov    $0x0,%edi
        struct Exe_Segment* seg = exeFormat->segmentList + i;
        memcpy(userContext->memory + seg->startAddress,
   169d6:	8b 45 08             	mov    0x8(%ebp),%eax
   169d9:	03 46 14             	add    0x14(%esi),%eax
        exeFileData + seg->offsetInFile, seg->lengthInFile);
   169dc:	8b 54 24 40          	mov    0x40(%esp),%edx
   169e0:	03 55 00             	add    0x0(%ebp),%edx
        memcpy(userContext->memory + seg->startAddress,
   169e3:	83 ec 04             	sub    $0x4,%esp
   169e6:	ff 75 04             	pushl  0x4(%ebp)
   169e9:	52                   	push   %edx
   169ea:	50                   	push   %eax
   169eb:	e8 8e 60 00 00       	call   1ca7e <memcpy>
    for (i = 0; i < exeFormat->numSegments; i++) {
   169f0:	83 c7 01             	add    $0x1,%edi
   169f3:	83 c5 14             	add    $0x14,%ebp
   169f6:	83 c4 10             	add    $0x10,%esp
   169f9:	8b 44 24 48          	mov    0x48(%esp),%eax
   169fd:	39 78 64             	cmp    %edi,0x64(%eax)
   16a00:	77 d4                	ja     169d6 <Load_User_Program+0x17a>
    }

    Format_Argument_Block(userContext->memory + argBlockAddr, numarg, argBlockAddr, command);
   16a02:	ff 74 24 4c          	pushl  0x4c(%esp)
   16a06:	8b 7c 24 10          	mov    0x10(%esp),%edi
   16a0a:	57                   	push   %edi
   16a0b:	ff 74 24 24          	pushl  0x24(%esp)
   16a0f:	89 f8                	mov    %edi,%eax
   16a11:	03 46 14             	add    0x14(%esi),%eax
   16a14:	50                   	push   %eax
   16a15:	e8 e0 01 00 00       	call   16bfa <Format_Argument_Block>
    userContext->argBlockAddr = argBlockAddr;
   16a1a:	89 7e 28             	mov    %edi,0x28(%esi)
    userContext->stackPointerAddr = argBlockAddr;
   16a1d:	89 7e 2c             	mov    %edi,0x2c(%esi)
    userContext->entryAddr = exeFormat->entryAddr;
   16a20:	8b 44 24 58          	mov    0x58(%esp),%eax
   16a24:	8b 40 68             	mov    0x68(%eax),%eax
   16a27:	89 46 24             	mov    %eax,0x24(%esi)

    *pUserContext = userContext;
   16a2a:	8b 44 24 60          	mov    0x60(%esp),%eax
   16a2e:	89 30                	mov    %esi,(%eax)
    return 0;
   16a30:	83 c4 10             	add    $0x10,%esp
   16a33:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16a38:	83 c4 2c             	add    $0x2c,%esp
   16a3b:	5b                   	pop    %ebx
   16a3c:	5e                   	pop    %esi
   16a3d:	5f                   	pop    %edi
   16a3e:	5d                   	pop    %ebp
   16a3f:	c3                   	ret    
    KASSERT(maxva > 0);
   16a40:	83 ec 0c             	sub    $0xc,%esp
   16a43:	6a 4f                	push   $0x4f
   16a45:	e8 df a6 ff ff       	call   11129 <Set_Current_Attr>
   16a4a:	83 c4 0c             	add    $0xc,%esp
   16a4d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16a53:	ff 30                	pushl  (%eax)
   16a55:	ff 74 24 44          	pushl  0x44(%esp)
   16a59:	68 9d 00 00 00       	push   $0x9d
   16a5e:	8d 83 b4 82 ff ff    	lea    -0x7d4c(%ebx),%eax
   16a64:	50                   	push   %eax
   16a65:	8d 83 e7 82 ff ff    	lea    -0x7d19(%ebx),%eax
   16a6b:	50                   	push   %eax
   16a6c:	8d 83 f4 82 ff ff    	lea    -0x7d0c(%ebx),%eax
   16a72:	50                   	push   %eax
   16a73:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16a79:	50                   	push   %eax
   16a7a:	e8 5b a5 ff ff       	call   10fda <Print>
   16a7f:	83 c4 20             	add    $0x20,%esp
   16a82:	eb fe                	jmp    16a82 <Load_User_Program+0x226>
        Free(userContext);
   16a84:	83 ec 0c             	sub    $0xc,%esp
   16a87:	56                   	push   %esi
   16a88:	e8 9d d2 ff ff       	call   13d2a <Free>
        return NULL;
   16a8d:	83 c4 10             	add    $0x10,%esp
        return -1;
   16a90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16a95:	eb a1                	jmp    16a38 <Load_User_Program+0x1dc>
        Free(userContext->memory);
   16a97:	83 ec 0c             	sub    $0xc,%esp
   16a9a:	ff 76 14             	pushl  0x14(%esi)
   16a9d:	e8 88 d2 ff ff       	call   13d2a <Free>
        Free(userContext);
   16aa2:	89 34 24             	mov    %esi,(%esp)
   16aa5:	e8 80 d2 ff ff       	call   13d2a <Free>
        return NULL;
   16aaa:	83 c4 10             	add    $0x10,%esp
   16aad:	eb e1                	jmp    16a90 <Load_User_Program+0x234>

00016aaf <Copy_From_User>:
 *   true if successful, false if user buffer is invalid (i.e.,
 *   doesn't correspond to memory the process has a right to
 *   access)
 */
bool Copy_From_User(void* destInKernel, ulong_t srcInUser, ulong_t bufSize)
{
   16aaf:	57                   	push   %edi
   16ab0:	56                   	push   %esi
   16ab1:	53                   	push   %ebx
   16ab2:	e8 5b 97 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16ab7:	81 c3 49 f5 00 00    	add    $0xf549,%ebx
   16abd:	8b 44 24 14          	mov    0x14(%esp),%eax
   16ac1:	8b 74 24 18          	mov    0x18(%esp),%esi
     * - the user address is an index relative to the chunk
     *   of memory you allocated for it
     * - make sure the user buffer lies entirely in memory belonging
     *   to the process
     */
    struct User_Context* userContext = g_currentThread->userContext;
   16ac5:	c7 c2 90 77 02 00    	mov    $0x27790,%edx
   16acb:	8b 12                	mov    (%edx),%edx
   16acd:	8b 7a 18             	mov    0x18(%edx),%edi
    if (userAddr >= userContext->size)
   16ad0:	8b 57 18             	mov    0x18(%edi),%edx
    if (!Validate_User_Memory(userContext, srcInUser, bufSize)) return false;
   16ad3:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (userAddr >= userContext->size)
   16ad8:	39 d0                	cmp    %edx,%eax
   16ada:	73 1f                	jae    16afb <Copy_From_User+0x4c>
    avail = userContext->size - userAddr;
   16adc:	29 c2                	sub    %eax,%edx
    if (!Validate_User_Memory(userContext, srcInUser, bufSize)) return false;
   16ade:	39 d6                	cmp    %edx,%esi
   16ae0:	77 19                	ja     16afb <Copy_From_User+0x4c>
    memcpy(destInKernel, userContext->memory + srcInUser, bufSize);
   16ae2:	03 47 14             	add    0x14(%edi),%eax
   16ae5:	83 ec 04             	sub    $0x4,%esp
   16ae8:	56                   	push   %esi
   16ae9:	50                   	push   %eax
   16aea:	ff 74 24 1c          	pushl  0x1c(%esp)
   16aee:	e8 8b 5f 00 00       	call   1ca7e <memcpy>
    return true;
   16af3:	83 c4 10             	add    $0x10,%esp
   16af6:	b9 01 00 00 00       	mov    $0x1,%ecx
}
   16afb:	89 c8                	mov    %ecx,%eax
   16afd:	5b                   	pop    %ebx
   16afe:	5e                   	pop    %esi
   16aff:	5f                   	pop    %edi
   16b00:	c3                   	ret    

00016b01 <Copy_To_User>:
 *   true if successful, false if user buffer is invalid (i.e.,
 *   doesn't correspond to memory the process has a right to
 *   access)
 */
bool Copy_To_User(ulong_t destInUser, void* srcInKernel, ulong_t bufSize)
{
   16b01:	57                   	push   %edi
   16b02:	56                   	push   %esi
   16b03:	53                   	push   %ebx
   16b04:	e8 09 97 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16b09:	81 c3 f7 f4 00 00    	add    $0xf4f7,%ebx
   16b0f:	8b 44 24 10          	mov    0x10(%esp),%eax
   16b13:	8b 74 24 18          	mov    0x18(%esp),%esi
    /*
     * Hints: same as for Copy_From_User()
     */
    struct User_Context* userContext = g_currentThread->userContext;
   16b17:	c7 c2 90 77 02 00    	mov    $0x27790,%edx
   16b1d:	8b 12                	mov    (%edx),%edx
   16b1f:	8b 7a 18             	mov    0x18(%edx),%edi
    if (userAddr >= userContext->size)
   16b22:	8b 57 18             	mov    0x18(%edi),%edx
    if (!Validate_User_Memory(userContext, destInUser, bufSize)) return false;
   16b25:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (userAddr >= userContext->size)
   16b2a:	39 d0                	cmp    %edx,%eax
   16b2c:	73 1f                	jae    16b4d <Copy_To_User+0x4c>
    avail = userContext->size - userAddr;
   16b2e:	29 c2                	sub    %eax,%edx
    if (!Validate_User_Memory(userContext, destInUser, bufSize)) return false;
   16b30:	39 d6                	cmp    %edx,%esi
   16b32:	77 19                	ja     16b4d <Copy_To_User+0x4c>
    memcpy(userContext->memory + destInUser, srcInKernel, bufSize);
   16b34:	03 47 14             	add    0x14(%edi),%eax
   16b37:	83 ec 04             	sub    $0x4,%esp
   16b3a:	56                   	push   %esi
   16b3b:	ff 74 24 1c          	pushl  0x1c(%esp)
   16b3f:	50                   	push   %eax
   16b40:	e8 39 5f 00 00       	call   1ca7e <memcpy>
    return true;
   16b45:	83 c4 10             	add    $0x10,%esp
   16b48:	b9 01 00 00 00       	mov    $0x1,%ecx
}
   16b4d:	89 c8                	mov    %ecx,%eax
   16b4f:	5b                   	pop    %ebx
   16b50:	5e                   	pop    %esi
   16b51:	5f                   	pop    %edi
   16b52:	c3                   	ret    

00016b53 <Switch_To_Address_Space>:
    /*
     * Hint: you will need to use the lldt assembly language instruction
     * to load the process's LDT by specifying its LDT selector.
     */
    ushort_t ldtSelector = userContext->ldtSelector;     
    __asm__ __volatile__ (
   16b53:	8b 44 24 04          	mov    0x4(%esp),%eax
   16b57:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
   16b5b:	0f 00 d0             	lldt   %ax
        "lldt %0"
        :
        : "a" (ldtSelector)     
    );
}
   16b5e:	c3                   	ret    

00016b5f <Is_Space>:
 * Is given character a space?
 * @param c the character
 */
static bool Is_Space(int c)
{
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
   16b5f:	8d 48 f7             	lea    -0x9(%eax),%ecx
   16b62:	b8 00 00 00 00       	mov    $0x0,%eax
   16b67:	83 f9 17             	cmp    $0x17,%ecx
   16b6a:	77 0a                	ja     16b76 <Is_Space+0x17>
   16b6c:	b8 13 00 80 00       	mov    $0x800013,%eax
   16b71:	d3 e8                	shr    %cl,%eax
   16b73:	83 e0 01             	and    $0x1,%eax
   16b76:	83 e0 01             	and    $0x1,%eax
}
   16b79:	c3                   	ret    

00016b7a <Get_Argument_Len>:
 * Get the length of the first argument token in given string.
 * @param arg the string
 * @return number of characters in the argument token
 */
static unsigned Get_Argument_Len(const char *arg)
{
   16b7a:	56                   	push   %esi
   16b7b:	53                   	push   %ebx
   16b7c:	89 c6                	mov    %eax,%esi
    const char *s = arg;
    unsigned len = 0;

    while (*s != '\0' && !Is_Space(*s)) {
   16b7e:	0f b6 00             	movzbl (%eax),%eax
    unsigned len = 0;
   16b81:	bb 00 00 00 00       	mov    $0x0,%ebx
    while (*s != '\0' && !Is_Space(*s)) {
   16b86:	84 c0                	test   %al,%al
   16b88:	74 17                	je     16ba1 <Get_Argument_Len+0x27>
   16b8a:	0f be c0             	movsbl %al,%eax
   16b8d:	e8 cd ff ff ff       	call   16b5f <Is_Space>
   16b92:	84 c0                	test   %al,%al
   16b94:	75 0b                	jne    16ba1 <Get_Argument_Len+0x27>
	++len;
   16b96:	83 c3 01             	add    $0x1,%ebx
    while (*s != '\0' && !Is_Space(*s)) {
   16b99:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
   16b9d:	84 c0                	test   %al,%al
   16b9f:	75 e9                	jne    16b8a <Get_Argument_Len+0x10>
	++s;
    }
    return len;
}
   16ba1:	89 d8                	mov    %ebx,%eax
   16ba3:	5b                   	pop    %ebx
   16ba4:	5e                   	pop    %esi
   16ba5:	c3                   	ret    

00016ba6 <Get_Argument_Block_Size>:
 * @param numArgs pointer to int where number of arguments will be returned
 * @param argBlockSize pointer to int where buffer size of argument block
 *   will be returned
 */
void Get_Argument_Block_Size(const char *command, unsigned *numArgs, ulong_t *argBlockSize)
{
   16ba6:	55                   	push   %ebp
   16ba7:	57                   	push   %edi
   16ba8:	56                   	push   %esi
   16ba9:	53                   	push   %ebx
   16baa:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    ulong_t size = 0;
    unsigned argCount = 0;
   16bae:	bf 00 00 00 00       	mov    $0x0,%edi
    const char *s = command;

    size += sizeof(int);  /* Argument count */
    size += sizeof(char **);  /* Pointer to argument vector */
   16bb3:	be 08 00 00 00       	mov    $0x8,%esi
   16bb8:	eb 03                	jmp    16bbd <Get_Argument_Block_Size+0x17>
	++s;
   16bba:	83 c3 01             	add    $0x1,%ebx
    while (Is_Space(*s))
   16bbd:	0f b6 2b             	movzbl (%ebx),%ebp
   16bc0:	89 e8                	mov    %ebp,%eax
   16bc2:	0f be c0             	movsbl %al,%eax
   16bc5:	e8 95 ff ff ff       	call   16b5f <Is_Space>
   16bca:	84 c0                	test   %al,%al
   16bcc:	75 ec                	jne    16bba <Get_Argument_Block_Size+0x14>
    for (;;) {
	int len;

	s = Skip_Whitespace(s);
	/*Print("%s\n", s); */
	if (*s == '\0')
   16bce:	89 e8                	mov    %ebp,%eax
   16bd0:	84 c0                	test   %al,%al
   16bd2:	74 12                	je     16be6 <Get_Argument_Block_Size+0x40>
	    break;
	len = Get_Argument_Len(s);
   16bd4:	89 d8                	mov    %ebx,%eax
   16bd6:	e8 9f ff ff ff       	call   16b7a <Get_Argument_Len>
	s += len;
   16bdb:	01 c3                	add    %eax,%ebx

	size += sizeof(char *);  /* Pointer to the argument (in argv) */
	size += len + 1;  /* Buffer storing the argument, with nul terminator */
   16bdd:	8d 74 30 05          	lea    0x5(%eax,%esi,1),%esi
	++argCount;
   16be1:	83 c7 01             	add    $0x1,%edi
    while (Is_Space(*s))
   16be4:	eb d7                	jmp    16bbd <Get_Argument_Block_Size+0x17>
    }

    /* argv[] is terminated by a null pointer */
    size += sizeof(char *);

    *numArgs = argCount;
   16be6:	8b 44 24 18          	mov    0x18(%esp),%eax
   16bea:	89 38                	mov    %edi,(%eax)
    size += sizeof(char *);
   16bec:	83 c6 04             	add    $0x4,%esi
   16bef:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16bf3:	89 30                	mov    %esi,(%eax)
    *argBlockSize = size;

    /*Print("argCount=%d\n", argCount); */
}
   16bf5:	5b                   	pop    %ebx
   16bf6:	5e                   	pop    %esi
   16bf7:	5f                   	pop    %edi
   16bf8:	5d                   	pop    %ebp
   16bf9:	c3                   	ret    

00016bfa <Format_Argument_Block>:
 *   be located in user mode
 * @param command the command used to build the argument block
 */
void Format_Argument_Block(char *argBlock, unsigned numArgs, ulong_t userAddress,
    const char *command)
{
   16bfa:	55                   	push   %ebp
   16bfb:	57                   	push   %edi
   16bfc:	56                   	push   %esi
   16bfd:	53                   	push   %ebx
   16bfe:	83 ec 1c             	sub    $0x1c,%esp
   16c01:	e8 c0 9c ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   16c06:	05 fa f3 00 00       	add    $0xf3fa,%eax
   16c0b:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16c0f:	8b 44 24 34          	mov    0x34(%esp),%eax
   16c13:	8b 74 24 3c          	mov    0x3c(%esp),%esi
    ulong_t *argv;
    char *dst = argBlock;
    const char *s = command;

    /* Store argc in first word (argc field of Argument_Block) */
    *(int *)dst = numArgs;
   16c17:	8b 54 24 30          	mov    0x30(%esp),%edx
   16c1b:	89 02                	mov    %eax,(%edx)

    /*
     * Store pointer to argument vector array
     * (argv field of Argument_Block)
     */
    *(ulong_t *)dst = userAddress + sizeof(struct Argument_Block);
   16c1d:	8b 54 24 38          	mov    0x38(%esp),%edx
   16c21:	83 c2 08             	add    $0x8,%edx
   16c24:	8b 7c 24 30          	mov    0x30(%esp),%edi
   16c28:	89 57 04             	mov    %edx,0x4(%edi)
    dst += sizeof(char **);
   16c2b:	89 fa                	mov    %edi,%edx
   16c2d:	8d 7f 08             	lea    0x8(%edi),%edi

    /* Argv array immediately follows argv pointer */
    argv = (ulong_t *) dst;
    dst += (numArgs+1) * sizeof(char *);
   16c30:	8d 6c 82 0c          	lea    0xc(%edx,%eax,4),%ebp
   16c34:	eb 03                	jmp    16c39 <Format_Argument_Block+0x3f>
	++s;
   16c36:	83 c6 01             	add    $0x1,%esi
    while (Is_Space(*s))
   16c39:	0f b6 1e             	movzbl (%esi),%ebx
   16c3c:	0f be c3             	movsbl %bl,%eax
   16c3f:	e8 1b ff ff ff       	call   16b5f <Is_Space>
   16c44:	84 c0                	test   %al,%al
   16c46:	75 ee                	jne    16c36 <Format_Argument_Block+0x3c>

    /* The argument strings are located immediately after argv */
    for (;;) {
	s = Skip_Whitespace(s);
	if (*s == '\0')
   16c48:	84 db                	test   %bl,%bl
   16c4a:	74 3f                	je     16c8b <Format_Argument_Block+0x91>
	    break;
	*argv++ = userAddress + (dst - argBlock);  /* Set argv element */
   16c4c:	83 c7 04             	add    $0x4,%edi
   16c4f:	89 e8                	mov    %ebp,%eax
   16c51:	2b 44 24 30          	sub    0x30(%esp),%eax
   16c55:	03 44 24 38          	add    0x38(%esp),%eax
   16c59:	89 47 fc             	mov    %eax,-0x4(%edi)

	len = Get_Argument_Len(s);
   16c5c:	89 f0                	mov    %esi,%eax
   16c5e:	e8 17 ff ff ff       	call   16b7a <Get_Argument_Len>
	memcpy(dst, s, len);  /* Copy argument into arg block */
   16c63:	83 ec 04             	sub    $0x4,%esp
   16c66:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16c6a:	50                   	push   %eax
   16c6b:	56                   	push   %esi
   16c6c:	55                   	push   %ebp
   16c6d:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
   16c71:	e8 08 5e 00 00       	call   1ca7e <memcpy>
	dst += len;
   16c76:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   16c7a:	8d 44 0d 00          	lea    0x0(%ebp,%ecx,1),%eax
	*dst++ = '\0';  /* Nul-terminate the argument */
   16c7e:	8d 68 01             	lea    0x1(%eax),%ebp
   16c81:	c6 00 00             	movb   $0x0,(%eax)

	s += len;
   16c84:	01 ce                	add    %ecx,%esi
	s = Skip_Whitespace(s);
   16c86:	83 c4 10             	add    $0x10,%esp
    while (Is_Space(*s))
   16c89:	eb ae                	jmp    16c39 <Format_Argument_Block+0x3f>
    }

    /* Argv terminated by null pointer */
    *argv++ = 0;
   16c8b:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
   16c91:	83 c4 1c             	add    $0x1c,%esp
   16c94:	5b                   	pop    %ebx
   16c95:	5e                   	pop    %esi
   16c96:	5f                   	pop    %edi
   16c97:	5d                   	pop    %ebp
   16c98:	c3                   	ret    

00016c99 <Sys_Null>:
 *   always returns the value 0 (zero)
 */
static int Sys_Null(struct Interrupt_State* state)
{
    return 0;
}
   16c99:	b8 00 00 00 00       	mov    $0x0,%eax
   16c9e:	c3                   	ret    

00016c9f <Sys_GetPID>:
 * Params:
 *   state - processor registers from user mode
 * Returns: the pid of the current thread
 */
static int Sys_GetPID(struct Interrupt_State* state)
{
   16c9f:	e8 22 9c ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   16ca4:	05 5c f3 00 00       	add    $0xf35c,%eax
    return g_currentThread->pid;
   16ca9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16caf:	8b 00                	mov    (%eax),%eax
   16cb1:	8b 40 34             	mov    0x34(%eax),%eax
}
   16cb4:	c3                   	ret    

00016cb5 <Sys_SetAttr>:
{
   16cb5:	53                   	push   %ebx
   16cb6:	83 ec 14             	sub    $0x14,%esp
   16cb9:	e8 54 95 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16cbe:	81 c3 42 f3 00 00    	add    $0xf342,%ebx
    Set_Current_Attr(state->ebx);
   16cc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16cc8:	0f b6 40 24          	movzbl 0x24(%eax),%eax
   16ccc:	50                   	push   %eax
   16ccd:	e8 57 a4 ff ff       	call   11129 <Set_Current_Attr>
}
   16cd2:	83 c4 18             	add    $0x18,%esp
   16cd5:	5b                   	pop    %ebx
   16cd6:	c3                   	ret    

00016cd7 <Sys_Wait>:
{
   16cd7:	56                   	push   %esi
   16cd8:	53                   	push   %ebx
   16cd9:	83 ec 10             	sub    $0x10,%esp
   16cdc:	e8 31 95 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16ce1:	81 c3 1f f3 00 00    	add    $0xf31f,%ebx
    struct Kernel_Thread* thread = Lookup_Thread(state->ebx);
   16ce7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16ceb:	ff 70 24             	pushl  0x24(%eax)
   16cee:	e8 1b e6 ff ff       	call   1530e <Lookup_Thread>
    if (!thread) return -1;
   16cf3:	83 c4 10             	add    $0x10,%esp
   16cf6:	85 c0                	test   %eax,%eax
   16cf8:	0f 84 b4 00 00 00    	je     16db2 <Sys_Wait+0xdb>
   16cfe:	89 c6                	mov    %eax,%esi
    Enable_Interrupts();
   16d00:	e8 47 95 ff ff       	call   1024c <Interrupts_Enabled>
   16d05:	84 c0                	test   %al,%al
   16d07:	74 44                	je     16d4d <Sys_Wait+0x76>
   16d09:	83 ec 0c             	sub    $0xc,%esp
   16d0c:	6a 4f                	push   $0x4f
   16d0e:	e8 16 a4 ff ff       	call   11129 <Set_Current_Attr>
   16d13:	83 c4 0c             	add    $0xc,%esp
   16d16:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16d1c:	ff 30                	pushl  (%eax)
   16d1e:	ff 74 24 14          	pushl  0x14(%esp)
   16d22:	68 b3 00 00 00       	push   $0xb3
   16d27:	8d 83 1d 83 ff ff    	lea    -0x7ce3(%ebx),%eax
   16d2d:	50                   	push   %eax
   16d2e:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   16d34:	50                   	push   %eax
   16d35:	8d 83 44 83 ff ff    	lea    -0x7cbc(%ebx),%eax
   16d3b:	50                   	push   %eax
   16d3c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16d42:	50                   	push   %eax
   16d43:	e8 92 a2 ff ff       	call   10fda <Print>
   16d48:	83 c4 20             	add    $0x20,%esp
   16d4b:	eb fe                	jmp    16d4b <Sys_Wait+0x74>
   16d4d:	fb                   	sti    
    int exit = Join(thread);
   16d4e:	83 ec 0c             	sub    $0xc,%esp
   16d51:	56                   	push   %esi
   16d52:	e8 b2 ec ff ff       	call   15a09 <Join>
   16d57:	89 c6                	mov    %eax,%esi
    Disable_Interrupts();
   16d59:	e8 ee 94 ff ff       	call   1024c <Interrupts_Enabled>
   16d5e:	83 c4 10             	add    $0x10,%esp
   16d61:	84 c0                	test   %al,%al
   16d63:	74 09                	je     16d6e <Sys_Wait+0x97>
    __asm__ __volatile__ ("cli");
   16d65:	fa                   	cli    
}
   16d66:	89 f0                	mov    %esi,%eax
   16d68:	83 c4 04             	add    $0x4,%esp
   16d6b:	5b                   	pop    %ebx
   16d6c:	5e                   	pop    %esi
   16d6d:	c3                   	ret    
    Disable_Interrupts();
   16d6e:	83 ec 0c             	sub    $0xc,%esp
   16d71:	6a 4f                	push   $0x4f
   16d73:	e8 b1 a3 ff ff       	call   11129 <Set_Current_Attr>
   16d78:	83 c4 0c             	add    $0xc,%esp
   16d7b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16d81:	ff 30                	pushl  (%eax)
   16d83:	ff 74 24 14          	pushl  0x14(%esp)
   16d87:	68 b5 00 00 00       	push   $0xb5
   16d8c:	8d 83 1d 83 ff ff    	lea    -0x7ce3(%ebx),%eax
   16d92:	50                   	push   %eax
   16d93:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   16d99:	50                   	push   %eax
   16d9a:	8d 83 44 83 ff ff    	lea    -0x7cbc(%ebx),%eax
   16da0:	50                   	push   %eax
   16da1:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16da7:	50                   	push   %eax
   16da8:	e8 2d a2 ff ff       	call   10fda <Print>
   16dad:	83 c4 20             	add    $0x20,%esp
   16db0:	eb fe                	jmp    16db0 <Sys_Wait+0xd9>
    if (!thread) return -1;
   16db2:	be ff ff ff ff       	mov    $0xffffffff,%esi
   16db7:	eb ad                	jmp    16d66 <Sys_Wait+0x8f>

00016db9 <Sys_Spawn>:
{
   16db9:	55                   	push   %ebp
   16dba:	57                   	push   %edi
   16dbb:	56                   	push   %esi
   16dbc:	53                   	push   %ebx
   16dbd:	83 ec 38             	sub    $0x38,%esp
   16dc0:	e8 4d 94 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16dc5:	81 c3 3b f2 00 00    	add    $0xf23b,%ebx
   16dcb:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    uint_t len_path = state->ecx;
   16dcf:	8b 68 20             	mov    0x20(%eax),%ebp
    uint_t len_cmd = state->esi;
   16dd2:	8b 78 18             	mov    0x18(%eax),%edi
    uint_t ptr_path = state->ebx;
   16dd5:	8b 50 24             	mov    0x24(%eax),%edx
   16dd8:	89 54 24 14          	mov    %edx,0x14(%esp)
    uint_t ptr_cmd = state->edx;
   16ddc:	8b 40 1c             	mov    0x1c(%eax),%eax
   16ddf:	89 44 24 18          	mov    %eax,0x18(%esp)
    char* path = Malloc(len_path);
   16de3:	55                   	push   %ebp
   16de4:	e8 c3 cd ff ff       	call   13bac <Malloc>
    if (path == 0) return -1;
   16de9:	83 c4 10             	add    $0x10,%esp
   16dec:	85 c0                	test   %eax,%eax
   16dee:	0f 84 4f 01 00 00    	je     16f43 <Sys_Spawn+0x18a>
   16df4:	89 c6                	mov    %eax,%esi
    if (!Copy_From_User(path, ptr_path, len_path)) {
   16df6:	83 ec 04             	sub    $0x4,%esp
   16df9:	55                   	push   %ebp
   16dfa:	ff 74 24 10          	pushl  0x10(%esp)
   16dfe:	50                   	push   %eax
   16dff:	e8 ab fc ff ff       	call   16aaf <Copy_From_User>
   16e04:	83 c4 10             	add    $0x10,%esp
   16e07:	84 c0                	test   %al,%al
   16e09:	74 78                	je     16e83 <Sys_Spawn+0xca>
    char* cmd = Malloc(len_cmd);
   16e0b:	83 ec 0c             	sub    $0xc,%esp
   16e0e:	57                   	push   %edi
   16e0f:	e8 98 cd ff ff       	call   13bac <Malloc>
   16e14:	89 c5                	mov    %eax,%ebp
    if (cmd == 0) return -1;
   16e16:	83 c4 10             	add    $0x10,%esp
   16e19:	85 c0                	test   %eax,%eax
   16e1b:	0f 84 29 01 00 00    	je     16f4a <Sys_Spawn+0x191>
    if (!Copy_From_User(cmd, ptr_cmd, len_cmd)) {
   16e21:	83 ec 04             	sub    $0x4,%esp
   16e24:	57                   	push   %edi
   16e25:	ff 74 24 14          	pushl  0x14(%esp)
   16e29:	50                   	push   %eax
   16e2a:	e8 80 fc ff ff       	call   16aaf <Copy_From_User>
   16e2f:	83 c4 10             	add    $0x10,%esp
   16e32:	84 c0                	test   %al,%al
   16e34:	74 63                	je     16e99 <Sys_Spawn+0xe0>
    Enable_Interrupts();
   16e36:	e8 11 94 ff ff       	call   1024c <Interrupts_Enabled>
   16e3b:	84 c0                	test   %al,%al
   16e3d:	74 78                	je     16eb7 <Sys_Spawn+0xfe>
   16e3f:	83 ec 0c             	sub    $0xc,%esp
   16e42:	6a 4f                	push   $0x4f
   16e44:	e8 e0 a2 ff ff       	call   11129 <Set_Current_Attr>
   16e49:	83 c4 0c             	add    $0xc,%esp
   16e4c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16e52:	ff 30                	pushl  (%eax)
   16e54:	ff 74 24 44          	pushl  0x44(%esp)
   16e58:	68 9d 00 00 00       	push   $0x9d
   16e5d:	8d 83 1d 83 ff ff    	lea    -0x7ce3(%ebx),%eax
   16e63:	50                   	push   %eax
   16e64:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   16e6a:	50                   	push   %eax
   16e6b:	8d 83 38 83 ff ff    	lea    -0x7cc8(%ebx),%eax
   16e71:	50                   	push   %eax
   16e72:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16e78:	50                   	push   %eax
   16e79:	e8 5c a1 ff ff       	call   10fda <Print>
   16e7e:	83 c4 20             	add    $0x20,%esp
   16e81:	eb fe                	jmp    16e81 <Sys_Spawn+0xc8>
        Free(path);
   16e83:	83 ec 0c             	sub    $0xc,%esp
   16e86:	56                   	push   %esi
   16e87:	e8 9e ce ff ff       	call   13d2a <Free>
        return -1;
   16e8c:	83 c4 10             	add    $0x10,%esp
   16e8f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   16e94:	e9 a0 00 00 00       	jmp    16f39 <Sys_Spawn+0x180>
        Free(cmd);
   16e99:	83 ec 0c             	sub    $0xc,%esp
   16e9c:	55                   	push   %ebp
   16e9d:	e8 88 ce ff ff       	call   13d2a <Free>
        Free(path);
   16ea2:	89 34 24             	mov    %esi,(%esp)
   16ea5:	e8 80 ce ff ff       	call   13d2a <Free>
        return -1;
   16eaa:	83 c4 10             	add    $0x10,%esp
   16ead:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   16eb2:	e9 82 00 00 00       	jmp    16f39 <Sys_Spawn+0x180>
    __asm__ __volatile__ ("sti");
   16eb7:	fb                   	sti    
    rc = Spawn(path, cmd, &newThread);
   16eb8:	83 ec 04             	sub    $0x4,%esp
   16ebb:	8d 44 24 20          	lea    0x20(%esp),%eax
   16ebf:	50                   	push   %eax
   16ec0:	55                   	push   %ebp
   16ec1:	56                   	push   %esi
   16ec2:	e8 30 f7 ff ff       	call   165f7 <Spawn>
   16ec7:	89 c7                	mov    %eax,%edi
    if (!rc) {
   16ec9:	83 c4 10             	add    $0x10,%esp
   16ecc:	85 c0                	test   %eax,%eax
   16ece:	75 07                	jne    16ed7 <Sys_Spawn+0x11e>
        rc = newThread->pid;
   16ed0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   16ed4:	8b 78 34             	mov    0x34(%eax),%edi
    Disable_Interrupts();
   16ed7:	e8 70 93 ff ff       	call   1024c <Interrupts_Enabled>
   16edc:	84 c0                	test   %al,%al
   16ede:	75 44                	jne    16f24 <Sys_Spawn+0x16b>
   16ee0:	83 ec 0c             	sub    $0xc,%esp
   16ee3:	6a 4f                	push   $0x4f
   16ee5:	e8 3f a2 ff ff       	call   11129 <Set_Current_Attr>
   16eea:	83 c4 0c             	add    $0xc,%esp
   16eed:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   16ef3:	ff 30                	pushl  (%eax)
   16ef5:	ff 74 24 44          	pushl  0x44(%esp)
   16ef9:	68 a2 00 00 00       	push   $0xa2
   16efe:	8d 83 1d 83 ff ff    	lea    -0x7ce3(%ebx),%eax
   16f04:	50                   	push   %eax
   16f05:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   16f0b:	50                   	push   %eax
   16f0c:	8d 83 38 83 ff ff    	lea    -0x7cc8(%ebx),%eax
   16f12:	50                   	push   %eax
   16f13:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   16f19:	50                   	push   %eax
   16f1a:	e8 bb a0 ff ff       	call   10fda <Print>
   16f1f:	83 c4 20             	add    $0x20,%esp
   16f22:	eb fe                	jmp    16f22 <Sys_Spawn+0x169>
    __asm__ __volatile__ ("cli");
   16f24:	fa                   	cli    
    Free(path);
   16f25:	83 ec 0c             	sub    $0xc,%esp
   16f28:	56                   	push   %esi
   16f29:	e8 fc cd ff ff       	call   13d2a <Free>
    Free(cmd);
   16f2e:	89 2c 24             	mov    %ebp,(%esp)
   16f31:	e8 f4 cd ff ff       	call   13d2a <Free>
    return rc;
   16f36:	83 c4 10             	add    $0x10,%esp
}
   16f39:	89 f8                	mov    %edi,%eax
   16f3b:	83 c4 2c             	add    $0x2c,%esp
   16f3e:	5b                   	pop    %ebx
   16f3f:	5e                   	pop    %esi
   16f40:	5f                   	pop    %edi
   16f41:	5d                   	pop    %ebp
   16f42:	c3                   	ret    
    if (path == 0) return -1;
   16f43:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   16f48:	eb ef                	jmp    16f39 <Sys_Spawn+0x180>
    if (cmd == 0) return -1;
   16f4a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   16f4f:	eb e8                	jmp    16f39 <Sys_Spawn+0x180>

00016f51 <Sys_PutCursor>:
{
   16f51:	53                   	push   %ebx
   16f52:	83 ec 10             	sub    $0x10,%esp
   16f55:	e8 b8 92 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16f5a:	81 c3 a6 f0 00 00    	add    $0xf0a6,%ebx
   16f60:	8b 44 24 18          	mov    0x18(%esp),%eax
    return Put_Cursor(state->ebx, state->ecx);
   16f64:	ff 70 20             	pushl  0x20(%eax)
   16f67:	ff 70 24             	pushl  0x24(%eax)
   16f6a:	e8 e5 a2 ff ff       	call   11254 <Put_Cursor>
   16f6f:	0f b6 c0             	movzbl %al,%eax
}
   16f72:	83 c4 18             	add    $0x18,%esp
   16f75:	5b                   	pop    %ebx
   16f76:	c3                   	ret    

00016f77 <Sys_GetCursor>:
{
   16f77:	57                   	push   %edi
   16f78:	56                   	push   %esi
   16f79:	53                   	push   %ebx
   16f7a:	83 ec 18             	sub    $0x18,%esp
   16f7d:	e8 90 92 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16f82:	81 c3 7e f0 00 00    	add    $0xf07e,%ebx
   16f88:	8b 7c 24 28          	mov    0x28(%esp),%edi
    Get_Cursor(&row, &col);
   16f8c:	8d 44 24 10          	lea    0x10(%esp),%eax
   16f90:	50                   	push   %eax
   16f91:	8d 74 24 18          	lea    0x18(%esp),%esi
   16f95:	56                   	push   %esi
   16f96:	e8 1c a5 ff ff       	call   114b7 <Get_Cursor>
    int rc = Copy_To_User(state->ebx, &row, sizeof(row));
   16f9b:	83 c4 0c             	add    $0xc,%esp
   16f9e:	6a 04                	push   $0x4
   16fa0:	56                   	push   %esi
   16fa1:	ff 77 24             	pushl  0x24(%edi)
   16fa4:	e8 58 fb ff ff       	call   16b01 <Copy_To_User>
    if (!rc) return -1;
   16fa9:	83 c4 10             	add    $0x10,%esp
   16fac:	84 c0                	test   %al,%al
   16fae:	74 24                	je     16fd4 <Sys_GetCursor+0x5d>
    rc = Copy_To_User(state->ecx, &col, sizeof(col));
   16fb0:	83 ec 04             	sub    $0x4,%esp
   16fb3:	6a 04                	push   $0x4
   16fb5:	8d 44 24 10          	lea    0x10(%esp),%eax
   16fb9:	50                   	push   %eax
   16fba:	ff 77 20             	pushl  0x20(%edi)
   16fbd:	e8 3f fb ff ff       	call   16b01 <Copy_To_User>
    if (!rc) return -1;
   16fc2:	83 f0 01             	xor    $0x1,%eax
   16fc5:	0f b6 c0             	movzbl %al,%eax
   16fc8:	f7 d8                	neg    %eax
   16fca:	83 c4 10             	add    $0x10,%esp
}
   16fcd:	83 c4 10             	add    $0x10,%esp
   16fd0:	5b                   	pop    %ebx
   16fd1:	5e                   	pop    %esi
   16fd2:	5f                   	pop    %edi
   16fd3:	c3                   	ret    
    if (!rc) return -1;
   16fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16fd9:	eb f2                	jmp    16fcd <Sys_GetCursor+0x56>

00016fdb <Sys_GetKey>:
{
   16fdb:	53                   	push   %ebx
   16fdc:	83 ec 08             	sub    $0x8,%esp
   16fdf:	e8 2e 92 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   16fe4:	81 c3 1c f0 00 00    	add    $0xf01c,%ebx
    return Wait_For_Key();
   16fea:	e8 8a 9c ff ff       	call   10c79 <Wait_For_Key>
   16fef:	0f b7 c0             	movzwl %ax,%eax
}
   16ff2:	83 c4 08             	add    $0x8,%esp
   16ff5:	5b                   	pop    %ebx
   16ff6:	c3                   	ret    

00016ff7 <Sys_PrintString>:
{
   16ff7:	55                   	push   %ebp
   16ff8:	57                   	push   %edi
   16ff9:	56                   	push   %esi
   16ffa:	53                   	push   %ebx
   16ffb:	83 ec 0c             	sub    $0xc,%esp
   16ffe:	e8 0f 92 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17003:	81 c3 fd ef 00 00    	add    $0xeffd,%ebx
   17009:	8b 44 24 20          	mov    0x20(%esp),%eax
    uint_t len = state->ecx;
   1700d:	8b 70 20             	mov    0x20(%eax),%esi
    if (len <= 0) return;
   17010:	85 f6                	test   %esi,%esi
   17012:	75 08                	jne    1701c <Sys_PrintString+0x25>
}
   17014:	83 c4 0c             	add    $0xc,%esp
   17017:	5b                   	pop    %ebx
   17018:	5e                   	pop    %esi
   17019:	5f                   	pop    %edi
   1701a:	5d                   	pop    %ebp
   1701b:	c3                   	ret    
    uint_t ptr = state->ebx;
   1701c:	8b 68 24             	mov    0x24(%eax),%ebp
    void* buf = Malloc(len);
   1701f:	83 ec 0c             	sub    $0xc,%esp
   17022:	56                   	push   %esi
   17023:	e8 84 cb ff ff       	call   13bac <Malloc>
   17028:	89 c7                	mov    %eax,%edi
    if (!buf) return -1;
   1702a:	83 c4 10             	add    $0x10,%esp
   1702d:	85 c0                	test   %eax,%eax
   1702f:	74 39                	je     1706a <Sys_PrintString+0x73>
    if (!Copy_From_User(buf, ptr, len)) {
   17031:	83 ec 04             	sub    $0x4,%esp
   17034:	56                   	push   %esi
   17035:	55                   	push   %ebp
   17036:	50                   	push   %eax
   17037:	e8 73 fa ff ff       	call   16aaf <Copy_From_User>
   1703c:	83 c4 10             	add    $0x10,%esp
   1703f:	84 c0                	test   %al,%al
   17041:	74 14                	je     17057 <Sys_PrintString+0x60>
    Put_Buf(buf, len);
   17043:	83 ec 08             	sub    $0x8,%esp
   17046:	56                   	push   %esi
   17047:	57                   	push   %edi
   17048:	e8 44 ae ff ff       	call   11e91 <Put_Buf>
    return 0;
   1704d:	83 c4 10             	add    $0x10,%esp
   17050:	b8 00 00 00 00       	mov    $0x0,%eax
   17055:	eb bd                	jmp    17014 <Sys_PrintString+0x1d>
        Free(buf);
   17057:	83 ec 0c             	sub    $0xc,%esp
   1705a:	57                   	push   %edi
   1705b:	e8 ca cc ff ff       	call   13d2a <Free>
        return -1;
   17060:	83 c4 10             	add    $0x10,%esp
   17063:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17068:	eb aa                	jmp    17014 <Sys_PrintString+0x1d>
    if (!buf) return -1;
   1706a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1706f:	eb a3                	jmp    17014 <Sys_PrintString+0x1d>

00017071 <Sys_Exit>:
{
   17071:	53                   	push   %ebx
   17072:	83 ec 14             	sub    $0x14,%esp
   17075:	e8 98 91 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1707a:	81 c3 86 ef 00 00    	add    $0xef86,%ebx
    Exit(state->ebx);
   17080:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17084:	ff 70 24             	pushl  0x24(%eax)
   17087:	e8 f8 ea ff ff       	call   15b84 <Exit>

0001708c <Init_DMA>:

/**
 * Initialize the DMA controllers.
 */
void Init_DMA(void)
{
   1708c:	53                   	push   %ebx
   1708d:	83 ec 14             	sub    $0x14,%esp
   17090:	e8 7d 91 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17095:	81 c3 6b ef 00 00    	add    $0xef6b,%ebx
    Print("Initializing DMA Controller...\n");
   1709b:	8d 83 54 83 ff ff    	lea    -0x7cac(%ebx),%eax
   170a1:	50                   	push   %eax
   170a2:	e8 33 9f ff ff       	call   10fda <Print>

    /* Reset the controller */
    Out_Byte(DMA_MASTER_CLEAR_REG, 0);
   170a7:	83 c4 08             	add    $0x8,%esp
   170aa:	6a 00                	push   $0x0
   170ac:	6a 0d                	push   $0xd
   170ae:	e8 17 98 ff ff       	call   108ca <Out_Byte>
}
   170b3:	83 c4 18             	add    $0x18,%esp
   170b6:	5b                   	pop    %ebx
   170b7:	c3                   	ret    

000170b8 <Reserve_DMA>:
 * Reserve given DMA channel.
 * @param chan the channel to reserve
 * @return true if successful, false if not
 */
bool Reserve_DMA(int chan)
{
   170b8:	55                   	push   %ebp
   170b9:	57                   	push   %edi
   170ba:	56                   	push   %esi
   170bb:	53                   	push   %ebx
   170bc:	83 ec 0c             	sub    $0xc,%esp
   170bf:	e8 4e 91 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   170c4:	81 c3 3c ef 00 00    	add    $0xef3c,%ebx
   170ca:	8b 74 24 20          	mov    0x20(%esp),%esi
    bool enabled = Interrupts_Enabled();
   170ce:	e8 79 91 ff ff       	call   1024c <Interrupts_Enabled>
   170d3:	89 c5                	mov    %eax,%ebp
    if (enabled)
   170d5:	84 c0                	test   %al,%al
   170d7:	75 3f                	jne    17118 <Reserve_DMA+0x60>
    bool iflag = Begin_Int_Atomic();
    bool result = false;

    KASSERT(VALID_CHANNEL(chan));
   170d9:	83 fe 03             	cmp    $0x3,%esi
   170dc:	0f 87 86 00 00 00    	ja     17168 <Reserve_DMA+0xb0>

    if (!IS_RESERVED(chan)) {
   170e2:	0f b6 83 08 13 00 00 	movzbl 0x1308(%ebx),%eax
    bool result = false;
   170e9:	bf 00 00 00 00       	mov    $0x0,%edi
    if (!IS_RESERVED(chan)) {
   170ee:	0f a3 f0             	bt     %esi,%eax
   170f1:	0f 83 b5 00 00 00    	jae    171ac <Reserve_DMA+0xf4>
    KASSERT(!Interrupts_Enabled());
   170f7:	e8 50 91 ff ff       	call   1024c <Interrupts_Enabled>
   170fc:	84 c0                	test   %al,%al
   170fe:	0f 85 d4 00 00 00    	jne    171d8 <Reserve_DMA+0x120>
    if (iflag) {
   17104:	89 e8                	mov    %ebp,%eax
   17106:	84 c0                	test   %al,%al
   17108:	0f 85 0e 01 00 00    	jne    1721c <Reserve_DMA+0x164>
    }

    End_Int_Atomic(iflag);

    return result;
}
   1710e:	89 f8                	mov    %edi,%eax
   17110:	83 c4 0c             	add    $0xc,%esp
   17113:	5b                   	pop    %ebx
   17114:	5e                   	pop    %esi
   17115:	5f                   	pop    %edi
   17116:	5d                   	pop    %ebp
   17117:	c3                   	ret    
	Disable_Interrupts();
   17118:	e8 2f 91 ff ff       	call   1024c <Interrupts_Enabled>
   1711d:	84 c0                	test   %al,%al
   1711f:	74 03                	je     17124 <Reserve_DMA+0x6c>
    __asm__ __volatile__ ("cli");
   17121:	fa                   	cli    
}
   17122:	eb b5                	jmp    170d9 <Reserve_DMA+0x21>
	Disable_Interrupts();
   17124:	83 ec 0c             	sub    $0xc,%esp
   17127:	6a 4f                	push   $0x4f
   17129:	e8 fb 9f ff ff       	call   11129 <Set_Current_Attr>
   1712e:	83 c4 0c             	add    $0xc,%esp
   17131:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17137:	ff 30                	pushl  (%eax)
   17139:	ff 74 24 24          	pushl  0x24(%esp)
   1713d:	68 8f 00 00 00       	push   $0x8f
   17142:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   17148:	50                   	push   %eax
   17149:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1714f:	50                   	push   %eax
   17150:	8d 83 4c 84 ff ff    	lea    -0x7bb4(%ebx),%eax
   17156:	50                   	push   %eax
   17157:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1715d:	50                   	push   %eax
   1715e:	e8 77 9e ff ff       	call   10fda <Print>
   17163:	83 c4 20             	add    $0x20,%esp
   17166:	eb fe                	jmp    17166 <Reserve_DMA+0xae>
    KASSERT(VALID_CHANNEL(chan));
   17168:	83 ec 0c             	sub    $0xc,%esp
   1716b:	6a 4f                	push   $0x4f
   1716d:	e8 b7 9f ff ff       	call   11129 <Set_Current_Attr>
   17172:	83 c4 0c             	add    $0xc,%esp
   17175:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1717b:	ff 30                	pushl  (%eax)
   1717d:	ff 74 24 24          	pushl  0x24(%esp)
   17181:	68 94 00 00 00       	push   $0x94
   17186:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   1718c:	50                   	push   %eax
   1718d:	8d 83 db 83 ff ff    	lea    -0x7c25(%ebx),%eax
   17193:	50                   	push   %eax
   17194:	8d 83 60 84 ff ff    	lea    -0x7ba0(%ebx),%eax
   1719a:	50                   	push   %eax
   1719b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   171a1:	50                   	push   %eax
   171a2:	e8 33 9e ff ff       	call   10fda <Print>
   171a7:	83 c4 20             	add    $0x20,%esp
   171aa:	eb fe                	jmp    171aa <Reserve_DMA+0xf2>
	Out_Byte(DMA_MASK_ONE_REG, chan & 3);
   171ac:	83 ec 08             	sub    $0x8,%esp
   171af:	89 f0                	mov    %esi,%eax
   171b1:	83 e0 03             	and    $0x3,%eax
   171b4:	50                   	push   %eax
   171b5:	6a 0a                	push   $0xa
   171b7:	e8 0e 97 ff ff       	call   108ca <Out_Byte>
	s_allocated |= (1 << chan);
   171bc:	b8 01 00 00 00       	mov    $0x1,%eax
   171c1:	89 f1                	mov    %esi,%ecx
   171c3:	d3 e0                	shl    %cl,%eax
   171c5:	08 83 08 13 00 00    	or     %al,0x1308(%ebx)
   171cb:	83 c4 10             	add    $0x10,%esp
	result = true;
   171ce:	bf 01 00 00 00       	mov    $0x1,%edi
   171d3:	e9 1f ff ff ff       	jmp    170f7 <Reserve_DMA+0x3f>
    KASSERT(!Interrupts_Enabled());
   171d8:	83 ec 0c             	sub    $0xc,%esp
   171db:	6a 4f                	push   $0x4f
   171dd:	e8 47 9f ff ff       	call   11129 <Set_Current_Attr>
   171e2:	83 c4 0c             	add    $0xc,%esp
   171e5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   171eb:	ff 30                	pushl  (%eax)
   171ed:	ff 74 24 24          	pushl  0x24(%esp)
   171f1:	68 99 00 00 00       	push   $0x99
   171f6:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   171fc:	50                   	push   %eax
   171fd:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   17203:	50                   	push   %eax
   17204:	8d 83 3c 84 ff ff    	lea    -0x7bc4(%ebx),%eax
   1720a:	50                   	push   %eax
   1720b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17211:	50                   	push   %eax
   17212:	e8 c3 9d ff ff       	call   10fda <Print>
   17217:	83 c4 20             	add    $0x20,%esp
   1721a:	eb fe                	jmp    1721a <Reserve_DMA+0x162>
	Enable_Interrupts();
   1721c:	e8 2b 90 ff ff       	call   1024c <Interrupts_Enabled>
   17221:	84 c0                	test   %al,%al
   17223:	75 06                	jne    1722b <Reserve_DMA+0x173>
    __asm__ __volatile__ ("sti");
   17225:	fb                   	sti    
    return result;
   17226:	e9 e3 fe ff ff       	jmp    1710e <Reserve_DMA+0x56>
	Enable_Interrupts();
   1722b:	83 ec 0c             	sub    $0xc,%esp
   1722e:	6a 4f                	push   $0x4f
   17230:	e8 f4 9e ff ff       	call   11129 <Set_Current_Attr>
   17235:	83 c4 0c             	add    $0xc,%esp
   17238:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1723e:	ff 30                	pushl  (%eax)
   17240:	ff 74 24 24          	pushl  0x24(%esp)
   17244:	68 9c 00 00 00       	push   $0x9c
   17249:	8d 83 da 72 ff ff    	lea    -0x8d26(%ebx),%eax
   1724f:	50                   	push   %eax
   17250:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   17256:	50                   	push   %eax
   17257:	8d 83 3c 84 ff ff    	lea    -0x7bc4(%ebx),%eax
   1725d:	50                   	push   %eax
   1725e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17264:	50                   	push   %eax
   17265:	e8 70 9d ff ff       	call   10fda <Print>
   1726a:	83 c4 20             	add    $0x20,%esp
   1726d:	eb fe                	jmp    1726d <Reserve_DMA+0x1b5>

0001726f <Mask_DMA>:
 * Mask given DMA channel.
 * The channel must have already been reserved.
 * @param chan the channel
 */
void Mask_DMA(int chan)
{
   1726f:	53                   	push   %ebx
   17270:	83 ec 08             	sub    $0x8,%esp
   17273:	e8 9a 8f ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17278:	81 c3 88 ed 00 00    	add    $0xed88,%ebx
   1727e:	8b 44 24 10          	mov    0x10(%esp),%eax
    KASSERT(VALID_CHANNEL(chan));
   17282:	83 f8 03             	cmp    $0x3,%eax
   17285:	77 54                	ja     172db <Mask_DMA+0x6c>
    KASSERT(IS_RESERVED(chan));
   17287:	0f b6 93 08 13 00 00 	movzbl 0x1308(%ebx),%edx
   1728e:	0f a3 c2             	bt     %eax,%edx
   17291:	0f 82 88 00 00 00    	jb     1731f <Mask_DMA+0xb0>
   17297:	83 ec 0c             	sub    $0xc,%esp
   1729a:	6a 4f                	push   $0x4f
   1729c:	e8 88 9e ff ff       	call   11129 <Set_Current_Attr>
   172a1:	83 c4 0c             	add    $0xc,%esp
   172a4:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   172aa:	ff 30                	pushl  (%eax)
   172ac:	ff 74 24 14          	pushl  0x14(%esp)
   172b0:	68 e8 00 00 00       	push   $0xe8
   172b5:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   172bb:	50                   	push   %eax
   172bc:	8d 83 ef 83 ff ff    	lea    -0x7c11(%ebx),%eax
   172c2:	50                   	push   %eax
   172c3:	8d 83 24 84 ff ff    	lea    -0x7bdc(%ebx),%eax
   172c9:	50                   	push   %eax
   172ca:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   172d0:	50                   	push   %eax
   172d1:	e8 04 9d ff ff       	call   10fda <Print>
   172d6:	83 c4 20             	add    $0x20,%esp
   172d9:	eb fe                	jmp    172d9 <Mask_DMA+0x6a>
    KASSERT(VALID_CHANNEL(chan));
   172db:	83 ec 0c             	sub    $0xc,%esp
   172de:	6a 4f                	push   $0x4f
   172e0:	e8 44 9e ff ff       	call   11129 <Set_Current_Attr>
   172e5:	83 c4 0c             	add    $0xc,%esp
   172e8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   172ee:	ff 30                	pushl  (%eax)
   172f0:	ff 74 24 14          	pushl  0x14(%esp)
   172f4:	68 e7 00 00 00       	push   $0xe7
   172f9:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   172ff:	50                   	push   %eax
   17300:	8d 83 db 83 ff ff    	lea    -0x7c25(%ebx),%eax
   17306:	50                   	push   %eax
   17307:	8d 83 24 84 ff ff    	lea    -0x7bdc(%ebx),%eax
   1730d:	50                   	push   %eax
   1730e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17314:	50                   	push   %eax
   17315:	e8 c0 9c ff ff       	call   10fda <Print>
   1731a:	83 c4 20             	add    $0x20,%esp
   1731d:	eb fe                	jmp    1731d <Mask_DMA+0xae>

    Out_Byte(DMA_MASK_ONE_REG, (1 << 2) | (chan & 3));
   1731f:	83 ec 08             	sub    $0x8,%esp
   17322:	83 c8 04             	or     $0x4,%eax
   17325:	0f b6 c0             	movzbl %al,%eax
   17328:	50                   	push   %eax
   17329:	6a 0a                	push   $0xa
   1732b:	e8 9a 95 ff ff       	call   108ca <Out_Byte>
}
   17330:	83 c4 18             	add    $0x18,%esp
   17333:	5b                   	pop    %ebx
   17334:	c3                   	ret    

00017335 <Unmask_DMA>:
 * Unmask given DMA channel.
 * The channel must have already been reserved.
 * @param chan the channel
 */
void Unmask_DMA(int chan)
{
   17335:	53                   	push   %ebx
   17336:	83 ec 08             	sub    $0x8,%esp
   17339:	e8 d4 8e ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1733e:	81 c3 c2 ec 00 00    	add    $0xecc2,%ebx
   17344:	8b 44 24 10          	mov    0x10(%esp),%eax
    KASSERT(VALID_CHANNEL(chan));
   17348:	83 f8 03             	cmp    $0x3,%eax
   1734b:	77 54                	ja     173a1 <Unmask_DMA+0x6c>
    KASSERT(IS_RESERVED(chan));
   1734d:	0f b6 93 08 13 00 00 	movzbl 0x1308(%ebx),%edx
   17354:	0f a3 c2             	bt     %eax,%edx
   17357:	0f 82 88 00 00 00    	jb     173e5 <Unmask_DMA+0xb0>
   1735d:	83 ec 0c             	sub    $0xc,%esp
   17360:	6a 4f                	push   $0x4f
   17362:	e8 c2 9d ff ff       	call   11129 <Set_Current_Attr>
   17367:	83 c4 0c             	add    $0xc,%esp
   1736a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17370:	ff 30                	pushl  (%eax)
   17372:	ff 74 24 14          	pushl  0x14(%esp)
   17376:	68 f5 00 00 00       	push   $0xf5
   1737b:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   17381:	50                   	push   %eax
   17382:	8d 83 ef 83 ff ff    	lea    -0x7c11(%ebx),%eax
   17388:	50                   	push   %eax
   17389:	8d 83 18 84 ff ff    	lea    -0x7be8(%ebx),%eax
   1738f:	50                   	push   %eax
   17390:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17396:	50                   	push   %eax
   17397:	e8 3e 9c ff ff       	call   10fda <Print>
   1739c:	83 c4 20             	add    $0x20,%esp
   1739f:	eb fe                	jmp    1739f <Unmask_DMA+0x6a>
    KASSERT(VALID_CHANNEL(chan));
   173a1:	83 ec 0c             	sub    $0xc,%esp
   173a4:	6a 4f                	push   $0x4f
   173a6:	e8 7e 9d ff ff       	call   11129 <Set_Current_Attr>
   173ab:	83 c4 0c             	add    $0xc,%esp
   173ae:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   173b4:	ff 30                	pushl  (%eax)
   173b6:	ff 74 24 14          	pushl  0x14(%esp)
   173ba:	68 f4 00 00 00       	push   $0xf4
   173bf:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   173c5:	50                   	push   %eax
   173c6:	8d 83 db 83 ff ff    	lea    -0x7c25(%ebx),%eax
   173cc:	50                   	push   %eax
   173cd:	8d 83 18 84 ff ff    	lea    -0x7be8(%ebx),%eax
   173d3:	50                   	push   %eax
   173d4:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   173da:	50                   	push   %eax
   173db:	e8 fa 9b ff ff       	call   10fda <Print>
   173e0:	83 c4 20             	add    $0x20,%esp
   173e3:	eb fe                	jmp    173e3 <Unmask_DMA+0xae>

    Out_Byte(DMA_MASK_ONE_REG, chan & 3);
   173e5:	83 ec 08             	sub    $0x8,%esp
   173e8:	83 e0 03             	and    $0x3,%eax
   173eb:	50                   	push   %eax
   173ec:	6a 0a                	push   $0xa
   173ee:	e8 d7 94 ff ff       	call   108ca <Out_Byte>
}
   173f3:	83 c4 18             	add    $0x18,%esp
   173f6:	5b                   	pop    %ebx
   173f7:	c3                   	ret    

000173f8 <Setup_DMA>:
{
   173f8:	55                   	push   %ebp
   173f9:	57                   	push   %edi
   173fa:	56                   	push   %esi
   173fb:	53                   	push   %ebx
   173fc:	83 ec 0c             	sub    $0xc,%esp
   173ff:	e8 0e 8e ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17404:	81 c3 fc eb 00 00    	add    $0xebfc,%ebx
   1740a:	8b 54 24 20          	mov    0x20(%esp),%edx
   1740e:	8b 6c 24 24          	mov    0x24(%esp),%ebp
   17412:	8b 74 24 28          	mov    0x28(%esp),%esi
    KASSERT(direction == DMA_READ || direction == DMA_WRITE);
   17416:	83 fa 01             	cmp    $0x1,%edx
   17419:	77 71                	ja     1748c <Setup_DMA+0x94>
    KASSERT(VALID_CHANNEL(chan));
   1741b:	83 fd 03             	cmp    $0x3,%ebp
   1741e:	0f 87 ac 00 00 00    	ja     174d0 <Setup_DMA+0xd8>
    KASSERT(IS_RESERVED(chan));
   17424:	0f b6 83 08 13 00 00 	movzbl 0x1308(%ebx),%eax
   1742b:	0f a3 e8             	bt     %ebp,%eax
   1742e:	0f 83 e0 00 00 00    	jae    17514 <Setup_DMA+0x11c>
 *   0(inclusive)..max(exclusive)
 */
static __inline__ bool
Check_Range_Under(ulong_t start, ulong_t size, ulong_t max)
{
    if (!Check_Range_Proper(start, size))
   17434:	89 f0                	mov    %esi,%eax
   17436:	03 44 24 2c          	add    0x2c(%esp),%eax
   1743a:	0f 83 18 01 00 00    	jae    17558 <Setup_DMA+0x160>
   17440:	85 c0                	test   %eax,%eax
   17442:	0f 84 10 01 00 00    	je     17558 <Setup_DMA+0x160>
    KASSERT(VALID_MEM(addr, size));
   17448:	83 ec 0c             	sub    $0xc,%esp
   1744b:	6a 4f                	push   $0x4f
   1744d:	e8 d7 9c ff ff       	call   11129 <Set_Current_Attr>
   17452:	83 c4 0c             	add    $0xc,%esp
   17455:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1745b:	ff 30                	pushl  (%eax)
   1745d:	ff 74 24 24          	pushl  0x24(%esp)
   17461:	68 b4 00 00 00       	push   $0xb4
   17466:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   1746c:	50                   	push   %eax
   1746d:	8d 83 01 84 ff ff    	lea    -0x7bff(%ebx),%eax
   17473:	50                   	push   %eax
   17474:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   1747a:	50                   	push   %eax
   1747b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17481:	50                   	push   %eax
   17482:	e8 53 9b ff ff       	call   10fda <Print>
   17487:	83 c4 20             	add    $0x20,%esp
   1748a:	eb fe                	jmp    1748a <Setup_DMA+0x92>
    KASSERT(direction == DMA_READ || direction == DMA_WRITE);
   1748c:	83 ec 0c             	sub    $0xc,%esp
   1748f:	6a 4f                	push   $0x4f
   17491:	e8 93 9c ff ff       	call   11129 <Set_Current_Attr>
   17496:	83 c4 0c             	add    $0xc,%esp
   17499:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1749f:	ff 30                	pushl  (%eax)
   174a1:	ff 74 24 24          	pushl  0x24(%esp)
   174a5:	68 b1 00 00 00       	push   $0xb1
   174aa:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   174b0:	50                   	push   %eax
   174b1:	8d 83 74 83 ff ff    	lea    -0x7c8c(%ebx),%eax
   174b7:	50                   	push   %eax
   174b8:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   174be:	50                   	push   %eax
   174bf:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   174c5:	50                   	push   %eax
   174c6:	e8 0f 9b ff ff       	call   10fda <Print>
   174cb:	83 c4 20             	add    $0x20,%esp
   174ce:	eb fe                	jmp    174ce <Setup_DMA+0xd6>
    KASSERT(VALID_CHANNEL(chan));
   174d0:	83 ec 0c             	sub    $0xc,%esp
   174d3:	6a 4f                	push   $0x4f
   174d5:	e8 4f 9c ff ff       	call   11129 <Set_Current_Attr>
   174da:	83 c4 0c             	add    $0xc,%esp
   174dd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   174e3:	ff 30                	pushl  (%eax)
   174e5:	ff 74 24 24          	pushl  0x24(%esp)
   174e9:	68 b2 00 00 00       	push   $0xb2
   174ee:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   174f4:	50                   	push   %eax
   174f5:	8d 83 db 83 ff ff    	lea    -0x7c25(%ebx),%eax
   174fb:	50                   	push   %eax
   174fc:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   17502:	50                   	push   %eax
   17503:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17509:	50                   	push   %eax
   1750a:	e8 cb 9a ff ff       	call   10fda <Print>
   1750f:	83 c4 20             	add    $0x20,%esp
   17512:	eb fe                	jmp    17512 <Setup_DMA+0x11a>
    KASSERT(IS_RESERVED(chan));
   17514:	83 ec 0c             	sub    $0xc,%esp
   17517:	6a 4f                	push   $0x4f
   17519:	e8 0b 9c ff ff       	call   11129 <Set_Current_Attr>
   1751e:	83 c4 0c             	add    $0xc,%esp
   17521:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17527:	ff 30                	pushl  (%eax)
   17529:	ff 74 24 24          	pushl  0x24(%esp)
   1752d:	68 b3 00 00 00       	push   $0xb3
   17532:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   17538:	50                   	push   %eax
   17539:	8d 83 ef 83 ff ff    	lea    -0x7c11(%ebx),%eax
   1753f:	50                   	push   %eax
   17540:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   17546:	50                   	push   %eax
   17547:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1754d:	50                   	push   %eax
   1754e:	e8 87 9a ff ff       	call   10fda <Print>
   17553:	83 c4 20             	add    $0x20,%esp
   17556:	eb fe                	jmp    17556 <Setup_DMA+0x15e>
    KASSERT(VALID_MEM(addr, size));
   17558:	3d 00 00 00 01       	cmp    $0x1000000,%eax
   1755d:	0f 87 e5 fe ff ff    	ja     17448 <Setup_DMA+0x50>
   17563:	81 fe ff ff ff 00    	cmp    $0xffffff,%esi
   17569:	0f 87 d9 fe ff ff    	ja     17448 <Setup_DMA+0x50>
    KASSERT(size > 0);
   1756f:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
   17574:	0f 84 ba 00 00 00    	je     17634 <Setup_DMA+0x23c>
    KASSERT(size <= (0xffff - (addr & 0xffff)));  /* can't cross 64K boundary */
   1757a:	89 f0                	mov    %esi,%eax
   1757c:	f7 d0                	not    %eax
   1757e:	0f b7 c0             	movzwl %ax,%eax
   17581:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
   17585:	0f 82 ed 00 00 00    	jb     17678 <Setup_DMA+0x280>
    mode |= (direction == DMA_READ) ? DMA_MODE_READ : DMA_MODE_WRITE;
   1758b:	83 fa 01             	cmp    $0x1,%edx
   1758e:	19 ff                	sbb    %edi,%edi
   17590:	83 e7 fc             	and    $0xfffffffc,%edi
   17593:	83 c7 08             	add    $0x8,%edi
    Mask_DMA(chan);
   17596:	83 ec 0c             	sub    $0xc,%esp
   17599:	55                   	push   %ebp
   1759a:	e8 d0 fc ff ff       	call   1726f <Mask_DMA>
    Out_Byte(DMA_MODE_REG, mode);
   1759f:	83 c4 08             	add    $0x8,%esp
    mode |= (chan & 3);
   175a2:	89 f8                	mov    %edi,%eax
   175a4:	09 e8                	or     %ebp,%eax
   175a6:	83 c8 40             	or     $0x40,%eax
    Out_Byte(DMA_MODE_REG, mode);
   175a9:	0f b6 c0             	movzbl %al,%eax
   175ac:	50                   	push   %eax
   175ad:	6a 0b                	push   $0xb
   175af:	e8 16 93 ff ff       	call   108ca <Out_Byte>
    Out_Byte(DMA_CLEAR_FF_REG, 0);  /* doesn't matter what value is written here */
   175b4:	83 c4 08             	add    $0x8,%esp
   175b7:	6a 00                	push   $0x0
   175b9:	6a 0c                	push   $0xc
   175bb:	e8 0a 93 ff ff       	call   108ca <Out_Byte>
    Out_Byte(DMA_ADDR_REG(chan), addr & 0xFF);
   175c0:	8d 7c 2d 00          	lea    0x0(%ebp,%ebp,1),%edi
   175c4:	83 c4 08             	add    $0x8,%esp
   175c7:	89 f0                	mov    %esi,%eax
   175c9:	0f b6 c0             	movzbl %al,%eax
   175cc:	50                   	push   %eax
   175cd:	57                   	push   %edi
   175ce:	e8 f7 92 ff ff       	call   108ca <Out_Byte>
    Out_Byte(DMA_ADDR_REG(chan), (addr >> 8) & 0xFF);
   175d3:	83 c4 08             	add    $0x8,%esp
   175d6:	89 f0                	mov    %esi,%eax
   175d8:	0f b6 c4             	movzbl %ah,%eax
   175db:	50                   	push   %eax
   175dc:	57                   	push   %edi
   175dd:	e8 e8 92 ff ff       	call   108ca <Out_Byte>
    Out_Byte(DMA_PAGE_REG(chan), (addr >> 16) & 0xFF);
   175e2:	83 c4 08             	add    $0x8,%esp
   175e5:	c1 ee 10             	shr    $0x10,%esi
   175e8:	56                   	push   %esi
   175e9:	0f b6 84 2b 6c 84 ff 	movzbl -0x7b94(%ebx,%ebp,1),%eax
   175f0:	ff 
   175f1:	50                   	push   %eax
   175f2:	e8 d3 92 ff ff       	call   108ca <Out_Byte>
    --size;
   175f7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   175fb:	83 e8 01             	sub    $0x1,%eax
    Out_Byte(DMA_COUNT_REG(chan), size & 0xFF);
   175fe:	89 fe                	mov    %edi,%esi
   17600:	83 ce 01             	or     $0x1,%esi
   17603:	0f b7 f6             	movzwl %si,%esi
   17606:	83 c4 08             	add    $0x8,%esp
   17609:	89 c7                	mov    %eax,%edi
   1760b:	0f b6 c0             	movzbl %al,%eax
   1760e:	50                   	push   %eax
   1760f:	56                   	push   %esi
   17610:	e8 b5 92 ff ff       	call   108ca <Out_Byte>
    Out_Byte(DMA_COUNT_REG(chan), (size >> 8) & 0xFF);
   17615:	83 c4 08             	add    $0x8,%esp
   17618:	89 f8                	mov    %edi,%eax
   1761a:	c1 e8 08             	shr    $0x8,%eax
   1761d:	50                   	push   %eax
   1761e:	56                   	push   %esi
   1761f:	e8 a6 92 ff ff       	call   108ca <Out_Byte>
    Unmask_DMA(chan);
   17624:	89 2c 24             	mov    %ebp,(%esp)
   17627:	e8 09 fd ff ff       	call   17335 <Unmask_DMA>
}
   1762c:	83 c4 1c             	add    $0x1c,%esp
   1762f:	5b                   	pop    %ebx
   17630:	5e                   	pop    %esi
   17631:	5f                   	pop    %edi
   17632:	5d                   	pop    %ebp
   17633:	c3                   	ret    
    KASSERT(size > 0);
   17634:	83 ec 0c             	sub    $0xc,%esp
   17637:	6a 4f                	push   $0x4f
   17639:	e8 eb 9a ff ff       	call   11129 <Set_Current_Attr>
   1763e:	83 c4 0c             	add    $0xc,%esp
   17641:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17647:	ff 30                	pushl  (%eax)
   17649:	ff 74 24 24          	pushl  0x24(%esp)
   1764d:	68 b5 00 00 00       	push   $0xb5
   17652:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   17658:	50                   	push   %eax
   17659:	8d 83 e5 7b ff ff    	lea    -0x841b(%ebx),%eax
   1765f:	50                   	push   %eax
   17660:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   17666:	50                   	push   %eax
   17667:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1766d:	50                   	push   %eax
   1766e:	e8 67 99 ff ff       	call   10fda <Print>
   17673:	83 c4 20             	add    $0x20,%esp
   17676:	eb fe                	jmp    17676 <Setup_DMA+0x27e>
    KASSERT(size <= (0xffff - (addr & 0xffff)));  /* can't cross 64K boundary */
   17678:	83 ec 0c             	sub    $0xc,%esp
   1767b:	6a 4f                	push   $0x4f
   1767d:	e8 a7 9a ff ff       	call   11129 <Set_Current_Attr>
   17682:	83 c4 0c             	add    $0xc,%esp
   17685:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1768b:	ff 30                	pushl  (%eax)
   1768d:	ff 74 24 24          	pushl  0x24(%esp)
   17691:	68 b6 00 00 00       	push   $0xb6
   17696:	8d 83 c7 83 ff ff    	lea    -0x7c39(%ebx),%eax
   1769c:	50                   	push   %eax
   1769d:	8d 83 a4 83 ff ff    	lea    -0x7c5c(%ebx),%eax
   176a3:	50                   	push   %eax
   176a4:	8d 83 30 84 ff ff    	lea    -0x7bd0(%ebx),%eax
   176aa:	50                   	push   %eax
   176ab:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   176b1:	50                   	push   %eax
   176b2:	e8 23 99 ff ff       	call   10fda <Print>
   176b7:	83 c4 20             	add    $0x20,%esp
   176ba:	eb fe                	jmp    176ba <Setup_DMA+0x2c2>

000176bc <Wait_For_MRQ>:
 * Wait for the MRQ bit to be set in the main status register.
 * This indicates that the controller is ready to accept data
 * or send data via the data register.
 */
static void Wait_For_MRQ(uchar_t readyValue)
{
   176bc:	56                   	push   %esi
   176bd:	53                   	push   %ebx
   176be:	83 ec 04             	sub    $0x4,%esp
   176c1:	e8 4c 8b ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   176c6:	81 c3 3a e9 00 00    	add    $0xe93a,%ebx
   176cc:	89 c6                	mov    %eax,%esi
    KASSERT(readyValue == FDC_STATUS_READY_READ || readyValue == FDC_STATUS_READY_WRITE);
   176ce:	83 e0 bf             	and    $0xffffffbf,%eax
   176d1:	3c 80                	cmp    $0x80,%al
   176d3:	75 1f                	jne    176f4 <Wait_For_MRQ+0x38>

    /* Wait for MRQ bit to be set in main status register */
    while ((In_Byte(FDC_STATUS_REG) & FDC_STATUS_READY_MASK) != readyValue)
   176d5:	83 ec 0c             	sub    $0xc,%esp
   176d8:	68 f4 03 00 00       	push   $0x3f4
   176dd:	e8 f2 91 ff ff       	call   108d4 <In_Byte>
   176e2:	83 e0 c0             	and    $0xffffffc0,%eax
   176e5:	83 c4 10             	add    $0x10,%esp
   176e8:	89 f2                	mov    %esi,%edx
   176ea:	38 c2                	cmp    %al,%dl
   176ec:	75 e7                	jne    176d5 <Wait_For_MRQ+0x19>
	;

    /*Debug("Ready to accept command!\n"); */
}
   176ee:	83 c4 04             	add    $0x4,%esp
   176f1:	5b                   	pop    %ebx
   176f2:	5e                   	pop    %esi
   176f3:	c3                   	ret    
    KASSERT(readyValue == FDC_STATUS_READY_READ || readyValue == FDC_STATUS_READY_WRITE);
   176f4:	83 ec 0c             	sub    $0xc,%esp
   176f7:	6a 4f                	push   $0x4f
   176f9:	e8 2b 9a ff ff       	call   11129 <Set_Current_Attr>
   176fe:	83 c4 0c             	add    $0xc,%esp
   17701:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17707:	ff 30                	pushl  (%eax)
   17709:	ff 74 24 14          	pushl  0x14(%esp)
   1770d:	68 38 01 00 00       	push   $0x138
   17712:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17718:	50                   	push   %eax
   17719:	8d 83 b4 84 ff ff    	lea    -0x7b4c(%ebx),%eax
   1771f:	50                   	push   %eax
   17720:	8d 83 58 87 ff ff    	lea    -0x78a8(%ebx),%eax
   17726:	50                   	push   %eax
   17727:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1772d:	50                   	push   %eax
   1772e:	e8 a7 98 ff ff       	call   10fda <Print>
   17733:	83 c4 20             	add    $0x20,%esp
   17736:	eb fe                	jmp    17736 <Wait_For_MRQ+0x7a>

00017738 <Floppy_Out>:

/*
 * Write a byte to the data register.
 */
static void Floppy_Out(uchar_t val)
{
   17738:	56                   	push   %esi
   17739:	53                   	push   %ebx
   1773a:	83 ec 04             	sub    $0x4,%esp
   1773d:	e8 91 8d ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   17742:	81 c6 be e8 00 00    	add    $0xe8be,%esi
   17748:	89 c3                	mov    %eax,%ebx
    Wait_For_MRQ(FDC_STATUS_READY_WRITE);
   1774a:	b8 80 00 00 00       	mov    $0x80,%eax
   1774f:	e8 68 ff ff ff       	call   176bc <Wait_For_MRQ>
    Out_Byte(FDC_DATA_REG, val);
   17754:	83 ec 08             	sub    $0x8,%esp
   17757:	0f b6 db             	movzbl %bl,%ebx
   1775a:	53                   	push   %ebx
   1775b:	68 f5 03 00 00       	push   $0x3f5
   17760:	89 f3                	mov    %esi,%ebx
   17762:	e8 63 91 ff ff       	call   108ca <Out_Byte>
}
   17767:	83 c4 14             	add    $0x14,%esp
   1776a:	5b                   	pop    %ebx
   1776b:	5e                   	pop    %esi
   1776c:	c3                   	ret    

0001776d <Floppy_In>:
{
   1776d:	53                   	push   %ebx
   1776e:	83 ec 08             	sub    $0x8,%esp
   17771:	e8 9c 8a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17776:	81 c3 8a e8 00 00    	add    $0xe88a,%ebx
    Wait_For_MRQ(FDC_STATUS_READY_READ);
   1777c:	b8 c0 00 00 00       	mov    $0xc0,%eax
   17781:	e8 36 ff ff ff       	call   176bc <Wait_For_MRQ>
    return In_Byte(FDC_DATA_REG);
   17786:	83 ec 0c             	sub    $0xc,%esp
   17789:	68 f5 03 00 00       	push   $0x3f5
   1778e:	e8 41 91 ff ff       	call   108d4 <In_Byte>
}
   17793:	83 c4 18             	add    $0x18,%esp
   17796:	5b                   	pop    %ebx
   17797:	c3                   	ret    

00017798 <Wait_For_Interrupt>:
/*
 * Wait for the controller to issue an interrupt.
 * Must be called with interrupts disabled.
 */
static void Wait_For_Interrupt(void)
{
   17798:	53                   	push   %ebx
   17799:	83 ec 08             	sub    $0x8,%esp
   1779c:	e8 71 8a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   177a1:	81 c3 5f e8 00 00    	add    $0xe85f,%ebx
    KASSERT(!Interrupts_Enabled());
   177a7:	e8 a0 8a ff ff       	call   1024c <Interrupts_Enabled>
   177ac:	84 c0                	test   %al,%al
   177ae:	74 44                	je     177f4 <Wait_For_Interrupt+0x5c>
   177b0:	83 ec 0c             	sub    $0xc,%esp
   177b3:	6a 4f                	push   $0x4f
   177b5:	e8 6f 99 ff ff       	call   11129 <Set_Current_Attr>
   177ba:	83 c4 0c             	add    $0xc,%esp
   177bd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   177c3:	ff 30                	pushl  (%eax)
   177c5:	ff 74 24 14          	pushl  0x14(%esp)
   177c9:	68 59 01 00 00       	push   $0x159
   177ce:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   177d4:	50                   	push   %eax
   177d5:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   177db:	50                   	push   %eax
   177dc:	8d 83 44 87 ff ff    	lea    -0x78bc(%ebx),%eax
   177e2:	50                   	push   %eax
   177e3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   177e9:	50                   	push   %eax
   177ea:	e8 eb 97 ff ff       	call   10fda <Print>
   177ef:	83 c4 20             	add    $0x20,%esp
   177f2:	eb fe                	jmp    177f2 <Wait_For_Interrupt+0x5a>

    /* Spin wait */

    s_interruptOccurred = 0;
   177f4:	c7 83 20 13 00 00 00 	movl   $0x0,0x1320(%ebx)
   177fb:	00 00 00 
    Enable_Interrupts();
   177fe:	e8 49 8a ff ff       	call   1024c <Interrupts_Enabled>
   17803:	84 c0                	test   %al,%al
   17805:	75 1a                	jne    17821 <Wait_For_Interrupt+0x89>
    __asm__ __volatile__ ("sti");
   17807:	fb                   	sti    
    while (!s_interruptOccurred) {
   17808:	8b 83 20 13 00 00    	mov    0x1320(%ebx),%eax
   1780e:	85 c0                	test   %eax,%eax
   17810:	74 f6                	je     17808 <Wait_For_Interrupt+0x70>
	/* FIXME: Could sleep here */
    }
    Disable_Interrupts();
   17812:	e8 35 8a ff ff       	call   1024c <Interrupts_Enabled>
   17817:	84 c0                	test   %al,%al
   17819:	74 4a                	je     17865 <Wait_For_Interrupt+0xcd>
    __asm__ __volatile__ ("cli");
   1781b:	fa                   	cli    
}
   1781c:	83 c4 08             	add    $0x8,%esp
   1781f:	5b                   	pop    %ebx
   17820:	c3                   	ret    
    Enable_Interrupts();
   17821:	83 ec 0c             	sub    $0xc,%esp
   17824:	6a 4f                	push   $0x4f
   17826:	e8 fe 98 ff ff       	call   11129 <Set_Current_Attr>
   1782b:	83 c4 0c             	add    $0xc,%esp
   1782e:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17834:	ff 30                	pushl  (%eax)
   17836:	ff 74 24 14          	pushl  0x14(%esp)
   1783a:	68 5e 01 00 00       	push   $0x15e
   1783f:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17845:	50                   	push   %eax
   17846:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1784c:	50                   	push   %eax
   1784d:	8d 83 44 87 ff ff    	lea    -0x78bc(%ebx),%eax
   17853:	50                   	push   %eax
   17854:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1785a:	50                   	push   %eax
   1785b:	e8 7a 97 ff ff       	call   10fda <Print>
   17860:	83 c4 20             	add    $0x20,%esp
   17863:	eb fe                	jmp    17863 <Wait_For_Interrupt+0xcb>
    Disable_Interrupts();
   17865:	83 ec 0c             	sub    $0xc,%esp
   17868:	6a 4f                	push   $0x4f
   1786a:	e8 ba 98 ff ff       	call   11129 <Set_Current_Attr>
   1786f:	83 c4 0c             	add    $0xc,%esp
   17872:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17878:	ff 30                	pushl  (%eax)
   1787a:	ff 74 24 14          	pushl  0x14(%esp)
   1787e:	68 62 01 00 00       	push   $0x162
   17883:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17889:	50                   	push   %eax
   1788a:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   17890:	50                   	push   %eax
   17891:	8d 83 44 87 ff ff    	lea    -0x78bc(%ebx),%eax
   17897:	50                   	push   %eax
   17898:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1789e:	50                   	push   %eax
   1789f:	e8 36 97 ff ff       	call   10fda <Print>
   178a4:	83 c4 20             	add    $0x20,%esp
   178a7:	eb fe                	jmp    178a7 <Wait_For_Interrupt+0x10f>

000178a9 <Floppy_Get_Num_Blocks>:
{
   178a9:	53                   	push   %ebx
   178aa:	83 ec 08             	sub    $0x8,%esp
   178ad:	e8 60 89 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   178b2:	81 c3 4e e7 00 00    	add    $0xe74e,%ebx
    KASSERT(dev->unit >= 0 && dev->unit <= 1);
   178b8:	8b 44 24 10          	mov    0x10(%esp),%eax
   178bc:	8b 40 14             	mov    0x14(%eax),%eax
   178bf:	83 f8 01             	cmp    $0x1,%eax
   178c2:	77 1c                	ja     178e0 <Floppy_Get_Num_Blocks+0x37>
    params = drive->params;
   178c4:	c7 c2 98 77 02 00    	mov    $0x27798,%edx
   178ca:	8b 14 82             	mov    (%edx,%eax,4),%edx
    KASSERT(params != 0);
   178cd:	85 d2                	test   %edx,%edx
   178cf:	74 53                	je     17924 <Floppy_Get_Num_Blocks+0x7b>
    return params->cylinders * params->heads * params->sectors;
   178d1:	8b 02                	mov    (%edx),%eax
   178d3:	0f af 42 04          	imul   0x4(%edx),%eax
   178d7:	0f af 42 08          	imul   0x8(%edx),%eax
}
   178db:	83 c4 08             	add    $0x8,%esp
   178de:	5b                   	pop    %ebx
   178df:	c3                   	ret    
    KASSERT(dev->unit >= 0 && dev->unit <= 1);
   178e0:	83 ec 0c             	sub    $0xc,%esp
   178e3:	6a 4f                	push   $0x4f
   178e5:	e8 3f 98 ff ff       	call   11129 <Set_Current_Attr>
   178ea:	83 c4 0c             	add    $0xc,%esp
   178ed:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   178f3:	ff 30                	pushl  (%eax)
   178f5:	ff 74 24 14          	pushl  0x14(%esp)
   178f9:	68 e4 00 00 00       	push   $0xe4
   178fe:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17904:	50                   	push   %eax
   17905:	8d 83 00 85 ff ff    	lea    -0x7b00(%ebx),%eax
   1790b:	50                   	push   %eax
   1790c:	8d 83 2c 87 ff ff    	lea    -0x78d4(%ebx),%eax
   17912:	50                   	push   %eax
   17913:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17919:	50                   	push   %eax
   1791a:	e8 bb 96 ff ff       	call   10fda <Print>
   1791f:	83 c4 20             	add    $0x20,%esp
   17922:	eb fe                	jmp    17922 <Floppy_Get_Num_Blocks+0x79>
    KASSERT(params != 0);
   17924:	83 ec 0c             	sub    $0xc,%esp
   17927:	6a 4f                	push   $0x4f
   17929:	e8 fb 97 ff ff       	call   11129 <Set_Current_Attr>
   1792e:	83 c4 0c             	add    $0xc,%esp
   17931:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17937:	ff 30                	pushl  (%eax)
   17939:	ff 74 24 14          	pushl  0x14(%esp)
   1793d:	68 e8 00 00 00       	push   $0xe8
   17942:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17948:	50                   	push   %eax
   17949:	8d 83 87 84 ff ff    	lea    -0x7b79(%ebx),%eax
   1794f:	50                   	push   %eax
   17950:	8d 83 2c 87 ff ff    	lea    -0x78d4(%ebx),%eax
   17956:	50                   	push   %eax
   17957:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1795d:	50                   	push   %eax
   1795e:	e8 77 96 ff ff       	call   10fda <Print>
   17963:	83 c4 20             	add    $0x20,%esp
   17966:	eb fe                	jmp    17966 <Floppy_Get_Num_Blocks+0xbd>

00017968 <Floppy_Close>:
{
   17968:	53                   	push   %ebx
   17969:	83 ec 08             	sub    $0x8,%esp
   1796c:	e8 a1 88 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17971:	81 c3 8f e6 00 00    	add    $0xe68f,%ebx
    KASSERT(dev->inUse);
   17977:	8b 44 24 10          	mov    0x10(%esp),%eax
   1797b:	80 78 18 00          	cmpb   $0x0,0x18(%eax)
   1797f:	74 0a                	je     1798b <Floppy_Close+0x23>
}
   17981:	b8 00 00 00 00       	mov    $0x0,%eax
   17986:	83 c4 08             	add    $0x8,%esp
   17989:	5b                   	pop    %ebx
   1798a:	c3                   	ret    
    KASSERT(dev->inUse);
   1798b:	83 ec 0c             	sub    $0xc,%esp
   1798e:	6a 4f                	push   $0x4f
   17990:	e8 94 97 ff ff       	call   11129 <Set_Current_Attr>
   17995:	83 c4 0c             	add    $0xc,%esp
   17998:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1799e:	ff 30                	pushl  (%eax)
   179a0:	ff 74 24 14          	pushl  0x14(%esp)
   179a4:	68 d8 00 00 00       	push   $0xd8
   179a9:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   179af:	50                   	push   %eax
   179b0:	8d 83 94 84 ff ff    	lea    -0x7b6c(%ebx),%eax
   179b6:	50                   	push   %eax
   179b7:	8d 83 1c 87 ff ff    	lea    -0x78e4(%ebx),%eax
   179bd:	50                   	push   %eax
   179be:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   179c4:	50                   	push   %eax
   179c5:	e8 10 96 ff ff       	call   10fda <Print>
   179ca:	83 c4 20             	add    $0x20,%esp
   179cd:	eb fe                	jmp    179cd <Floppy_Close+0x65>

000179cf <Floppy_Open>:
{
   179cf:	53                   	push   %ebx
   179d0:	83 ec 08             	sub    $0x8,%esp
   179d3:	e8 3a 88 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   179d8:	81 c3 28 e6 00 00    	add    $0xe628,%ebx
    KASSERT(!dev->inUse);
   179de:	8b 44 24 10          	mov    0x10(%esp),%eax
   179e2:	80 78 18 00          	cmpb   $0x0,0x18(%eax)
   179e6:	75 0a                	jne    179f2 <Floppy_Open+0x23>
}
   179e8:	b8 00 00 00 00       	mov    $0x0,%eax
   179ed:	83 c4 08             	add    $0x8,%esp
   179f0:	5b                   	pop    %ebx
   179f1:	c3                   	ret    
    KASSERT(!dev->inUse);
   179f2:	83 ec 0c             	sub    $0xc,%esp
   179f5:	6a 4f                	push   $0x4f
   179f7:	e8 2d 97 ff ff       	call   11129 <Set_Current_Attr>
   179fc:	83 c4 0c             	add    $0xc,%esp
   179ff:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17a05:	ff 30                	pushl  (%eax)
   17a07:	ff 74 24 14          	pushl  0x14(%esp)
   17a0b:	68 cf 00 00 00       	push   $0xcf
   17a10:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17a16:	50                   	push   %eax
   17a17:	8d 83 93 84 ff ff    	lea    -0x7b6d(%ebx),%eax
   17a1d:	50                   	push   %eax
   17a1e:	8d 83 10 87 ff ff    	lea    -0x78f0(%ebx),%eax
   17a24:	50                   	push   %eax
   17a25:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17a2b:	50                   	push   %eax
   17a2c:	e8 a9 95 ff ff       	call   10fda <Print>
   17a31:	83 c4 20             	add    $0x20,%esp
   17a34:	eb fe                	jmp    17a34 <Floppy_Open+0x65>

00017a36 <Floppy_Interrupt_Handler>:
{
   17a36:	56                   	push   %esi
   17a37:	53                   	push   %ebx
   17a38:	83 ec 10             	sub    $0x10,%esp
   17a3b:	e8 d2 87 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17a40:	81 c3 c0 e5 00 00    	add    $0xe5c0,%ebx
   17a46:	8b 74 24 1c          	mov    0x1c(%esp),%esi
    Begin_IRQ(state);
   17a4a:	56                   	push   %esi
   17a4b:	e8 19 8e ff ff       	call   10869 <Begin_IRQ>
    s_interruptOccurred = 1;
   17a50:	c7 83 20 13 00 00 01 	movl   $0x1,0x1320(%ebx)
   17a57:	00 00 00 
    End_IRQ(state);
   17a5a:	89 34 24             	mov    %esi,(%esp)
   17a5d:	e8 08 8e ff ff       	call   1086a <End_IRQ>
}
   17a62:	83 c4 14             	add    $0x14,%esp
   17a65:	5b                   	pop    %ebx
   17a66:	5e                   	pop    %esi
   17a67:	c3                   	ret    

00017a68 <Setup_Drive_Parameters>:
{
   17a68:	55                   	push   %ebp
   17a69:	57                   	push   %edi
   17a6a:	56                   	push   %esi
   17a6b:	53                   	push   %ebx
   17a6c:	83 ec 1c             	sub    $0x1c,%esp
   17a6f:	e8 9e 87 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17a74:	81 c3 8c e5 00 00    	add    $0xe58c,%ebx
    if (IS_VALID_FLOPPY_TYPE(type)) {
   17a7a:	83 fa 05             	cmp    $0x5,%edx
   17a7d:	77 11                	ja     17a90 <Setup_Drive_Parameters+0x28>
   17a7f:	89 c7                	mov    %eax,%edi
   17a81:	89 d6                	mov    %edx,%esi
   17a83:	8d 04 92             	lea    (%edx,%edx,4),%eax
   17a86:	83 bc 83 60 00 00 00 	cmpl   $0x0,0x60(%ebx,%eax,4)
   17a8d:	00 
   17a8e:	7f 08                	jg     17a98 <Setup_Drive_Parameters+0x30>
}
   17a90:	83 c4 1c             	add    $0x1c,%esp
   17a93:	5b                   	pop    %ebx
   17a94:	5e                   	pop    %esi
   17a95:	5f                   	pop    %edi
   17a96:	5d                   	pop    %ebp
   17a97:	c3                   	ret    
	snprintf(devname, sizeof(devname), "fd%d", drive);
   17a98:	57                   	push   %edi
   17a99:	8d 83 9f 84 ff ff    	lea    -0x7b61(%ebx),%eax
   17a9f:	50                   	push   %eax
   17aa0:	6a 10                	push   $0x10
   17aa2:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
   17aa6:	55                   	push   %ebp
   17aa7:	e8 f4 52 00 00       	call   1cda0 <snprintf>
	Print("    %s: cyl=%d, heads=%d, sectors=%d\n", devname,
   17aac:	83 c4 04             	add    $0x4,%esp
   17aaf:	8d 04 b5 00 00 00 00 	lea    0x0(,%esi,4),%eax
   17ab6:	8d 14 30             	lea    (%eax,%esi,1),%edx
   17ab9:	8d 94 93 60 00 00 00 	lea    0x60(%ebx,%edx,4),%edx
   17ac0:	ff 72 08             	pushl  0x8(%edx)
   17ac3:	ff 72 04             	pushl  0x4(%edx)
   17ac6:	01 f0                	add    %esi,%eax
   17ac8:	ff b4 83 60 00 00 00 	pushl  0x60(%ebx,%eax,4)
   17acf:	55                   	push   %ebp
   17ad0:	8d 83 24 85 ff ff    	lea    -0x7adc(%ebx),%eax
   17ad6:	50                   	push   %eax
   17ad7:	e8 fe 94 ff ff       	call   10fda <Print>
	struct Floppy_Parameters* params = &s_floppyParamsTable[type];
   17adc:	8d 04 b6             	lea    (%esi,%esi,4),%eax
   17adf:	8d 94 83 60 00 00 00 	lea    0x60(%ebx,%eax,4),%edx
   17ae6:	c7 c0 98 77 02 00    	mov    $0x27798,%eax
   17aec:	89 14 b8             	mov    %edx,(%eax,%edi,4)
	rc = Register_Block_Device(devname, &s_floppyDeviceOps, drive, 0,
   17aef:	83 c4 18             	add    $0x18,%esp
   17af2:	8d 83 14 13 00 00    	lea    0x1314(%ebx),%eax
   17af8:	50                   	push   %eax
   17af9:	8d 83 0c 13 00 00    	lea    0x130c(%ebx),%eax
   17aff:	50                   	push   %eax
   17b00:	6a 00                	push   $0x0
   17b02:	57                   	push   %edi
   17b03:	8d 83 d8 00 00 00    	lea    0xd8(%ebx),%eax
   17b09:	50                   	push   %eax
   17b0a:	55                   	push   %ebp
   17b0b:	e8 a0 09 00 00       	call   184b0 <Register_Block_Device>
	if (rc != 0)
   17b10:	83 c4 20             	add    $0x20,%esp
   17b13:	85 c0                	test   %eax,%eax
   17b15:	0f 84 75 ff ff ff    	je     17a90 <Setup_Drive_Parameters+0x28>
	    Print("  Error: could not create block device for %s\n", devname);
   17b1b:	83 ec 08             	sub    $0x8,%esp
   17b1e:	8d 44 24 08          	lea    0x8(%esp),%eax
   17b22:	50                   	push   %eax
   17b23:	8d 83 4c 85 ff ff    	lea    -0x7ab4(%ebx),%eax
   17b29:	50                   	push   %eax
   17b2a:	e8 ab 94 ff ff       	call   10fda <Print>
   17b2f:	83 c4 10             	add    $0x10,%esp
}
   17b32:	e9 59 ff ff ff       	jmp    17a90 <Setup_Drive_Parameters+0x28>

00017b37 <Floppy_Transfer>:

    return success;
}

static int Floppy_Transfer(int direction, int driveNum, int blockNum, char *buf)
{
   17b37:	55                   	push   %ebp
   17b38:	57                   	push   %edi
   17b39:	56                   	push   %esi
   17b3a:	53                   	push   %ebx
   17b3b:	83 ec 2c             	sub    $0x2c,%esp
   17b3e:	e8 cf 86 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   17b43:	81 c3 bd e4 00 00    	add    $0xe4bd,%ebx
   17b49:	89 44 24 04          	mov    %eax,0x4(%esp)
   17b4d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	direction == FLOPPY_READ ? DMA_READ : DMA_WRITE;
    uchar_t command;
    uchar_t st0, st1, st2;
    int result = -1;

    KASSERT(driveNum == 0);  /* FIXME */
   17b51:	85 d2                	test   %edx,%edx
   17b53:	0f 85 81 00 00 00    	jne    17bda <Floppy_Transfer+0xa3>
    KASSERT(direction == FLOPPY_READ || direction == FLOPPY_WRITE);
   17b59:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
   17b5e:	0f 87 ba 00 00 00    	ja     17c1e <Floppy_Transfer+0xe7>
    struct Floppy_Parameters *params = drive->params;
   17b64:	c7 c0 98 77 02 00    	mov    $0x27798,%eax
   17b6a:	8b 30                	mov    (%eax),%esi
    KASSERT(params != 0);
   17b6c:	85 f6                	test   %esi,%esi
   17b6e:	0f 84 ee 00 00 00    	je     17c62 <Floppy_Transfer+0x12b>
    *cylinder = lba / (params->heads * params->sectors);
   17b74:	8b 6e 04             	mov    0x4(%esi),%ebp
   17b77:	8b 4e 08             	mov    0x8(%esi),%ecx
   17b7a:	89 ef                	mov    %ebp,%edi
   17b7c:	0f af f9             	imul   %ecx,%edi
   17b7f:	8b 44 24 08          	mov    0x8(%esp),%eax
   17b83:	99                   	cltd   
   17b84:	f7 ff                	idiv   %edi
   17b86:	89 44 24 0c          	mov    %eax,0xc(%esp)
    KASSERT(*cylinder >= 0 && *cylinder < params->cylinders);
   17b8a:	85 c0                	test   %eax,%eax
   17b8c:	78 08                	js     17b96 <Floppy_Transfer+0x5f>
   17b8e:	3b 06                	cmp    (%esi),%eax
   17b90:	0f 8c 10 01 00 00    	jl     17ca6 <Floppy_Transfer+0x16f>
   17b96:	83 ec 0c             	sub    $0xc,%esp
   17b99:	6a 4f                	push   $0x4f
   17b9b:	e8 89 95 ff ff       	call   11129 <Set_Current_Attr>
   17ba0:	83 c4 0c             	add    $0xc,%esp
   17ba3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17ba9:	ff 30                	pushl  (%eax)
   17bab:	ff 74 24 44          	pushl  0x44(%esp)
   17baf:	68 2c 01 00 00       	push   $0x12c
   17bb4:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17bba:	50                   	push   %eax
   17bbb:	8d 83 b4 85 ff ff    	lea    -0x7a4c(%ebx),%eax
   17bc1:	50                   	push   %eax
   17bc2:	8d 83 74 87 ff ff    	lea    -0x788c(%ebx),%eax
   17bc8:	50                   	push   %eax
   17bc9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17bcf:	50                   	push   %eax
   17bd0:	e8 05 94 ff ff       	call   10fda <Print>
   17bd5:	83 c4 20             	add    $0x20,%esp
   17bd8:	eb fe                	jmp    17bd8 <Floppy_Transfer+0xa1>
    KASSERT(driveNum == 0);  /* FIXME */
   17bda:	83 ec 0c             	sub    $0xc,%esp
   17bdd:	6a 4f                	push   $0x4f
   17bdf:	e8 45 95 ff ff       	call   11129 <Set_Current_Attr>
   17be4:	83 c4 0c             	add    $0xc,%esp
   17be7:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17bed:	ff 30                	pushl  (%eax)
   17bef:	ff 74 24 44          	pushl  0x44(%esp)
   17bf3:	68 de 01 00 00       	push   $0x1de
   17bf8:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17bfe:	50                   	push   %eax
   17bff:	8d 83 a4 84 ff ff    	lea    -0x7b5c(%ebx),%eax
   17c05:	50                   	push   %eax
   17c06:	8d 83 80 87 ff ff    	lea    -0x7880(%ebx),%eax
   17c0c:	50                   	push   %eax
   17c0d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17c13:	50                   	push   %eax
   17c14:	e8 c1 93 ff ff       	call   10fda <Print>
   17c19:	83 c4 20             	add    $0x20,%esp
   17c1c:	eb fe                	jmp    17c1c <Floppy_Transfer+0xe5>
    KASSERT(direction == FLOPPY_READ || direction == FLOPPY_WRITE);
   17c1e:	83 ec 0c             	sub    $0xc,%esp
   17c21:	6a 4f                	push   $0x4f
   17c23:	e8 01 95 ff ff       	call   11129 <Set_Current_Attr>
   17c28:	83 c4 0c             	add    $0xc,%esp
   17c2b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17c31:	ff 30                	pushl  (%eax)
   17c33:	ff 74 24 44          	pushl  0x44(%esp)
   17c37:	68 df 01 00 00       	push   $0x1df
   17c3c:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17c42:	50                   	push   %eax
   17c43:	8d 83 7c 85 ff ff    	lea    -0x7a84(%ebx),%eax
   17c49:	50                   	push   %eax
   17c4a:	8d 83 80 87 ff ff    	lea    -0x7880(%ebx),%eax
   17c50:	50                   	push   %eax
   17c51:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17c57:	50                   	push   %eax
   17c58:	e8 7d 93 ff ff       	call   10fda <Print>
   17c5d:	83 c4 20             	add    $0x20,%esp
   17c60:	eb fe                	jmp    17c60 <Floppy_Transfer+0x129>
    KASSERT(params != 0);
   17c62:	83 ec 0c             	sub    $0xc,%esp
   17c65:	6a 4f                	push   $0x4f
   17c67:	e8 bd 94 ff ff       	call   11129 <Set_Current_Attr>
   17c6c:	83 c4 0c             	add    $0xc,%esp
   17c6f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17c75:	ff 30                	pushl  (%eax)
   17c77:	ff 74 24 44          	pushl  0x44(%esp)
   17c7b:	68 e0 01 00 00       	push   $0x1e0
   17c80:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17c86:	50                   	push   %eax
   17c87:	8d 83 87 84 ff ff    	lea    -0x7b79(%ebx),%eax
   17c8d:	50                   	push   %eax
   17c8e:	8d 83 80 87 ff ff    	lea    -0x7880(%ebx),%eax
   17c94:	50                   	push   %eax
   17c95:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17c9b:	50                   	push   %eax
   17c9c:	e8 39 93 ff ff       	call   10fda <Print>
   17ca1:	83 c4 20             	add    $0x20,%esp
   17ca4:	eb fe                	jmp    17ca4 <Floppy_Transfer+0x16d>
    *head = (lba / params->sectors) % params->heads;
   17ca6:	8b 44 24 08          	mov    0x8(%esp),%eax
   17caa:	99                   	cltd   
   17cab:	f7 f9                	idiv   %ecx
   17cad:	99                   	cltd   
   17cae:	f7 fd                	idiv   %ebp
   17cb0:	89 d7                	mov    %edx,%edi
    KASSERT(*head >= 0 && *head < params->heads);
   17cb2:	85 d2                	test   %edx,%edx
   17cb4:	78 3a                	js     17cf0 <Floppy_Transfer+0x1b9>
   17cb6:	39 d5                	cmp    %edx,%ebp
   17cb8:	7e 36                	jle    17cf0 <Floppy_Transfer+0x1b9>
    *sector = (lba % params->sectors) + 1;
   17cba:	8b 44 24 08          	mov    0x8(%esp),%eax
   17cbe:	99                   	cltd   
   17cbf:	f7 f9                	idiv   %ecx
   17cc1:	8d 6a 01             	lea    0x1(%edx),%ebp
    KASSERT(*sector > 0 && *sector <= params->sectors);
   17cc4:	39 e9                	cmp    %ebp,%ecx
   17cc6:	7c 6c                	jl     17d34 <Floppy_Transfer+0x1fd>
   17cc8:	85 ed                	test   %ebp,%ebp
   17cca:	7e 68                	jle    17d34 <Floppy_Transfer+0x1fd>
	Floppy_Out((head << 2) | (drive & 3));
   17ccc:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
   17cd3:	0f b6 c0             	movzbl %al,%eax
   17cd6:	89 44 24 08          	mov    %eax,0x8(%esp)
   17cda:	c7 44 24 10 04 00 00 	movl   $0x4,0x10(%esp)
   17ce1:	00 
   17ce2:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   17ce7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   17ceb:	e9 1b 01 00 00       	jmp    17e0b <Floppy_Transfer+0x2d4>
    KASSERT(*head >= 0 && *head < params->heads);
   17cf0:	83 ec 0c             	sub    $0xc,%esp
   17cf3:	6a 4f                	push   $0x4f
   17cf5:	e8 2f 94 ff ff       	call   11129 <Set_Current_Attr>
   17cfa:	83 c4 0c             	add    $0xc,%esp
   17cfd:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17d03:	ff 30                	pushl  (%eax)
   17d05:	ff 74 24 44          	pushl  0x44(%esp)
   17d09:	68 2d 01 00 00       	push   $0x12d
   17d0e:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17d14:	50                   	push   %eax
   17d15:	8d 83 e4 85 ff ff    	lea    -0x7a1c(%ebx),%eax
   17d1b:	50                   	push   %eax
   17d1c:	8d 83 74 87 ff ff    	lea    -0x788c(%ebx),%eax
   17d22:	50                   	push   %eax
   17d23:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17d29:	50                   	push   %eax
   17d2a:	e8 ab 92 ff ff       	call   10fda <Print>
   17d2f:	83 c4 20             	add    $0x20,%esp
   17d32:	eb fe                	jmp    17d32 <Floppy_Transfer+0x1fb>
    KASSERT(*sector > 0 && *sector <= params->sectors);
   17d34:	83 ec 0c             	sub    $0xc,%esp
   17d37:	6a 4f                	push   $0x4f
   17d39:	e8 eb 93 ff ff       	call   11129 <Set_Current_Attr>
   17d3e:	83 c4 0c             	add    $0xc,%esp
   17d41:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17d47:	ff 30                	pushl  (%eax)
   17d49:	ff 74 24 44          	pushl  0x44(%esp)
   17d4d:	68 2e 01 00 00       	push   $0x12e
   17d52:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17d58:	50                   	push   %eax
   17d59:	8d 83 08 86 ff ff    	lea    -0x79f8(%ebx),%eax
   17d5f:	50                   	push   %eax
   17d60:	8d 83 74 87 ff ff    	lea    -0x788c(%ebx),%eax
   17d66:	50                   	push   %eax
   17d67:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17d6d:	50                   	push   %eax
   17d6e:	e8 67 92 ff ff       	call   10fda <Print>
   17d73:	83 c4 20             	add    $0x20,%esp
   17d76:	eb fe                	jmp    17d76 <Floppy_Transfer+0x23f>
	Disable_Interrupts();
   17d78:	83 ec 0c             	sub    $0xc,%esp
   17d7b:	6a 4f                	push   $0x4f
   17d7d:	e8 a7 93 ff ff       	call   11129 <Set_Current_Attr>
   17d82:	83 c4 0c             	add    $0xc,%esp
   17d85:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17d8b:	ff 30                	pushl  (%eax)
   17d8d:	ff 74 24 44          	pushl  0x44(%esp)
   17d91:	68 b5 01 00 00       	push   $0x1b5
   17d96:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17d9c:	50                   	push   %eax
   17d9d:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   17da3:	50                   	push   %eax
   17da4:	8d 83 68 87 ff ff    	lea    -0x7898(%ebx),%eax
   17daa:	50                   	push   %eax
   17dab:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17db1:	50                   	push   %eax
   17db2:	e8 23 92 ff ff       	call   10fda <Print>
   17db7:	83 c4 20             	add    $0x20,%esp
   17dba:	eb fe                	jmp    17dba <Floppy_Transfer+0x283>
	Enable_Interrupts();
   17dbc:	83 ec 0c             	sub    $0xc,%esp
   17dbf:	6a 4f                	push   $0x4f
   17dc1:	e8 63 93 ff ff       	call   11129 <Set_Current_Attr>
   17dc6:	83 c4 0c             	add    $0xc,%esp
   17dc9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17dcf:	ff 30                	pushl  (%eax)
   17dd1:	ff 74 24 44          	pushl  0x44(%esp)
   17dd5:	68 bf 01 00 00       	push   $0x1bf
   17dda:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17de0:	50                   	push   %eax
   17de1:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   17de7:	50                   	push   %eax
   17de8:	8d 83 68 87 ff ff    	lea    -0x7898(%ebx),%eax
   17dee:	50                   	push   %eax
   17def:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17df5:	50                   	push   %eax
   17df6:	e8 df 91 ff ff       	call   10fda <Print>
   17dfb:	83 c4 20             	add    $0x20,%esp
   17dfe:	eb fe                	jmp    17dfe <Floppy_Transfer+0x2c7>
    while (numAttempts-- > 0) {
   17e00:	83 6c 24 10 01       	subl   $0x1,0x10(%esp)
   17e05:	0f 84 e2 00 00 00    	je     17eed <Floppy_Transfer+0x3b6>
    Out_Byte(FDC_DOR_REG,
   17e0b:	83 ec 08             	sub    $0x8,%esp
   17e0e:	6a 1c                	push   $0x1c
   17e10:	68 f2 03 00 00       	push   $0x3f2
   17e15:	e8 b0 8a ff ff       	call   108ca <Out_Byte>
	Disable_Interrupts();
   17e1a:	e8 2d 84 ff ff       	call   1024c <Interrupts_Enabled>
   17e1f:	83 c4 10             	add    $0x10,%esp
   17e22:	84 c0                	test   %al,%al
   17e24:	0f 84 4e ff ff ff    	je     17d78 <Floppy_Transfer+0x241>
   17e2a:	fa                   	cli    
	Floppy_Out(FDC_COMMAND_SEEK);
   17e2b:	b8 0f 00 00 00       	mov    $0xf,%eax
   17e30:	e8 03 f9 ff ff       	call   17738 <Floppy_Out>
	Floppy_Out((head << 2) | (drive & 3));
   17e35:	8b 44 24 08          	mov    0x8(%esp),%eax
   17e39:	e8 fa f8 ff ff       	call   17738 <Floppy_Out>
	Floppy_Out(cylinder & 0xFF);
   17e3e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   17e42:	89 44 24 14          	mov    %eax,0x14(%esp)
   17e46:	e8 ed f8 ff ff       	call   17738 <Floppy_Out>
	Wait_For_Interrupt();
   17e4b:	e8 48 f9 ff ff       	call   17798 <Wait_For_Interrupt>
	Enable_Interrupts();
   17e50:	e8 f7 83 ff ff       	call   1024c <Interrupts_Enabled>
   17e55:	84 c0                	test   %al,%al
   17e57:	0f 85 5f ff ff ff    	jne    17dbc <Floppy_Transfer+0x285>
    __asm__ __volatile__ ("sti");
   17e5d:	fb                   	sti    
    Out_Byte(FDC_DOR_REG,
   17e5e:	83 ec 08             	sub    $0x8,%esp
   17e61:	6a 0c                	push   $0xc
   17e63:	68 f2 03 00 00       	push   $0x3f2
   17e68:	e8 5d 8a ff ff       	call   108ca <Out_Byte>
    Floppy_Out(FDC_COMMAND_SENSE_INT_STATUS);
   17e6d:	b8 08 00 00 00       	mov    $0x8,%eax
   17e72:	e8 c1 f8 ff ff       	call   17738 <Floppy_Out>
    *st0 = Floppy_In();
   17e77:	e8 f1 f8 ff ff       	call   1776d <Floppy_In>
   17e7c:	88 44 24 2b          	mov    %al,0x2b(%esp)
    *pcn = Floppy_In();
   17e80:	e8 e8 f8 ff ff       	call   1776d <Floppy_In>
	if (st0 & FDC_ST0_SEEK_END) {
   17e85:	83 c4 10             	add    $0x10,%esp
   17e88:	f6 44 24 1b 20       	testb  $0x20,0x1b(%esp)
   17e8d:	0f 84 6d ff ff ff    	je     17e00 <Floppy_Transfer+0x2c9>
	    if (pcn != cylinder) {
   17e93:	0f b6 c0             	movzbl %al,%eax
   17e96:	3b 44 24 0c          	cmp    0xc(%esp),%eax
   17e9a:	0f 85 60 ff ff ff    	jne    17e00 <Floppy_Transfer+0x2c9>
    LBA_To_CHS(&s_driveTable[driveNum], blockNum, &cylinder, &head, &sector);

    if (!Floppy_Seek(driveNum, cylinder, head))
	return -1;

    Disable_Interrupts();
   17ea0:	e8 a7 83 ff ff       	call   1024c <Interrupts_Enabled>
   17ea5:	84 c0                	test   %al,%al
   17ea7:	75 51                	jne    17efa <Floppy_Transfer+0x3c3>
   17ea9:	83 ec 0c             	sub    $0xc,%esp
   17eac:	6a 4f                	push   $0x4f
   17eae:	e8 76 92 ff ff       	call   11129 <Set_Current_Attr>
   17eb3:	83 c4 0c             	add    $0xc,%esp
   17eb6:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   17ebc:	ff 30                	pushl  (%eax)
   17ebe:	ff 74 24 44          	pushl  0x44(%esp)
   17ec2:	68 e7 01 00 00       	push   $0x1e7
   17ec7:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   17ecd:	50                   	push   %eax
   17ece:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   17ed4:	50                   	push   %eax
   17ed5:	8d 83 80 87 ff ff    	lea    -0x7880(%ebx),%eax
   17edb:	50                   	push   %eax
   17edc:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   17ee2:	50                   	push   %eax
   17ee3:	e8 f2 90 ff ff       	call   10fda <Print>
   17ee8:	83 c4 20             	add    $0x20,%esp
   17eeb:	eb fe                	jmp    17eeb <Floppy_Transfer+0x3b4>
	return -1;
   17eed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    Enable_Interrupts();

    /*STOP(); */
    return result;
}
   17ef2:	83 c4 2c             	add    $0x2c,%esp
   17ef5:	5b                   	pop    %ebx
   17ef6:	5e                   	pop    %esi
   17ef7:	5f                   	pop    %edi
   17ef8:	5d                   	pop    %ebp
   17ef9:	c3                   	ret    
    __asm__ __volatile__ ("cli");
   17efa:	fa                   	cli    
    Setup_DMA(dmaDirection, FDC_DMA, s_transferBuf, SECTOR_SIZE);
   17efb:	68 00 02 00 00       	push   $0x200
   17f00:	ff b3 1c 13 00 00    	pushl  0x131c(%ebx)
   17f06:	6a 02                	push   $0x2
	direction == FLOPPY_READ ? DMA_READ : DMA_WRITE;
   17f08:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   17f0d:	0f 95 c0             	setne  %al
   17f10:	0f b6 c0             	movzbl %al,%eax
    Setup_DMA(dmaDirection, FDC_DMA, s_transferBuf, SECTOR_SIZE);
   17f13:	50                   	push   %eax
   17f14:	e8 df f4 ff ff       	call   173f8 <Setup_DMA>
    Out_Byte(FDC_DOR_REG,
   17f19:	83 c4 08             	add    $0x8,%esp
   17f1c:	6a 1c                	push   $0x1c
   17f1e:	68 f2 03 00 00       	push   $0x3f2
   17f23:	e8 a2 89 ff ff       	call   108ca <Out_Byte>
    Micro_Delay(8000);
   17f28:	c7 04 24 40 1f 00 00 	movl   $0x1f40,(%esp)
   17f2f:	e8 5f a3 ff ff       	call   12293 <Micro_Delay>
    if (direction == FLOPPY_READ)
   17f34:	83 c4 10             	add    $0x10,%esp
	command = FDC_COMMAND_WRITE_SECTOR | FDC_MFM;
   17f37:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
   17f3c:	19 c0                	sbb    %eax,%eax
   17f3e:	83 e0 21             	and    $0x21,%eax
   17f41:	83 c0 45             	add    $0x45,%eax
    Floppy_Out(command);
   17f44:	0f b6 c0             	movzbl %al,%eax
   17f47:	e8 ec f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out((head << 2) | (driveNum & 3));
   17f4c:	8b 44 24 08          	mov    0x8(%esp),%eax
   17f50:	e8 e3 f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(cylinder);
   17f55:	8b 44 24 14          	mov    0x14(%esp),%eax
   17f59:	e8 da f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(head);
   17f5e:	89 f8                	mov    %edi,%eax
   17f60:	0f b6 c0             	movzbl %al,%eax
   17f63:	e8 d0 f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(sector);
   17f68:	89 e8                	mov    %ebp,%eax
   17f6a:	0f b6 c0             	movzbl %al,%eax
   17f6d:	e8 c6 f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(params->sectorSizeCode);
   17f72:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
   17f76:	e8 bd f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(params->sectors);
   17f7b:	0f b6 46 08          	movzbl 0x8(%esi),%eax
   17f7f:	e8 b4 f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(params->gapLengthCode);
   17f84:	0f b6 46 10          	movzbl 0x10(%esi),%eax
   17f88:	e8 ab f7 ff ff       	call   17738 <Floppy_Out>
    Floppy_Out(0xFF);  /* DTL */
   17f8d:	b8 ff 00 00 00       	mov    $0xff,%eax
   17f92:	e8 a1 f7 ff ff       	call   17738 <Floppy_Out>
    Wait_For_Interrupt();
   17f97:	e8 fc f7 ff ff       	call   17798 <Wait_For_Interrupt>
    st0 = Floppy_In();
   17f9c:	e8 cc f7 ff ff       	call   1776d <Floppy_In>
   17fa1:	89 c6                	mov    %eax,%esi
    st1 = Floppy_In();
   17fa3:	e8 c5 f7 ff ff       	call   1776d <Floppy_In>
    st2 = Floppy_In();
   17fa8:	e8 c0 f7 ff ff       	call   1776d <Floppy_In>
    Floppy_In();  /* cylinder */
   17fad:	e8 bb f7 ff ff       	call   1776d <Floppy_In>
    Floppy_In();  /* head */
   17fb2:	e8 b6 f7 ff ff       	call   1776d <Floppy_In>
    Floppy_In();  /* sector number */
   17fb7:	e8 b1 f7 ff ff       	call   1776d <Floppy_In>
    Floppy_In();  /* sector size */
   17fbc:	e8 ac f7 ff ff       	call   1776d <Floppy_In>
    Out_Byte(FDC_DOR_REG,
   17fc1:	83 ec 08             	sub    $0x8,%esp
   17fc4:	6a 0c                	push   $0xc
   17fc6:	68 f2 03 00 00       	push   $0x3f2
   17fcb:	e8 fa 88 ff ff       	call   108ca <Out_Byte>
    Enable_Interrupts();
   17fd0:	e8 77 82 ff ff       	call   1024c <Interrupts_Enabled>
   17fd5:	83 c4 10             	add    $0x10,%esp
   17fd8:	84 c0                	test   %al,%al
   17fda:	75 13                	jne    17fef <Floppy_Transfer+0x4b8>
    if (FDC_ST0_IS_SUCCESS(st0)) {
   17fdc:	89 f0                	mov    %esi,%eax
   17fde:	c0 e8 06             	shr    $0x6,%al
   17fe1:	0f 95 c0             	setne  %al
   17fe4:	0f b6 c0             	movzbl %al,%eax
   17fe7:	f7 d8                	neg    %eax
    __asm__ __volatile__ ("sti");
   17fe9:	fb                   	sti    
    return result;
   17fea:	e9 03 ff ff ff       	jmp    17ef2 <Floppy_Transfer+0x3bb>
    Enable_Interrupts();
   17fef:	83 ec 0c             	sub    $0xc,%esp
   17ff2:	6a 4f                	push   $0x4f
   17ff4:	e8 30 91 ff ff       	call   11129 <Set_Current_Attr>
   17ff9:	83 c4 0c             	add    $0xc,%esp
   17ffc:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18002:	ff 30                	pushl  (%eax)
   18004:	ff 74 24 44          	pushl  0x44(%esp)
   18008:	68 19 02 00 00       	push   $0x219
   1800d:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   18013:	50                   	push   %eax
   18014:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1801a:	50                   	push   %eax
   1801b:	8d 83 80 87 ff ff    	lea    -0x7880(%ebx),%eax
   18021:	50                   	push   %eax
   18022:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18028:	50                   	push   %eax
   18029:	e8 ac 8f ff ff       	call   10fda <Print>
   1802e:	83 c4 20             	add    $0x20,%esp
   18031:	eb fe                	jmp    18031 <Floppy_Transfer+0x4fa>

00018033 <Floppy_Request_Thread>:

/*
 * This is the thread which processes floppy I/O requests.
 */
static void Floppy_Request_Thread(ulong_t arg)
{
   18033:	55                   	push   %ebp
   18034:	57                   	push   %edi
   18035:	56                   	push   %esi
   18036:	53                   	push   %ebx
   18037:	83 ec 1c             	sub    $0x1c,%esp
   1803a:	e8 0f 04 00 00       	call   1844e <__x86.get_pc_thunk.bp>
   1803f:	81 c5 c1 df 00 00    	add    $0xdfc1,%ebp
    for (;;) {
	struct Block_Request *request;

	/* Wait for an I/O request to arrive */
	Debug("FRQ: Request thread waiting for a request\n");
	request = Dequeue_Request(&s_floppyRequestQueue, &s_floppyWaitQueue);
   18045:	8d 85 0c 13 00 00    	lea    0x130c(%ebp),%eax
   1804b:	89 44 24 08          	mov    %eax,0x8(%esp)
   1804f:	8d 85 14 13 00 00    	lea    0x1314(%ebp),%eax
   18055:	89 44 24 0c          	mov    %eax,0xc(%esp)
   18059:	e9 b8 00 00 00       	jmp    18116 <Floppy_Request_Thread+0xe3>
	Debug("FRQ: Got a floppy request [@%x]\n", request);
	KASSERT(request->type == BLOCK_READ || request->type == BLOCK_WRITE);
   1805e:	83 ec 0c             	sub    $0xc,%esp
   18061:	6a 4f                	push   $0x4f
   18063:	e8 c1 90 ff ff       	call   11129 <Set_Current_Attr>
   18068:	83 c4 0c             	add    $0xc,%esp
   1806b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18071:	ff 30                	pushl  (%eax)
   18073:	ff 74 24 34          	pushl  0x34(%esp)
   18077:	68 4f 02 00 00       	push   $0x24f
   1807c:	8d 85 70 84 ff ff    	lea    -0x7b90(%ebp),%eax
   18082:	50                   	push   %eax
   18083:	8d 85 34 86 ff ff    	lea    -0x79cc(%ebp),%eax
   18089:	50                   	push   %eax
   1808a:	8d 85 90 87 ff ff    	lea    -0x7870(%ebp),%eax
   18090:	50                   	push   %eax
   18091:	8d 85 54 70 ff ff    	lea    -0x8fac(%ebp),%eax
   18097:	50                   	push   %eax
   18098:	e8 3d 8f ff ff       	call   10fda <Print>
   1809d:	83 c4 20             	add    $0x20,%esp
   180a0:	eb fe                	jmp    180a0 <Floppy_Request_Thread+0x6d>

	/* Perform the I/O. */
	if (request->type == BLOCK_READ)
	    rc = Floppy_Read(request->dev->unit, request->blockNum, request->buf);
	else
	    rc = Floppy_Write(request->dev->unit, request->blockNum, request->buf);
   180a2:	8b 04 24             	mov    (%esp),%eax
   180a5:	8b 50 0c             	mov    0xc(%eax),%edx
   180a8:	8b 58 08             	mov    0x8(%eax),%ebx
   180ab:	8b 00                	mov    (%eax),%eax
   180ad:	8b 40 14             	mov    0x14(%eax),%eax
   180b0:	89 44 24 04          	mov    %eax,0x4(%esp)
    memcpy(s_transferBuf, buffer, SECTOR_SIZE);
   180b4:	8b 8d 1c 13 00 00    	mov    0x131c(%ebp),%ecx
   180ba:	8b 02                	mov    (%edx),%eax
   180bc:	89 01                	mov    %eax,(%ecx)
   180be:	8b 82 fc 01 00 00    	mov    0x1fc(%edx),%eax
   180c4:	89 81 fc 01 00 00    	mov    %eax,0x1fc(%ecx)
   180ca:	8d 79 04             	lea    0x4(%ecx),%edi
   180cd:	83 e7 fc             	and    $0xfffffffc,%edi
   180d0:	29 f9                	sub    %edi,%ecx
   180d2:	89 d6                	mov    %edx,%esi
   180d4:	29 ce                	sub    %ecx,%esi
   180d6:	81 c1 00 02 00 00    	add    $0x200,%ecx
   180dc:	c1 e9 02             	shr    $0x2,%ecx
   180df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    return Floppy_Transfer(FLOPPY_WRITE, driveNum, blockNum, buffer);
   180e1:	83 ec 0c             	sub    $0xc,%esp
   180e4:	52                   	push   %edx
   180e5:	89 d9                	mov    %ebx,%ecx
   180e7:	8b 54 24 14          	mov    0x14(%esp),%edx
   180eb:	b8 01 00 00 00       	mov    $0x1,%eax
   180f0:	e8 42 fa ff ff       	call   17b37 <Floppy_Transfer>

	/* Notify the requesting thread of the outcome of the I/O. */
	Debug("FRQ: Notifying requesting thread...\n");
	Notify_Request_Completion(request, rc == 0 ? COMPLETED : ERROR, rc);
   180f5:	83 c4 10             	add    $0x10,%esp
   180f8:	85 c0                	test   %eax,%eax
   180fa:	0f 95 c2             	setne  %dl
   180fd:	0f b6 d2             	movzbl %dl,%edx
   18100:	83 c2 01             	add    $0x1,%edx
   18103:	83 ec 04             	sub    $0x4,%esp
   18106:	50                   	push   %eax
   18107:	52                   	push   %edx
   18108:	ff 74 24 0c          	pushl  0xc(%esp)
   1810c:	89 eb                	mov    %ebp,%ebx
   1810e:	e8 c1 0a 00 00       	call   18bd4 <Notify_Request_Completion>
    for (;;) {
   18113:	83 c4 10             	add    $0x10,%esp
	request = Dequeue_Request(&s_floppyRequestQueue, &s_floppyWaitQueue);
   18116:	83 ec 08             	sub    $0x8,%esp
   18119:	ff 74 24 10          	pushl  0x10(%esp)
   1811d:	ff 74 24 18          	pushl  0x18(%esp)
   18121:	89 eb                	mov    %ebp,%ebx
   18123:	e8 c4 09 00 00       	call   18aec <Dequeue_Request>
   18128:	89 44 24 10          	mov    %eax,0x10(%esp)
	KASSERT(request->type == BLOCK_READ || request->type == BLOCK_WRITE);
   1812c:	8b 40 04             	mov    0x4(%eax),%eax
   1812f:	83 c4 10             	add    $0x10,%esp
   18132:	83 f8 01             	cmp    $0x1,%eax
   18135:	0f 87 23 ff ff ff    	ja     1805e <Floppy_Request_Thread+0x2b>
	if (request->type == BLOCK_READ)
   1813b:	85 c0                	test   %eax,%eax
   1813d:	0f 85 5f ff ff ff    	jne    180a2 <Floppy_Request_Thread+0x6f>
	    rc = Floppy_Read(request->dev->unit, request->blockNum, request->buf);
   18143:	8b 04 24             	mov    (%esp),%eax
   18146:	8b 58 0c             	mov    0xc(%eax),%ebx
   18149:	8b 70 08             	mov    0x8(%eax),%esi
   1814c:	8b 00                	mov    (%eax),%eax
   1814e:	8b 50 14             	mov    0x14(%eax),%edx
    memset(buffer, (char) 0xcd, SECTOR_SIZE);
   18151:	b8 cd cd cd cd       	mov    $0xcdcdcdcd,%eax
   18156:	c7 03 cd cd cd cd    	movl   $0xcdcdcdcd,(%ebx)
   1815c:	c7 83 fc 01 00 00 cd 	movl   $0xcdcdcdcd,0x1fc(%ebx)
   18163:	cd cd cd 
   18166:	8d 7b 04             	lea    0x4(%ebx),%edi
   18169:	83 e7 fc             	and    $0xfffffffc,%edi
   1816c:	89 d9                	mov    %ebx,%ecx
   1816e:	29 f9                	sub    %edi,%ecx
   18170:	81 c1 00 02 00 00    	add    $0x200,%ecx
   18176:	c1 e9 02             	shr    $0x2,%ecx
   18179:	f3 ab                	rep stos %eax,%es:(%edi)
    memset(s_transferBuf, (char) 0xcd, SECTOR_SIZE);
   1817b:	8b 8d 1c 13 00 00    	mov    0x131c(%ebp),%ecx
   18181:	c7 01 cd cd cd cd    	movl   $0xcdcdcdcd,(%ecx)
   18187:	c7 81 fc 01 00 00 cd 	movl   $0xcdcdcdcd,0x1fc(%ecx)
   1818e:	cd cd cd 
   18191:	8d 79 04             	lea    0x4(%ecx),%edi
   18194:	83 e7 fc             	and    $0xfffffffc,%edi
   18197:	29 f9                	sub    %edi,%ecx
   18199:	81 c1 00 02 00 00    	add    $0x200,%ecx
   1819f:	c1 e9 02             	shr    $0x2,%ecx
   181a2:	f3 ab                	rep stos %eax,%es:(%edi)
    rc = Floppy_Transfer(FLOPPY_READ, driveNum, blockNum, buffer);
   181a4:	83 ec 0c             	sub    $0xc,%esp
   181a7:	53                   	push   %ebx
   181a8:	89 f1                	mov    %esi,%ecx
   181aa:	b8 00 00 00 00       	mov    $0x0,%eax
   181af:	e8 83 f9 ff ff       	call   17b37 <Floppy_Transfer>
    if (rc == 0) {
   181b4:	83 c4 10             	add    $0x10,%esp
	Notify_Request_Completion(request, rc == 0 ? COMPLETED : ERROR, rc);
   181b7:	ba 02 00 00 00       	mov    $0x2,%edx
    if (rc == 0) {
   181bc:	85 c0                	test   %eax,%eax
   181be:	0f 85 3f ff ff ff    	jne    18103 <Floppy_Request_Thread+0xd0>
	memcpy(buffer, s_transferBuf, SECTOR_SIZE);
   181c4:	8b b5 1c 13 00 00    	mov    0x131c(%ebp),%esi
   181ca:	8b 16                	mov    (%esi),%edx
   181cc:	89 13                	mov    %edx,(%ebx)
   181ce:	8b 96 fc 01 00 00    	mov    0x1fc(%esi),%edx
   181d4:	89 93 fc 01 00 00    	mov    %edx,0x1fc(%ebx)
   181da:	8d 7b 04             	lea    0x4(%ebx),%edi
   181dd:	83 e7 fc             	and    $0xfffffffc,%edi
   181e0:	29 fb                	sub    %edi,%ebx
   181e2:	29 de                	sub    %ebx,%esi
   181e4:	81 c3 00 02 00 00    	add    $0x200,%ebx
   181ea:	c1 eb 02             	shr    $0x2,%ebx
   181ed:	89 d9                	mov    %ebx,%ecx
   181ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	Notify_Request_Completion(request, rc == 0 ? COMPLETED : ERROR, rc);
   181f1:	ba 01 00 00 00       	mov    $0x1,%edx
   181f6:	e9 08 ff ff ff       	jmp    18103 <Floppy_Request_Thread+0xd0>

000181fb <Init_Floppy>:

/*
 * Initialize the floppy controller.
 */
void Init_Floppy(void)
{
   181fb:	55                   	push   %ebp
   181fc:	57                   	push   %edi
   181fd:	56                   	push   %esi
   181fe:	53                   	push   %ebx
   181ff:	83 ec 28             	sub    $0x28,%esp
   18202:	e8 0b 80 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18207:	81 c3 f9 dd 00 00    	add    $0xddf9,%ebx
    uchar_t floppyByte;
    bool ready = false;
    bool good;

    Print("Initializing floppy controller...\n");
   1820d:	8d 83 70 86 ff ff    	lea    -0x7990(%ebx),%eax
   18213:	50                   	push   %eax
   18214:	e8 c1 8d ff ff       	call   10fda <Print>

    /* Allocate memory for DMA transfers */
    s_transferBuf = (uchar_t*) Alloc_Page();
   18219:	e8 36 a4 ff ff       	call   12654 <Alloc_Page>
   1821e:	89 83 1c 13 00 00    	mov    %eax,0x131c(%ebx)

    /* Use CMOS to get floppy configuration */
    Out_Byte(CMOS_OUT, CMOS_FLOPPY_INDEX);
   18224:	83 c4 08             	add    $0x8,%esp
   18227:	6a 10                	push   $0x10
   18229:	6a 70                	push   $0x70
   1822b:	e8 9a 86 ff ff       	call   108ca <Out_Byte>
    floppyByte = In_Byte(CMOS_IN);
   18230:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
   18237:	e8 98 86 ff ff       	call   108d4 <In_Byte>
   1823c:	89 c6                	mov    %eax,%esi
    Setup_Drive_Parameters(0, (floppyByte >> 4) & 0xF);
   1823e:	89 c2                	mov    %eax,%edx
   18240:	c0 ea 04             	shr    $0x4,%dl
   18243:	0f b6 d2             	movzbl %dl,%edx
   18246:	b8 00 00 00 00       	mov    $0x0,%eax
   1824b:	e8 18 f8 ff ff       	call   17a68 <Setup_Drive_Parameters>
    Setup_Drive_Parameters(1, floppyByte & 0xF);
   18250:	89 f2                	mov    %esi,%edx
   18252:	83 e2 0f             	and    $0xf,%edx
   18255:	b8 01 00 00 00       	mov    $0x1,%eax
   1825a:	e8 09 f8 ff ff       	call   17a68 <Setup_Drive_Parameters>

    /* Install floppy interrupt handler */
    Install_IRQ(FDC_IRQ, &Floppy_Interrupt_Handler);
   1825f:	83 c4 08             	add    $0x8,%esp
   18262:	8d 83 36 1a ff ff    	lea    -0xe5ca(%ebx),%eax
   18268:	50                   	push   %eax
   18269:	6a 06                	push   $0x6
   1826b:	e8 67 82 ff ff       	call   104d7 <Install_IRQ>
    Enable_IRQ(FDC_IRQ);
   18270:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
   18277:	e8 f3 82 ff ff       	call   1056f <Enable_IRQ>

    /* Reset and calibrate the controller. */
    Disable_Interrupts();
   1827c:	e8 cb 7f ff ff       	call   1024c <Interrupts_Enabled>
   18281:	89 c7                	mov    %eax,%edi
   18283:	83 c4 10             	add    $0x10,%esp
   18286:	84 c0                	test   %al,%al
   18288:	75 44                	jne    182ce <Init_Floppy+0xd3>
   1828a:	83 ec 0c             	sub    $0xc,%esp
   1828d:	6a 4f                	push   $0x4f
   1828f:	e8 95 8e ff ff       	call   11129 <Set_Current_Attr>
   18294:	83 c4 0c             	add    $0xc,%esp
   18297:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1829d:	ff 30                	pushl  (%eax)
   1829f:	ff 74 24 34          	pushl  0x34(%esp)
   182a3:	68 7b 02 00 00       	push   $0x27b
   182a8:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   182ae:	50                   	push   %eax
   182af:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   182b5:	50                   	push   %eax
   182b6:	8d 83 a8 87 ff ff    	lea    -0x7858(%ebx),%eax
   182bc:	50                   	push   %eax
   182bd:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   182c3:	50                   	push   %eax
   182c4:	e8 11 8d ff ff       	call   10fda <Print>
   182c9:	83 c4 20             	add    $0x20,%esp
   182cc:	eb fe                	jmp    182cc <Init_Floppy+0xd1>
    __asm__ __volatile__ ("cli");
   182ce:	fa                   	cli    
    Out_Byte(FDC_DOR_REG, 0);
   182cf:	83 ec 08             	sub    $0x8,%esp
   182d2:	6a 00                	push   $0x0
   182d4:	68 f2 03 00 00       	push   $0x3f2
   182d9:	e8 ec 85 ff ff       	call   108ca <Out_Byte>
    Out_Byte(FDC_DOR_REG,
   182de:	83 c4 08             	add    $0x8,%esp
   182e1:	6a 1c                	push   $0x1c
   182e3:	68 f2 03 00 00       	push   $0x3f2
   182e8:	e8 dd 85 ff ff       	call   108ca <Out_Byte>
    KASSERT(!Interrupts_Enabled());
   182ed:	e8 5a 7f ff ff       	call   1024c <Interrupts_Enabled>
   182f2:	89 c5                	mov    %eax,%ebp
   182f4:	83 c4 10             	add    $0x10,%esp
   182f7:	be 04 00 00 00       	mov    $0x4,%esi
   182fc:	84 c0                	test   %al,%al
   182fe:	0f 85 82 00 00 00    	jne    18386 <Init_Floppy+0x18b>
	Floppy_Out(FDC_COMMAND_CALIBRATE);
   18304:	b8 07 00 00 00       	mov    $0x7,%eax
   18309:	e8 2a f4 ff ff       	call   17738 <Floppy_Out>
	Floppy_Out((uchar_t) drive);
   1830e:	b8 00 00 00 00       	mov    $0x0,%eax
   18313:	e8 20 f4 ff ff       	call   17738 <Floppy_Out>
	Wait_For_Interrupt();
   18318:	e8 7b f4 ff ff       	call   17798 <Wait_For_Interrupt>
    Floppy_Out(FDC_COMMAND_SENSE_INT_STATUS);
   1831d:	b8 08 00 00 00       	mov    $0x8,%eax
   18322:	e8 11 f4 ff ff       	call   17738 <Floppy_Out>
    *st0 = Floppy_In();
   18327:	e8 41 f4 ff ff       	call   1776d <Floppy_In>
   1832c:	88 44 24 0f          	mov    %al,0xf(%esp)
    *pcn = Floppy_In();
   18330:	e8 38 f4 ff ff       	call   1776d <Floppy_In>
	if (st0 & FDC_ST0_SEEK_END) {
   18335:	f6 44 24 0f 20       	testb  $0x20,0xf(%esp)
   1833a:	75 07                	jne    18343 <Init_Floppy+0x148>
    while (numAttempts-- > 0) {
   1833c:	83 ee 01             	sub    $0x1,%esi
   1833f:	75 c3                	jne    18304 <Init_Floppy+0x109>
    bool success = false;
   18341:	89 ef                	mov    %ebp,%edi
    good = Reset_Controller();
    Enable_Interrupts();
   18343:	e8 04 7f ff ff       	call   1024c <Interrupts_Enabled>
   18348:	84 c0                	test   %al,%al
   1834a:	75 7e                	jne    183ca <Init_Floppy+0x1cf>
    __asm__ __volatile__ ("sti");
   1834c:	fb                   	sti    
    if (!good) {
   1834d:	89 f8                	mov    %edi,%eax
   1834f:	84 c0                	test   %al,%al
   18351:	0f 84 b7 00 00 00    	je     1840e <Init_Floppy+0x213>
	Print("  Failed to reset controller!\n");
	goto done;
    }

    /* Reserve DMA channel 2. */
    if (!Reserve_DMA(FDC_DMA)) {
   18357:	83 ec 0c             	sub    $0xc,%esp
   1835a:	6a 02                	push   $0x2
   1835c:	e8 57 ed ff ff       	call   170b8 <Reserve_DMA>
   18361:	83 c4 10             	add    $0x10,%esp
   18364:	84 c0                	test   %al,%al
   18366:	0f 84 ce 00 00 00    	je     1843a <Init_Floppy+0x23f>
    /*
     * Driver is now ready for requests.
     * Start the request processing thread.
     */
    ready = true;
    Start_Kernel_Thread(Floppy_Request_Thread, 0, PRIORITY_NORMAL, true);
   1836c:	6a 01                	push   $0x1
   1836e:	6a 05                	push   $0x5
   18370:	6a 00                	push   $0x0
   18372:	8d 83 33 20 ff ff    	lea    -0xdfcd(%ebx),%eax
   18378:	50                   	push   %eax
   18379:	e8 f7 c9 ff ff       	call   14d75 <Start_Kernel_Thread>
   1837e:	83 c4 10             	add    $0x10,%esp
   18381:	e9 ac 00 00 00       	jmp    18432 <Init_Floppy+0x237>
    KASSERT(!Interrupts_Enabled());
   18386:	83 ec 0c             	sub    $0xc,%esp
   18389:	6a 4f                	push   $0x4f
   1838b:	e8 99 8d ff ff       	call   11129 <Set_Current_Attr>
   18390:	83 c4 0c             	add    $0xc,%esp
   18393:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18399:	ff 30                	pushl  (%eax)
   1839b:	ff 74 24 34          	pushl  0x34(%esp)
   1839f:	68 75 01 00 00       	push   $0x175
   183a4:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   183aa:	50                   	push   %eax
   183ab:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   183b1:	50                   	push   %eax
   183b2:	8d 83 04 87 ff ff    	lea    -0x78fc(%ebx),%eax
   183b8:	50                   	push   %eax
   183b9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   183bf:	50                   	push   %eax
   183c0:	e8 15 8c ff ff       	call   10fda <Print>
   183c5:	83 c4 20             	add    $0x20,%esp
   183c8:	eb fe                	jmp    183c8 <Init_Floppy+0x1cd>
    Enable_Interrupts();
   183ca:	83 ec 0c             	sub    $0xc,%esp
   183cd:	6a 4f                	push   $0x4f
   183cf:	e8 55 8d ff ff       	call   11129 <Set_Current_Attr>
   183d4:	83 c4 0c             	add    $0xc,%esp
   183d7:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   183dd:	ff 30                	pushl  (%eax)
   183df:	ff 74 24 34          	pushl  0x34(%esp)
   183e3:	68 7d 02 00 00       	push   $0x27d
   183e8:	8d 83 70 84 ff ff    	lea    -0x7b90(%ebx),%eax
   183ee:	50                   	push   %eax
   183ef:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   183f5:	50                   	push   %eax
   183f6:	8d 83 a8 87 ff ff    	lea    -0x7858(%ebx),%eax
   183fc:	50                   	push   %eax
   183fd:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18403:	50                   	push   %eax
   18404:	e8 d1 8b ff ff       	call   10fda <Print>
   18409:	83 c4 20             	add    $0x20,%esp
   1840c:	eb fe                	jmp    1840c <Init_Floppy+0x211>
	Print("  Failed to reset controller!\n");
   1840e:	83 ec 0c             	sub    $0xc,%esp
   18411:	8d 83 94 86 ff ff    	lea    -0x796c(%ebx),%eax
   18417:	50                   	push   %eax
   18418:	e8 bd 8b ff ff       	call   10fda <Print>
   1841d:	83 c4 10             	add    $0x10,%esp

done:
    if (!ready)
	Print("  Floppy controller initialization FAILED\n");
   18420:	83 ec 0c             	sub    $0xc,%esp
   18423:	8d 83 d8 86 ff ff    	lea    -0x7928(%ebx),%eax
   18429:	50                   	push   %eax
   1842a:	e8 ab 8b ff ff       	call   10fda <Print>
   1842f:	83 c4 10             	add    $0x10,%esp
}
   18432:	83 c4 1c             	add    $0x1c,%esp
   18435:	5b                   	pop    %ebx
   18436:	5e                   	pop    %esi
   18437:	5f                   	pop    %edi
   18438:	5d                   	pop    %ebp
   18439:	c3                   	ret    
	Print("  Failed to reserve DMA channel\n");
   1843a:	83 ec 0c             	sub    $0xc,%esp
   1843d:	8d 83 b4 86 ff ff    	lea    -0x794c(%ebx),%eax
   18443:	50                   	push   %eax
   18444:	e8 91 8b ff ff       	call   10fda <Print>
   18449:	83 c4 10             	add    $0x10,%esp
   1844c:	eb d2                	jmp    18420 <Init_Floppy+0x225>

0001844e <__x86.get_pc_thunk.bp>:
   1844e:	8b 2c 24             	mov    (%esp),%ebp
   18451:	c3                   	ret    

00018452 <Parse_ELF_Executable>:
 *   and entry address; to be filled in
 * @return 0 if successful, < 0 on error
 */
int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength,
    struct Exe_Format *exeFormat)
{
   18452:	56                   	push   %esi
   18453:	53                   	push   %ebx
   18454:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   18458:	8b 44 24 14          	mov    0x14(%esp),%eax
    elfHeader *elf_head = (elfHeader *)exeFileData;
 
    exeFormat->numSegments = elf_head->phnum;
   1845c:	0f b7 53 2c          	movzwl 0x2c(%ebx),%edx
   18460:	89 50 64             	mov    %edx,0x64(%eax)
    exeFormat->entryAddr = elf_head->entry;
   18463:	8b 53 18             	mov    0x18(%ebx),%edx
   18466:	89 50 68             	mov    %edx,0x68(%eax)
 
    programHeader *ph = (programHeader *)(exeFileData + elf_head->phoff);
   18469:	8b 53 1c             	mov    0x1c(%ebx),%edx
    for(int i = 0; i < elf_head->phnum; i++) {
   1846c:	66 83 7b 2c 00       	cmpw   $0x0,0x2c(%ebx)
   18471:	74 35                	je     184a8 <Parse_ELF_Executable+0x56>
   18473:	01 da                	add    %ebx,%edx
   18475:	b9 00 00 00 00       	mov    $0x0,%ecx
        exeFormat->segmentList[i].offsetInFile = ph[i].offset;
   1847a:	8b 72 04             	mov    0x4(%edx),%esi
   1847d:	89 30                	mov    %esi,(%eax)
        exeFormat->segmentList[i].lengthInFile = ph[i].fileSize;
   1847f:	8b 72 10             	mov    0x10(%edx),%esi
   18482:	89 70 04             	mov    %esi,0x4(%eax)
        exeFormat->segmentList[i].startAddress = ph[i].paddr;
   18485:	8b 72 0c             	mov    0xc(%edx),%esi
   18488:	89 70 08             	mov    %esi,0x8(%eax)
        exeFormat->segmentList[i].sizeInMemory = ph[i].memSize;
   1848b:	8b 72 14             	mov    0x14(%edx),%esi
   1848e:	89 70 0c             	mov    %esi,0xc(%eax)
        exeFormat->segmentList[i].protFlags = ph[i].flags;
   18491:	8b 72 18             	mov    0x18(%edx),%esi
   18494:	89 70 10             	mov    %esi,0x10(%eax)
    for(int i = 0; i < elf_head->phnum; i++) {
   18497:	83 c1 01             	add    $0x1,%ecx
   1849a:	83 c2 20             	add    $0x20,%edx
   1849d:	83 c0 14             	add    $0x14,%eax
   184a0:	0f b7 73 2c          	movzwl 0x2c(%ebx),%esi
   184a4:	39 ce                	cmp    %ecx,%esi
   184a6:	7f d2                	jg     1847a <Parse_ELF_Executable+0x28>
    }
    // Print("Num = %d\n", exeFormat->numSegments);
	return 0;
}
   184a8:	b8 00 00 00 00       	mov    $0x0,%eax
   184ad:	5b                   	pop    %ebx
   184ae:	5e                   	pop    %esi
   184af:	c3                   	ret    

000184b0 <Register_Block_Device>:
 * Returns 0 if successful, error code otherwise.
 */
int Register_Block_Device(const char *name, struct Block_Device_Ops *ops,
    int unit, void *driverData, struct Thread_Queue *waitQueue,
    struct Block_Request_List *requestQueue)
{
   184b0:	55                   	push   %ebp
   184b1:	57                   	push   %edi
   184b2:	56                   	push   %esi
   184b3:	53                   	push   %ebx
   184b4:	83 ec 0c             	sub    $0xc,%esp
   184b7:	e8 56 7d ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   184bc:	81 c3 44 db 00 00    	add    $0xdb44,%ebx
   184c2:	8b 6c 24 30          	mov    0x30(%esp),%ebp
   184c6:	8b 7c 24 34          	mov    0x34(%esp),%edi
    struct Block_Device *dev;

    KASSERT(ops != 0);
   184ca:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   184cf:	0f 84 c6 00 00 00    	je     1859b <Register_Block_Device+0xeb>
    KASSERT(waitQueue != 0);
   184d5:	85 ed                	test   %ebp,%ebp
   184d7:	0f 84 ff 00 00 00    	je     185dc <Register_Block_Device+0x12c>
    KASSERT(requestQueue != 0);
   184dd:	85 ff                	test   %edi,%edi
   184df:	0f 84 38 01 00 00    	je     1861d <Register_Block_Device+0x16d>

    dev = (struct Block_Device*) Malloc(sizeof(*dev));
   184e5:	83 ec 0c             	sub    $0xc,%esp
   184e8:	6a 30                	push   $0x30
   184ea:	e8 bd b6 ff ff       	call   13bac <Malloc>
   184ef:	89 c6                	mov    %eax,%esi
    if (dev == 0)
   184f1:	83 c4 10             	add    $0x10,%esp
   184f4:	85 c0                	test   %eax,%eax
   184f6:	0f 84 77 01 00 00    	je     18673 <Register_Block_Device+0x1c3>
	return ENOMEM;

    strcpy(dev->name, name);
   184fc:	83 ec 08             	sub    $0x8,%esp
   184ff:	ff 74 24 28          	pushl  0x28(%esp)
   18503:	50                   	push   %eax
   18504:	e8 f9 46 00 00       	call   1cc02 <strcpy>
    dev->ops = ops;
   18509:	8b 44 24 34          	mov    0x34(%esp),%eax
   1850d:	89 46 10             	mov    %eax,0x10(%esi)
    dev->unit = unit;
   18510:	8b 44 24 38          	mov    0x38(%esp),%eax
   18514:	89 46 14             	mov    %eax,0x14(%esi)
    dev->inUse = false;
   18517:	c6 46 18 00          	movb   $0x0,0x18(%esi)
    dev->driverData = driverData;
   1851b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1851f:	89 46 1c             	mov    %eax,0x1c(%esi)
    dev->waitQueue = waitQueue;
   18522:	89 6e 20             	mov    %ebp,0x20(%esi)
    dev->requestQueue = requestQueue;
   18525:	89 7e 24             	mov    %edi,0x24(%esi)

    Mutex_Lock(&s_blockdevLock);
   18528:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   1852e:	89 04 24             	mov    %eax,(%esp)
   18531:	e8 a9 ba ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Block_Device_List, Block_Device);
   18536:	8b 83 24 13 00 00    	mov    0x1324(%ebx),%eax
   1853c:	83 c4 10             	add    $0x10,%esp
   1853f:	85 c0                	test   %eax,%eax
   18541:	0f 84 33 01 00 00    	je     1867a <Register_Block_Device+0x1ca>
   18547:	39 c6                	cmp    %eax,%esi
   18549:	74 0f                	je     1855a <Register_Block_Device+0xaa>
   1854b:	8b 40 2c             	mov    0x2c(%eax),%eax
   1854e:	85 c0                	test   %eax,%eax
   18550:	0f 84 24 01 00 00    	je     1867a <Register_Block_Device+0x1ca>
   18556:	39 c6                	cmp    %eax,%esi
   18558:	75 f1                	jne    1854b <Register_Block_Device+0x9b>
   1855a:	83 ec 0c             	sub    $0xc,%esp
   1855d:	6a 4f                	push   $0x4f
   1855f:	e8 c5 8b ff ff       	call   11129 <Set_Current_Attr>
   18564:	83 c4 0c             	add    $0xc,%esp
   18567:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1856d:	ff 30                	pushl  (%eax)
   1856f:	ff 74 24 24          	pushl  0x24(%esp)
   18573:	6a 27                	push   $0x27
   18575:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   1857b:	50                   	push   %eax
   1857c:	8d 83 3c 88 ff ff    	lea    -0x77c4(%ebx),%eax
   18582:	50                   	push   %eax
   18583:	8d 83 60 89 ff ff    	lea    -0x76a0(%ebx),%eax
   18589:	50                   	push   %eax
   1858a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18590:	50                   	push   %eax
   18591:	e8 44 8a ff ff       	call   10fda <Print>
   18596:	83 c4 20             	add    $0x20,%esp
   18599:	eb fe                	jmp    18599 <Register_Block_Device+0xe9>
    KASSERT(ops != 0);
   1859b:	83 ec 0c             	sub    $0xc,%esp
   1859e:	6a 4f                	push   $0x4f
   185a0:	e8 84 8b ff ff       	call   11129 <Set_Current_Attr>
   185a5:	83 c4 0c             	add    $0xc,%esp
   185a8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   185ae:	ff 30                	pushl  (%eax)
   185b0:	ff 74 24 24          	pushl  0x24(%esp)
   185b4:	6a 51                	push   $0x51
   185b6:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   185bc:	50                   	push   %eax
   185bd:	8d 83 cd 87 ff ff    	lea    -0x7833(%ebx),%eax
   185c3:	50                   	push   %eax
   185c4:	8d 83 84 89 ff ff    	lea    -0x767c(%ebx),%eax
   185ca:	50                   	push   %eax
   185cb:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   185d1:	50                   	push   %eax
   185d2:	e8 03 8a ff ff       	call   10fda <Print>
   185d7:	83 c4 20             	add    $0x20,%esp
   185da:	eb fe                	jmp    185da <Register_Block_Device+0x12a>
    KASSERT(waitQueue != 0);
   185dc:	83 ec 0c             	sub    $0xc,%esp
   185df:	6a 4f                	push   $0x4f
   185e1:	e8 43 8b ff ff       	call   11129 <Set_Current_Attr>
   185e6:	83 c4 0c             	add    $0xc,%esp
   185e9:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   185ef:	ff 30                	pushl  (%eax)
   185f1:	ff 74 24 24          	pushl  0x24(%esp)
   185f5:	6a 52                	push   $0x52
   185f7:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   185fd:	50                   	push   %eax
   185fe:	8d 83 d6 87 ff ff    	lea    -0x782a(%ebx),%eax
   18604:	50                   	push   %eax
   18605:	8d 83 84 89 ff ff    	lea    -0x767c(%ebx),%eax
   1860b:	50                   	push   %eax
   1860c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18612:	50                   	push   %eax
   18613:	e8 c2 89 ff ff       	call   10fda <Print>
   18618:	83 c4 20             	add    $0x20,%esp
   1861b:	eb fe                	jmp    1861b <Register_Block_Device+0x16b>
    KASSERT(requestQueue != 0);
   1861d:	83 ec 0c             	sub    $0xc,%esp
   18620:	6a 4f                	push   $0x4f
   18622:	e8 02 8b ff ff       	call   11129 <Set_Current_Attr>
   18627:	83 c4 0c             	add    $0xc,%esp
   1862a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18630:	ff 30                	pushl  (%eax)
   18632:	ff 74 24 24          	pushl  0x24(%esp)
   18636:	6a 53                	push   $0x53
   18638:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   1863e:	50                   	push   %eax
   1863f:	8d 83 e5 87 ff ff    	lea    -0x781b(%ebx),%eax
   18645:	50                   	push   %eax
   18646:	8d 83 84 89 ff ff    	lea    -0x767c(%ebx),%eax
   1864c:	50                   	push   %eax
   1864d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18653:	50                   	push   %eax
   18654:	e8 81 89 ff ff       	call   10fda <Print>
   18659:	83 c4 20             	add    $0x20,%esp
   1865c:	eb fe                	jmp    1865c <Register_Block_Device+0x1ac>
IMPLEMENT_LIST(Block_Device_List, Block_Device);
   1865e:	89 b3 28 13 00 00    	mov    %esi,0x1328(%ebx)
   18664:	89 b3 24 13 00 00    	mov    %esi,0x1324(%ebx)
   1866a:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
   18671:	eb 24                	jmp    18697 <Register_Block_Device+0x1e7>
	return ENOMEM;
   18673:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   18678:	eb 34                	jmp    186ae <Register_Block_Device+0x1fe>
IMPLEMENT_LIST(Block_Device_List, Block_Device);
   1867a:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
   18681:	8b 83 28 13 00 00    	mov    0x1328(%ebx),%eax
   18687:	85 c0                	test   %eax,%eax
   18689:	74 d3                	je     1865e <Register_Block_Device+0x1ae>
   1868b:	89 70 2c             	mov    %esi,0x2c(%eax)
   1868e:	89 46 28             	mov    %eax,0x28(%esi)
   18691:	89 b3 28 13 00 00    	mov    %esi,0x1328(%ebx)
    /* FIXME: handle name conflict with existing device */
    Debug("Registering block device %s\n", dev->name);
    Add_To_Back_Of_Block_Device_List(&s_deviceList, dev);
    Mutex_Unlock(&s_blockdevLock);
   18697:	83 ec 0c             	sub    $0xc,%esp
   1869a:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   186a0:	50                   	push   %eax
   186a1:	e8 6c ba ff ff       	call   14112 <Mutex_Unlock>

    return 0;
   186a6:	83 c4 10             	add    $0x10,%esp
   186a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   186ae:	83 c4 0c             	add    $0xc,%esp
   186b1:	5b                   	pop    %ebx
   186b2:	5e                   	pop    %esi
   186b3:	5f                   	pop    %edi
   186b4:	5d                   	pop    %ebp
   186b5:	c3                   	ret    

000186b6 <Open_Block_Device>:
/*
 * Open a named block device.
 * Return 0 if successful, error code on error.
 */
int Open_Block_Device(const char *name, struct Block_Device **pDev)
{
   186b6:	57                   	push   %edi
   186b7:	56                   	push   %esi
   186b8:	53                   	push   %ebx
   186b9:	e8 54 7b ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   186be:	81 c3 42 d9 00 00    	add    $0xd942,%ebx
   186c4:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct Block_Device *dev;
    int rc = 0;

    Mutex_Lock(&s_blockdevLock);
   186c8:	83 ec 0c             	sub    $0xc,%esp
   186cb:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   186d1:	50                   	push   %eax
   186d2:	e8 08 b9 ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Block_Device_List, Block_Device);
   186d7:	8b b3 24 13 00 00    	mov    0x1324(%ebx),%esi

    dev = Get_Front_Of_Block_Device_List(&s_deviceList);
    while (dev != 0) {
   186dd:	83 c4 10             	add    $0x10,%esp
   186e0:	85 f6                	test   %esi,%esi
   186e2:	74 5d                	je     18741 <Open_Block_Device+0x8b>
	if (strcmp(dev->name, name) == 0)
   186e4:	83 ec 08             	sub    $0x8,%esp
   186e7:	57                   	push   %edi
   186e8:	56                   	push   %esi
   186e9:	e8 2b 44 00 00       	call   1cb19 <strcmp>
   186ee:	83 c4 10             	add    $0x10,%esp
   186f1:	85 c0                	test   %eax,%eax
   186f3:	74 0e                	je     18703 <Open_Block_Device+0x4d>
IMPLEMENT_LIST(Block_Device_List, Block_Device);
   186f5:	8b 76 2c             	mov    0x2c(%esi),%esi
    while (dev != 0) {
   186f8:	85 f6                	test   %esi,%esi
   186fa:	75 e8                	jne    186e4 <Open_Block_Device+0x2e>
	    break;
	dev = Get_Next_In_Block_Device_List(dev);
    }

    if (dev == 0)
	rc = ENODEV;
   186fc:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
   18701:	eb 26                	jmp    18729 <Open_Block_Device+0x73>
    if (dev == 0)
   18703:	85 f6                	test   %esi,%esi
   18705:	74 41                	je     18748 <Open_Block_Device+0x92>
    else if (dev->inUse)
   18707:	80 7e 18 00          	cmpb   $0x0,0x18(%esi)
   1870b:	75 42                	jne    1874f <Open_Block_Device+0x99>
	rc = EBUSY;
    else {
	rc = dev->ops->Open(dev);
   1870d:	83 ec 0c             	sub    $0xc,%esp
   18710:	8b 46 10             	mov    0x10(%esi),%eax
   18713:	56                   	push   %esi
   18714:	ff 10                	call   *(%eax)
   18716:	89 c7                	mov    %eax,%edi
	if (rc == 0) {
   18718:	83 c4 10             	add    $0x10,%esp
   1871b:	85 c0                	test   %eax,%eax
   1871d:	75 0a                	jne    18729 <Open_Block_Device+0x73>
	    *pDev = dev;
   1871f:	8b 44 24 14          	mov    0x14(%esp),%eax
   18723:	89 30                	mov    %esi,(%eax)
	    dev->inUse = true;
   18725:	c6 46 18 01          	movb   $0x1,0x18(%esi)
	}
    }

    Mutex_Unlock(&s_blockdevLock);
   18729:	83 ec 0c             	sub    $0xc,%esp
   1872c:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   18732:	50                   	push   %eax
   18733:	e8 da b9 ff ff       	call   14112 <Mutex_Unlock>

    return rc;
   18738:	83 c4 10             	add    $0x10,%esp
}
   1873b:	89 f8                	mov    %edi,%eax
   1873d:	5b                   	pop    %ebx
   1873e:	5e                   	pop    %esi
   1873f:	5f                   	pop    %edi
   18740:	c3                   	ret    
	rc = ENODEV;
   18741:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
   18746:	eb e1                	jmp    18729 <Open_Block_Device+0x73>
   18748:	bf fc ff ff ff       	mov    $0xfffffffc,%edi
   1874d:	eb da                	jmp    18729 <Open_Block_Device+0x73>
	rc = EBUSY;
   1874f:	bf fa ff ff ff       	mov    $0xfffffffa,%edi
   18754:	eb d3                	jmp    18729 <Open_Block_Device+0x73>

00018756 <Close_Block_Device>:
/*
 * Close given block device.
 * Return 0 if successful, error code on error.
 */
int Close_Block_Device(struct Block_Device *dev)
{
   18756:	57                   	push   %edi
   18757:	56                   	push   %esi
   18758:	53                   	push   %ebx
   18759:	e8 b4 7a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1875e:	81 c3 a2 d8 00 00    	add    $0xd8a2,%ebx
   18764:	8b 7c 24 10          	mov    0x10(%esp),%edi
    int rc;

    Mutex_Lock(&s_blockdevLock);
   18768:	83 ec 0c             	sub    $0xc,%esp
   1876b:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   18771:	50                   	push   %eax
   18772:	e8 68 b8 ff ff       	call   13fdf <Mutex_Lock>

    KASSERT(dev->inUse);
   18777:	83 c4 10             	add    $0x10,%esp
   1877a:	80 7f 18 00          	cmpb   $0x0,0x18(%edi)
   1877e:	74 2f                	je     187af <Close_Block_Device+0x59>
    rc = dev->ops->Close(dev);
   18780:	83 ec 0c             	sub    $0xc,%esp
   18783:	8b 47 10             	mov    0x10(%edi),%eax
   18786:	57                   	push   %edi
   18787:	ff 50 04             	call   *0x4(%eax)
   1878a:	89 c6                	mov    %eax,%esi
    if (rc == 0)
   1878c:	83 c4 10             	add    $0x10,%esp
   1878f:	85 c0                	test   %eax,%eax
   18791:	75 04                	jne    18797 <Close_Block_Device+0x41>
	dev->inUse = false;
   18793:	c6 47 18 00          	movb   $0x0,0x18(%edi)

    Mutex_Unlock(&s_blockdevLock);
   18797:	83 ec 0c             	sub    $0xc,%esp
   1879a:	8d 83 2c 13 00 00    	lea    0x132c(%ebx),%eax
   187a0:	50                   	push   %eax
   187a1:	e8 6c b9 ff ff       	call   14112 <Mutex_Unlock>

    return rc;
   187a6:	83 c4 10             	add    $0x10,%esp
}
   187a9:	89 f0                	mov    %esi,%eax
   187ab:	5b                   	pop    %ebx
   187ac:	5e                   	pop    %esi
   187ad:	5f                   	pop    %edi
   187ae:	c3                   	ret    
    KASSERT(dev->inUse);
   187af:	83 ec 0c             	sub    $0xc,%esp
   187b2:	6a 4f                	push   $0x4f
   187b4:	e8 70 89 ff ff       	call   11129 <Set_Current_Attr>
   187b9:	83 c4 0c             	add    $0xc,%esp
   187bc:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   187c2:	ff 30                	pushl  (%eax)
   187c4:	ff 74 24 14          	pushl  0x14(%esp)
   187c8:	68 97 00 00 00       	push   $0x97
   187cd:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   187d3:	50                   	push   %eax
   187d4:	8d 83 94 84 ff ff    	lea    -0x7b6c(%ebx),%eax
   187da:	50                   	push   %eax
   187db:	8d 83 3c 89 ff ff    	lea    -0x76c4(%ebx),%eax
   187e1:	50                   	push   %eax
   187e2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   187e8:	50                   	push   %eax
   187e9:	e8 ec 87 ff ff       	call   10fda <Print>
   187ee:	83 c4 20             	add    $0x20,%esp
   187f1:	eb fe                	jmp    187f1 <Close_Block_Device+0x9b>

000187f3 <Create_Request>:
/*
 * Create a block device request to transfer a single block.
 */
struct Block_Request *Create_Request(struct Block_Device *dev, enum Request_Type type,
    int blockNum, void *buf)
{
   187f3:	53                   	push   %ebx
   187f4:	83 ec 14             	sub    $0x14,%esp
   187f7:	e8 16 7a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   187fc:	81 c3 04 d8 00 00    	add    $0xd804,%ebx
    struct Block_Request *request = Malloc(sizeof(*request));
   18802:	6a 28                	push   $0x28
   18804:	e8 a3 b3 ff ff       	call   13bac <Malloc>
    if (request != 0) {
   18809:	83 c4 10             	add    $0x10,%esp
   1880c:	85 c0                	test   %eax,%eax
   1880e:	74 30                	je     18840 <Create_Request+0x4d>
	request->dev = dev;
   18810:	8b 54 24 10          	mov    0x10(%esp),%edx
   18814:	89 10                	mov    %edx,(%eax)
	request->type = type;
   18816:	8b 54 24 14          	mov    0x14(%esp),%edx
   1881a:	89 50 04             	mov    %edx,0x4(%eax)
	request->blockNum = blockNum;
   1881d:	8b 54 24 18          	mov    0x18(%esp),%edx
   18821:	89 50 08             	mov    %edx,0x8(%eax)
	request->buf = buf;
   18824:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   18828:	89 50 0c             	mov    %edx,0xc(%eax)
	request->state = PENDING;
   1882b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
IMPLEMENT_LIST(Thread_Queue, Kernel_Thread);
   18832:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   18839:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	Clear_Thread_Queue(&request->waitQueue);
    }
    return request;
}
   18840:	83 c4 08             	add    $0x8,%esp
   18843:	5b                   	pop    %ebx
   18844:	c3                   	ret    

00018845 <Post_Request_And_Wait>:
 * Send a block IO request to a device and wait for it to be handled.
 * Returns when the driver completes the requests or signals
 * an error.
 */
void Post_Request_And_Wait(struct Block_Request *request)
{
   18845:	57                   	push   %edi
   18846:	56                   	push   %esi
   18847:	53                   	push   %ebx
   18848:	e8 c5 79 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1884d:	81 c3 b3 d7 00 00    	add    $0xd7b3,%ebx
   18853:	8b 74 24 10          	mov    0x10(%esp),%esi
    struct Block_Device *dev;

    KASSERT(request != 0);
   18857:	85 f6                	test   %esi,%esi
   18859:	74 5b                	je     188b6 <Post_Request_And_Wait+0x71>

    dev = request->dev;
   1885b:	8b 3e                	mov    (%esi),%edi
    KASSERT(dev != 0);
   1885d:	85 ff                	test   %edi,%edi
   1885f:	0f 84 95 00 00 00    	je     188fa <Post_Request_And_Wait+0xb5>

    /* Send request to the driver */
    Debug("Posting block device request [@%x]...\n", request);
    Disable_Interrupts();
   18865:	e8 e2 79 ff ff       	call   1024c <Interrupts_Enabled>
   1886a:	84 c0                	test   %al,%al
   1886c:	0f 85 cc 00 00 00    	jne    1893e <Post_Request_And_Wait+0xf9>
   18872:	83 ec 0c             	sub    $0xc,%esp
   18875:	6a 4f                	push   $0x4f
   18877:	e8 ad 88 ff ff       	call   11129 <Set_Current_Attr>
   1887c:	83 c4 0c             	add    $0xc,%esp
   1887f:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18885:	ff 30                	pushl  (%eax)
   18887:	ff 74 24 14          	pushl  0x14(%esp)
   1888b:	68 c3 00 00 00       	push   $0xc3
   18890:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18896:	50                   	push   %eax
   18897:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   1889d:	50                   	push   %eax
   1889e:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   188a4:	50                   	push   %eax
   188a5:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   188ab:	50                   	push   %eax
   188ac:	e8 29 87 ff ff       	call   10fda <Print>
   188b1:	83 c4 20             	add    $0x20,%esp
   188b4:	eb fe                	jmp    188b4 <Post_Request_And_Wait+0x6f>
    KASSERT(request != 0);
   188b6:	83 ec 0c             	sub    $0xc,%esp
   188b9:	6a 4f                	push   $0x4f
   188bb:	e8 69 88 ff ff       	call   11129 <Set_Current_Attr>
   188c0:	83 c4 0c             	add    $0xc,%esp
   188c3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   188c9:	ff 30                	pushl  (%eax)
   188cb:	ff 74 24 14          	pushl  0x14(%esp)
   188cf:	68 bc 00 00 00       	push   $0xbc
   188d4:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   188da:	50                   	push   %eax
   188db:	8d 83 f7 87 ff ff    	lea    -0x7809(%ebx),%eax
   188e1:	50                   	push   %eax
   188e2:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   188e8:	50                   	push   %eax
   188e9:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   188ef:	50                   	push   %eax
   188f0:	e8 e5 86 ff ff       	call   10fda <Print>
   188f5:	83 c4 20             	add    $0x20,%esp
   188f8:	eb fe                	jmp    188f8 <Post_Request_And_Wait+0xb3>
    KASSERT(dev != 0);
   188fa:	83 ec 0c             	sub    $0xc,%esp
   188fd:	6a 4f                	push   $0x4f
   188ff:	e8 25 88 ff ff       	call   11129 <Set_Current_Attr>
   18904:	83 c4 0c             	add    $0xc,%esp
   18907:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1890d:	ff 30                	pushl  (%eax)
   1890f:	ff 74 24 14          	pushl  0x14(%esp)
   18913:	68 bf 00 00 00       	push   $0xbf
   18918:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   1891e:	50                   	push   %eax
   1891f:	8d 83 04 88 ff ff    	lea    -0x77fc(%ebx),%eax
   18925:	50                   	push   %eax
   18926:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   1892c:	50                   	push   %eax
   1892d:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18933:	50                   	push   %eax
   18934:	e8 a1 86 ff ff       	call   10fda <Print>
   18939:	83 c4 20             	add    $0x20,%esp
   1893c:	eb fe                	jmp    1893c <Post_Request_And_Wait+0xf7>
    __asm__ __volatile__ ("cli");
   1893e:	fa                   	cli    
    Add_To_Back_Of_Block_Request_List(dev->requestQueue, request);
   1893f:	8b 47 24             	mov    0x24(%edi),%eax
    struct Thread_Queue waitQueue;

    DEFINE_LINK(Block_Request_List, Block_Request);
};

IMPLEMENT_LIST(Block_Request_List, Block_Request);
   18942:	8b 10                	mov    (%eax),%edx
   18944:	85 d2                	test   %edx,%edx
   18946:	0f 84 23 01 00 00    	je     18a6f <Post_Request_And_Wait+0x22a>
   1894c:	39 d6                	cmp    %edx,%esi
   1894e:	74 0f                	je     1895f <Post_Request_And_Wait+0x11a>
   18950:	8b 52 24             	mov    0x24(%edx),%edx
   18953:	85 d2                	test   %edx,%edx
   18955:	0f 84 14 01 00 00    	je     18a6f <Post_Request_And_Wait+0x22a>
   1895b:	39 d6                	cmp    %edx,%esi
   1895d:	75 f1                	jne    18950 <Post_Request_And_Wait+0x10b>
   1895f:	83 ec 0c             	sub    $0xc,%esp
   18962:	6a 4f                	push   $0x4f
   18964:	e8 c0 87 ff ff       	call   11129 <Set_Current_Attr>
   18969:	83 c4 0c             	add    $0xc,%esp
   1896c:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18972:	ff 30                	pushl  (%eax)
   18974:	ff 74 24 14          	pushl  0x14(%esp)
   18978:	6a 39                	push   $0x39
   1897a:	8d 83 0d 88 ff ff    	lea    -0x77f3(%ebx),%eax
   18980:	50                   	push   %eax
   18981:	8d 83 70 88 ff ff    	lea    -0x7790(%ebx),%eax
   18987:	50                   	push   %eax
   18988:	8d 83 00 89 ff ff    	lea    -0x7700(%ebx),%eax
   1898e:	50                   	push   %eax
   1898f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18995:	50                   	push   %eax
   18996:	e8 3f 86 ff ff       	call   10fda <Print>
   1899b:	83 c4 20             	add    $0x20,%esp
   1899e:	eb fe                	jmp    1899e <Post_Request_And_Wait+0x159>
   189a0:	89 70 04             	mov    %esi,0x4(%eax)
   189a3:	89 30                	mov    %esi,(%eax)
   189a5:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
   189ac:	e9 dc 00 00 00       	jmp    18a8d <Post_Request_And_Wait+0x248>
    __asm__ __volatile__ ("sti");
   189b1:	fb                   	sti    
    Wake_Up(dev->waitQueue);
    Enable_Interrupts();

    /* Wait for request to be processed */
    Disable_Interrupts();
   189b2:	e8 95 78 ff ff       	call   1024c <Interrupts_Enabled>
   189b7:	84 c0                	test   %al,%al
   189b9:	74 2c                	je     189e7 <Post_Request_And_Wait+0x1a2>
    __asm__ __volatile__ ("cli");
   189bb:	fa                   	cli    
    while (request->state == PENDING) {
   189bc:	8b 46 10             	mov    0x10(%esi),%eax
   189bf:	85 c0                	test   %eax,%eax
   189c1:	75 16                	jne    189d9 <Post_Request_And_Wait+0x194>
	Debug("Waiting, state=%d\n", request->state);
	Wait(&request->waitQueue);
   189c3:	8d 7e 18             	lea    0x18(%esi),%edi
   189c6:	83 ec 0c             	sub    $0xc,%esp
   189c9:	57                   	push   %edi
   189ca:	e8 88 ca ff ff       	call   15457 <Wait>
    while (request->state == PENDING) {
   189cf:	8b 46 10             	mov    0x10(%esi),%eax
   189d2:	83 c4 10             	add    $0x10,%esp
   189d5:	85 c0                	test   %eax,%eax
   189d7:	74 ed                	je     189c6 <Post_Request_And_Wait+0x181>
    }
    Debug("Wait completed!\n");
    Enable_Interrupts();
   189d9:	e8 6e 78 ff ff       	call   1024c <Interrupts_Enabled>
   189de:	84 c0                	test   %al,%al
   189e0:	75 49                	jne    18a2b <Post_Request_And_Wait+0x1e6>
    __asm__ __volatile__ ("sti");
   189e2:	fb                   	sti    
}
   189e3:	5b                   	pop    %ebx
   189e4:	5e                   	pop    %esi
   189e5:	5f                   	pop    %edi
   189e6:	c3                   	ret    
    Disable_Interrupts();
   189e7:	83 ec 0c             	sub    $0xc,%esp
   189ea:	6a 4f                	push   $0x4f
   189ec:	e8 38 87 ff ff       	call   11129 <Set_Current_Attr>
   189f1:	83 c4 0c             	add    $0xc,%esp
   189f4:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   189fa:	ff 30                	pushl  (%eax)
   189fc:	ff 74 24 14          	pushl  0x14(%esp)
   18a00:	68 c9 00 00 00       	push   $0xc9
   18a05:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18a0b:	50                   	push   %eax
   18a0c:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   18a12:	50                   	push   %eax
   18a13:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   18a19:	50                   	push   %eax
   18a1a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18a20:	50                   	push   %eax
   18a21:	e8 b4 85 ff ff       	call   10fda <Print>
   18a26:	83 c4 20             	add    $0x20,%esp
   18a29:	eb fe                	jmp    18a29 <Post_Request_And_Wait+0x1e4>
    Enable_Interrupts();
   18a2b:	83 ec 0c             	sub    $0xc,%esp
   18a2e:	6a 4f                	push   $0x4f
   18a30:	e8 f4 86 ff ff       	call   11129 <Set_Current_Attr>
   18a35:	83 c4 0c             	add    $0xc,%esp
   18a38:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18a3e:	ff 30                	pushl  (%eax)
   18a40:	ff 74 24 14          	pushl  0x14(%esp)
   18a44:	68 cf 00 00 00       	push   $0xcf
   18a49:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18a4f:	50                   	push   %eax
   18a50:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   18a56:	50                   	push   %eax
   18a57:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   18a5d:	50                   	push   %eax
   18a5e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18a64:	50                   	push   %eax
   18a65:	e8 70 85 ff ff       	call   10fda <Print>
   18a6a:	83 c4 20             	add    $0x20,%esp
   18a6d:	eb fe                	jmp    18a6d <Post_Request_And_Wait+0x228>
   18a6f:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
   18a76:	8b 50 04             	mov    0x4(%eax),%edx
   18a79:	85 d2                	test   %edx,%edx
   18a7b:	0f 84 1f ff ff ff    	je     189a0 <Post_Request_And_Wait+0x15b>
   18a81:	89 72 24             	mov    %esi,0x24(%edx)
   18a84:	8b 50 04             	mov    0x4(%eax),%edx
   18a87:	89 56 20             	mov    %edx,0x20(%esi)
   18a8a:	89 70 04             	mov    %esi,0x4(%eax)
    Wake_Up(dev->waitQueue);
   18a8d:	83 ec 0c             	sub    $0xc,%esp
   18a90:	ff 77 20             	pushl  0x20(%edi)
   18a93:	e8 3a cd ff ff       	call   157d2 <Wake_Up>
    Enable_Interrupts();
   18a98:	e8 af 77 ff ff       	call   1024c <Interrupts_Enabled>
   18a9d:	83 c4 10             	add    $0x10,%esp
   18aa0:	84 c0                	test   %al,%al
   18aa2:	0f 84 09 ff ff ff    	je     189b1 <Post_Request_And_Wait+0x16c>
   18aa8:	83 ec 0c             	sub    $0xc,%esp
   18aab:	6a 4f                	push   $0x4f
   18aad:	e8 77 86 ff ff       	call   11129 <Set_Current_Attr>
   18ab2:	83 c4 0c             	add    $0xc,%esp
   18ab5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18abb:	ff 30                	pushl  (%eax)
   18abd:	ff 74 24 14          	pushl  0x14(%esp)
   18ac1:	68 c6 00 00 00       	push   $0xc6
   18ac6:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18acc:	50                   	push   %eax
   18acd:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   18ad3:	50                   	push   %eax
   18ad4:	8d 83 24 89 ff ff    	lea    -0x76dc(%ebx),%eax
   18ada:	50                   	push   %eax
   18adb:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18ae1:	50                   	push   %eax
   18ae2:	e8 f3 84 ff ff       	call   10fda <Print>
   18ae7:	83 c4 20             	add    $0x20,%esp
   18aea:	eb fe                	jmp    18aea <Post_Request_And_Wait+0x2a5>

00018aec <Dequeue_Request>:
/*
 * Wait for a block request to arrive.
 */
struct Block_Request *Dequeue_Request(struct Block_Request_List *requestQueue,
    struct Thread_Queue *waitQueue)
{
   18aec:	57                   	push   %edi
   18aed:	56                   	push   %esi
   18aee:	53                   	push   %ebx
   18aef:	e8 1e 77 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18af4:	81 c3 0c d5 00 00    	add    $0xd50c,%ebx
   18afa:	8b 7c 24 10          	mov    0x10(%esp),%edi
    struct Block_Request *request;

    Disable_Interrupts();
   18afe:	e8 49 77 ff ff       	call   1024c <Interrupts_Enabled>
   18b03:	84 c0                	test   %al,%al
   18b05:	74 3c                	je     18b43 <Dequeue_Request+0x57>
    __asm__ __volatile__ ("cli");
   18b07:	fa                   	cli    
   18b08:	8b 37                	mov    (%edi),%esi
    while (Is_Block_Request_List_Empty(requestQueue))
   18b0a:	85 f6                	test   %esi,%esi
   18b0c:	75 15                	jne    18b23 <Dequeue_Request+0x37>
	Wait(waitQueue);
   18b0e:	83 ec 0c             	sub    $0xc,%esp
   18b11:	ff 74 24 20          	pushl  0x20(%esp)
   18b15:	e8 3d c9 ff ff       	call   15457 <Wait>
   18b1a:	8b 37                	mov    (%edi),%esi
    while (Is_Block_Request_List_Empty(requestQueue))
   18b1c:	83 c4 10             	add    $0x10,%esp
   18b1f:	85 f6                	test   %esi,%esi
   18b21:	74 eb                	je     18b0e <Dequeue_Request+0x22>
   18b23:	8b 46 24             	mov    0x24(%esi),%eax
   18b26:	89 07                	mov    %eax,(%edi)
   18b28:	85 c0                	test   %eax,%eax
   18b2a:	74 5b                	je     18b87 <Dequeue_Request+0x9b>
   18b2c:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
    request = Get_Front_Of_Block_Request_List(requestQueue);
    Remove_From_Front_Of_Block_Request_List(requestQueue);
    Enable_Interrupts();
   18b33:	e8 14 77 ff ff       	call   1024c <Interrupts_Enabled>
   18b38:	84 c0                	test   %al,%al
   18b3a:	75 54                	jne    18b90 <Dequeue_Request+0xa4>
    __asm__ __volatile__ ("sti");
   18b3c:	fb                   	sti    

    return request;
}
   18b3d:	89 f0                	mov    %esi,%eax
   18b3f:	5b                   	pop    %ebx
   18b40:	5e                   	pop    %esi
   18b41:	5f                   	pop    %edi
   18b42:	c3                   	ret    
    Disable_Interrupts();
   18b43:	83 ec 0c             	sub    $0xc,%esp
   18b46:	6a 4f                	push   $0x4f
   18b48:	e8 dc 85 ff ff       	call   11129 <Set_Current_Attr>
   18b4d:	83 c4 0c             	add    $0xc,%esp
   18b50:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18b56:	ff 30                	pushl  (%eax)
   18b58:	ff 74 24 14          	pushl  0x14(%esp)
   18b5c:	68 da 00 00 00       	push   $0xda
   18b61:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18b67:	50                   	push   %eax
   18b68:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   18b6e:	50                   	push   %eax
   18b6f:	8d 83 dc 88 ff ff    	lea    -0x7724(%ebx),%eax
   18b75:	50                   	push   %eax
   18b76:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18b7c:	50                   	push   %eax
   18b7d:	e8 58 84 ff ff       	call   10fda <Print>
   18b82:	83 c4 20             	add    $0x20,%esp
   18b85:	eb fe                	jmp    18b85 <Dequeue_Request+0x99>
   18b87:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
   18b8e:	eb a3                	jmp    18b33 <Dequeue_Request+0x47>
    Enable_Interrupts();
   18b90:	83 ec 0c             	sub    $0xc,%esp
   18b93:	6a 4f                	push   $0x4f
   18b95:	e8 8f 85 ff ff       	call   11129 <Set_Current_Attr>
   18b9a:	83 c4 0c             	add    $0xc,%esp
   18b9d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18ba3:	ff 30                	pushl  (%eax)
   18ba5:	ff 74 24 14          	pushl  0x14(%esp)
   18ba9:	68 df 00 00 00       	push   $0xdf
   18bae:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18bb4:	50                   	push   %eax
   18bb5:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   18bbb:	50                   	push   %eax
   18bbc:	8d 83 dc 88 ff ff    	lea    -0x7724(%ebx),%eax
   18bc2:	50                   	push   %eax
   18bc3:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18bc9:	50                   	push   %eax
   18bca:	e8 0b 84 ff ff       	call   10fda <Print>
   18bcf:	83 c4 20             	add    $0x20,%esp
   18bd2:	eb fe                	jmp    18bd2 <Dequeue_Request+0xe6>

00018bd4 <Notify_Request_Completion>:

/*
 * Signal the completion of a block request.
 */
void Notify_Request_Completion(struct Block_Request *request, enum Request_State state, int errorCode)
{
   18bd4:	56                   	push   %esi
   18bd5:	53                   	push   %ebx
   18bd6:	83 ec 04             	sub    $0x4,%esp
   18bd9:	e8 34 76 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18bde:	81 c3 22 d4 00 00    	add    $0xd422,%ebx
   18be4:	8b 74 24 10          	mov    0x10(%esp),%esi
    Disable_Interrupts();
   18be8:	e8 5f 76 ff ff       	call   1024c <Interrupts_Enabled>
   18bed:	84 c0                	test   %al,%al
   18bef:	75 44                	jne    18c35 <Notify_Request_Completion+0x61>
   18bf1:	83 ec 0c             	sub    $0xc,%esp
   18bf4:	6a 4f                	push   $0x4f
   18bf6:	e8 2e 85 ff ff       	call   11129 <Set_Current_Attr>
   18bfb:	83 c4 0c             	add    $0xc,%esp
   18bfe:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18c04:	ff 30                	pushl  (%eax)
   18c06:	ff 74 24 14          	pushl  0x14(%esp)
   18c0a:	68 e9 00 00 00       	push   $0xe9
   18c0f:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18c15:	50                   	push   %eax
   18c16:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   18c1c:	50                   	push   %eax
   18c1d:	8d 83 c0 88 ff ff    	lea    -0x7740(%ebx),%eax
   18c23:	50                   	push   %eax
   18c24:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18c2a:	50                   	push   %eax
   18c2b:	e8 aa 83 ff ff       	call   10fda <Print>
   18c30:	83 c4 20             	add    $0x20,%esp
   18c33:	eb fe                	jmp    18c33 <Notify_Request_Completion+0x5f>
    __asm__ __volatile__ ("cli");
   18c35:	fa                   	cli    
    request->state = state;
   18c36:	8b 44 24 14          	mov    0x14(%esp),%eax
   18c3a:	89 46 10             	mov    %eax,0x10(%esi)
    request->errorCode = errorCode;
   18c3d:	8b 44 24 18          	mov    0x18(%esp),%eax
   18c41:	89 46 14             	mov    %eax,0x14(%esi)
    Wake_Up(&request->waitQueue);
   18c44:	83 ec 0c             	sub    $0xc,%esp
   18c47:	83 c6 18             	add    $0x18,%esi
   18c4a:	56                   	push   %esi
   18c4b:	e8 82 cb ff ff       	call   157d2 <Wake_Up>
    Enable_Interrupts();
   18c50:	e8 f7 75 ff ff       	call   1024c <Interrupts_Enabled>
   18c55:	83 c4 10             	add    $0x10,%esp
   18c58:	84 c0                	test   %al,%al
   18c5a:	75 07                	jne    18c63 <Notify_Request_Completion+0x8f>
    __asm__ __volatile__ ("sti");
   18c5c:	fb                   	sti    
}
   18c5d:	83 c4 04             	add    $0x4,%esp
   18c60:	5b                   	pop    %ebx
   18c61:	5e                   	pop    %esi
   18c62:	c3                   	ret    
    Enable_Interrupts();
   18c63:	83 ec 0c             	sub    $0xc,%esp
   18c66:	6a 4f                	push   $0x4f
   18c68:	e8 bc 84 ff ff       	call   11129 <Set_Current_Attr>
   18c6d:	83 c4 0c             	add    $0xc,%esp
   18c70:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18c76:	ff 30                	pushl  (%eax)
   18c78:	ff 74 24 14          	pushl  0x14(%esp)
   18c7c:	68 ed 00 00 00       	push   $0xed
   18c81:	8d 83 b4 87 ff ff    	lea    -0x784c(%ebx),%eax
   18c87:	50                   	push   %eax
   18c88:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   18c8e:	50                   	push   %eax
   18c8f:	8d 83 c0 88 ff ff    	lea    -0x7740(%ebx),%eax
   18c95:	50                   	push   %eax
   18c96:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18c9c:	50                   	push   %eax
   18c9d:	e8 38 83 ff ff       	call   10fda <Print>
   18ca2:	83 c4 20             	add    $0x20,%esp
   18ca5:	eb fe                	jmp    18ca5 <Notify_Request_Completion+0xd1>

00018ca7 <Block_Read>:
/*
 * Read a block from given device.
 * Return 0 if successful, error code on error.
 */
int Block_Read(struct Block_Device *dev, int blockNum, void *buf)
{
   18ca7:	57                   	push   %edi
   18ca8:	56                   	push   %esi
   18ca9:	53                   	push   %ebx
   18caa:	e8 24 78 ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   18caf:	81 c6 51 d3 00 00    	add    $0xd351,%esi
   18cb5:	8b 7c 24 10          	mov    0x10(%esp),%edi
    Print("Block Read: %p\n", dev);
   18cb9:	83 ec 08             	sub    $0x8,%esp
   18cbc:	57                   	push   %edi
   18cbd:	8d 86 2a 88 ff ff    	lea    -0x77d6(%esi),%eax
   18cc3:	50                   	push   %eax
   18cc4:	89 f3                	mov    %esi,%ebx
   18cc6:	e8 0f 83 ff ff       	call   10fda <Print>
    request = Create_Request(dev, type, blockNum, buf);
   18ccb:	ff 74 24 28          	pushl  0x28(%esp)
   18ccf:	ff 74 24 28          	pushl  0x28(%esp)
   18cd3:	6a 00                	push   $0x0
   18cd5:	57                   	push   %edi
   18cd6:	e8 18 fb ff ff       	call   187f3 <Create_Request>
    if (request == 0)
   18cdb:	83 c4 20             	add    $0x20,%esp
   18cde:	85 c0                	test   %eax,%eax
   18ce0:	74 21                	je     18d03 <Block_Read+0x5c>
   18ce2:	89 c3                	mov    %eax,%ebx
    Post_Request_And_Wait(request);
   18ce4:	83 ec 0c             	sub    $0xc,%esp
   18ce7:	50                   	push   %eax
   18ce8:	e8 58 fb ff ff       	call   18845 <Post_Request_And_Wait>
    rc = request->errorCode;
   18ced:	8b 7b 14             	mov    0x14(%ebx),%edi
    Free(request);
   18cf0:	89 1c 24             	mov    %ebx,(%esp)
   18cf3:	89 f3                	mov    %esi,%ebx
   18cf5:	e8 30 b0 ff ff       	call   13d2a <Free>
    return rc;
   18cfa:	83 c4 10             	add    $0x10,%esp
    return Do_Request(dev, BLOCK_READ, blockNum, buf);
}
   18cfd:	89 f8                	mov    %edi,%eax
   18cff:	5b                   	pop    %ebx
   18d00:	5e                   	pop    %esi
   18d01:	5f                   	pop    %edi
   18d02:	c3                   	ret    
	return ENOMEM;
   18d03:	bf f9 ff ff ff       	mov    $0xfffffff9,%edi
    return Do_Request(dev, BLOCK_READ, blockNum, buf);
   18d08:	eb f3                	jmp    18cfd <Block_Read+0x56>

00018d0a <Block_Write>:
/*
 * Write a block to given device.
 * Return 0 if successful, error code on error.
 */
int Block_Write(struct Block_Device *dev, int blockNum, void *buf)
{
   18d0a:	57                   	push   %edi
   18d0b:	56                   	push   %esi
   18d0c:	53                   	push   %ebx
   18d0d:	e8 7c 9e ff ff       	call   12b8e <__x86.get_pc_thunk.di>
   18d12:	81 c7 ee d2 00 00    	add    $0xd2ee,%edi
    request = Create_Request(dev, type, blockNum, buf);
   18d18:	ff 74 24 18          	pushl  0x18(%esp)
   18d1c:	ff 74 24 18          	pushl  0x18(%esp)
   18d20:	6a 01                	push   $0x1
   18d22:	ff 74 24 1c          	pushl  0x1c(%esp)
   18d26:	e8 c8 fa ff ff       	call   187f3 <Create_Request>
    if (request == 0)
   18d2b:	83 c4 10             	add    $0x10,%esp
   18d2e:	85 c0                	test   %eax,%eax
   18d30:	74 21                	je     18d53 <Block_Write+0x49>
   18d32:	89 c3                	mov    %eax,%ebx
    Post_Request_And_Wait(request);
   18d34:	83 ec 0c             	sub    $0xc,%esp
   18d37:	50                   	push   %eax
   18d38:	e8 08 fb ff ff       	call   18845 <Post_Request_And_Wait>
    rc = request->errorCode;
   18d3d:	8b 73 14             	mov    0x14(%ebx),%esi
    Free(request);
   18d40:	89 1c 24             	mov    %ebx,(%esp)
   18d43:	89 fb                	mov    %edi,%ebx
   18d45:	e8 e0 af ff ff       	call   13d2a <Free>
    return rc;
   18d4a:	83 c4 10             	add    $0x10,%esp
    return Do_Request(dev, BLOCK_WRITE, blockNum, buf);
}
   18d4d:	89 f0                	mov    %esi,%eax
   18d4f:	5b                   	pop    %ebx
   18d50:	5e                   	pop    %esi
   18d51:	5f                   	pop    %edi
   18d52:	c3                   	ret    
	return ENOMEM;
   18d53:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
    return Do_Request(dev, BLOCK_WRITE, blockNum, buf);
   18d58:	eb f3                	jmp    18d4d <Block_Write+0x43>

00018d5a <Get_Num_Blocks>:

/*
 * Get number of blocks in given device.
 */
int Get_Num_Blocks(struct Block_Device *dev)
{
   18d5a:	83 ec 18             	sub    $0x18,%esp
   18d5d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    return dev->ops->Get_Num_Blocks(dev);
   18d61:	8b 50 10             	mov    0x10(%eax),%edx
   18d64:	50                   	push   %eax
   18d65:	ff 52 08             	call   *0x8(%edx)
}
   18d68:	83 c4 1c             	add    $0x1c,%esp
   18d6b:	c3                   	ret    

00018d6c <IDE_getNumBlocks>:
/*
 * return the number of logical blocks for a particular drive.
 *
 */
static int IDE_getNumBlocks(int driveNum)
{
   18d6c:	e8 76 92 ff ff       	call   11fe7 <__x86.get_pc_thunk.cx>
   18d71:	81 c1 8f d2 00 00    	add    $0xd28f,%ecx
    if (driveNum < 0 || driveNum > IDE_MAX_DRIVES) {
   18d77:	83 f8 02             	cmp    $0x2,%eax
   18d7a:	77 20                	ja     18d9c <IDE_getNumBlocks+0x30>
{
   18d7c:	53                   	push   %ebx
        return IDE_ERROR_BAD_DRIVE;
    }

    return (drives[driveNum].num_Heads * 
   18d7d:	8d 9c c1 40 13 00 00 	lea    0x1340(%ecx,%eax,8),%ebx
   18d84:	0f bf 53 02          	movswl 0x2(%ebx),%edx
            drives[driveNum].num_SectorsPerTrack *
   18d88:	0f bf 5b 04          	movswl 0x4(%ebx),%ebx
    return (drives[driveNum].num_Heads * 
   18d8c:	0f af d3             	imul   %ebx,%edx
	    drives[driveNum].num_Cylinders);
   18d8f:	0f bf 84 c1 40 13 00 	movswl 0x1340(%ecx,%eax,8),%eax
   18d96:	00 
            drives[driveNum].num_SectorsPerTrack *
   18d97:	0f af c2             	imul   %edx,%eax
}
   18d9a:	5b                   	pop    %ebx
   18d9b:	c3                   	ret    
        return IDE_ERROR_BAD_DRIVE;
   18d9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   18da1:	c3                   	ret    

00018da2 <IDE_Get_Num_Blocks>:
    return 0;
}

static int IDE_Get_Num_Blocks(struct Block_Device *dev)
{
    return IDE_getNumBlocks(dev->unit);
   18da2:	8b 44 24 04          	mov    0x4(%esp),%eax
   18da6:	8b 40 14             	mov    0x14(%eax),%eax
   18da9:	e8 be ff ff ff       	call   18d6c <IDE_getNumBlocks>
}
   18dae:	c3                   	ret    

00018daf <IDE_Close>:
{
   18daf:	53                   	push   %ebx
   18db0:	83 ec 08             	sub    $0x8,%esp
   18db3:	e8 5a 74 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18db8:	81 c3 48 d2 00 00    	add    $0xd248,%ebx
    KASSERT(dev->inUse);
   18dbe:	8b 44 24 10          	mov    0x10(%esp),%eax
   18dc2:	80 78 18 00          	cmpb   $0x0,0x18(%eax)
   18dc6:	74 0a                	je     18dd2 <IDE_Close+0x23>
}
   18dc8:	b8 00 00 00 00       	mov    $0x0,%eax
   18dcd:	83 c4 08             	add    $0x8,%esp
   18dd0:	5b                   	pop    %ebx
   18dd1:	c3                   	ret    
    KASSERT(dev->inUse);
   18dd2:	83 ec 0c             	sub    $0xc,%esp
   18dd5:	6a 4f                	push   $0x4f
   18dd7:	e8 4d 83 ff ff       	call   11129 <Set_Current_Attr>
   18ddc:	83 c4 0c             	add    $0xc,%esp
   18ddf:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18de5:	ff 30                	pushl  (%eax)
   18de7:	ff 74 24 14          	pushl  0x14(%esp)
   18deb:	68 19 01 00 00       	push   $0x119
   18df0:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   18df6:	50                   	push   %eax
   18df7:	8d 83 94 84 ff ff    	lea    -0x7b6c(%ebx),%eax
   18dfd:	50                   	push   %eax
   18dfe:	8d 83 74 8b ff ff    	lea    -0x748c(%ebx),%eax
   18e04:	50                   	push   %eax
   18e05:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18e0b:	50                   	push   %eax
   18e0c:	e8 c9 81 ff ff       	call   10fda <Print>
   18e11:	83 c4 20             	add    $0x20,%esp
   18e14:	eb fe                	jmp    18e14 <IDE_Close+0x65>

00018e16 <IDE_Open>:
{
   18e16:	53                   	push   %ebx
   18e17:	83 ec 08             	sub    $0x8,%esp
   18e1a:	e8 f3 73 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18e1f:	81 c3 e1 d1 00 00    	add    $0xd1e1,%ebx
    KASSERT(!dev->inUse);
   18e25:	8b 44 24 10          	mov    0x10(%esp),%eax
   18e29:	80 78 18 00          	cmpb   $0x0,0x18(%eax)
   18e2d:	75 0a                	jne    18e39 <IDE_Open+0x23>
}
   18e2f:	b8 00 00 00 00       	mov    $0x0,%eax
   18e34:	83 c4 08             	add    $0x8,%esp
   18e37:	5b                   	pop    %ebx
   18e38:	c3                   	ret    
    KASSERT(!dev->inUse);
   18e39:	83 ec 0c             	sub    $0xc,%esp
   18e3c:	6a 4f                	push   $0x4f
   18e3e:	e8 e6 82 ff ff       	call   11129 <Set_Current_Attr>
   18e43:	83 c4 0c             	add    $0xc,%esp
   18e46:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18e4c:	ff 30                	pushl  (%eax)
   18e4e:	ff 74 24 14          	pushl  0x14(%esp)
   18e52:	68 13 01 00 00       	push   $0x113
   18e57:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   18e5d:	50                   	push   %eax
   18e5e:	8d 83 93 84 ff ff    	lea    -0x7b6d(%ebx),%eax
   18e64:	50                   	push   %eax
   18e65:	8d 83 68 8b ff ff    	lea    -0x7498(%ebx),%eax
   18e6b:	50                   	push   %eax
   18e6c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18e72:	50                   	push   %eax
   18e73:	e8 62 81 ff ff       	call   10fda <Print>
   18e78:	83 c4 20             	add    $0x20,%esp
   18e7b:	eb fe                	jmp    18e7b <IDE_Open+0x65>

00018e7d <IDE_Request_Thread>:
    IDE_Close,
    IDE_Get_Num_Blocks,
};

static void IDE_Request_Thread(ulong_t arg)
{
   18e7d:	55                   	push   %ebp
   18e7e:	57                   	push   %edi
   18e7f:	56                   	push   %esi
   18e80:	53                   	push   %ebx
   18e81:	83 ec 2c             	sub    $0x2c,%esp
   18e84:	e8 89 73 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   18e89:	81 c3 77 d1 00 00    	add    $0xd177,%ebx
    for (;;) {
	struct Block_Request *request;
	int rc;

	/* Wait for a request to arrive */
	request = Dequeue_Request(&s_ideRequestQueue, &s_ideWaitQueue);
   18e8f:	c7 c0 a8 77 02 00    	mov    $0x277a8,%eax
   18e95:	89 44 24 14          	mov    %eax,0x14(%esp)
   18e99:	c7 c0 a0 77 02 00    	mov    $0x277a0,%eax
   18e9f:	89 44 24 18          	mov    %eax,0x18(%esp)
   18ea3:	e9 c7 01 00 00       	jmp    1906f <IDE_Request_Thread+0x1f2>
        return IDE_ERROR_BAD_DRIVE;
   18ea8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (ideDebug) Print("ide: invalid drive %d\n", driveNum);
   18ead:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   18eb4:	0f 84 c8 06 00 00    	je     19582 <IDE_Request_Thread+0x705>
   18eba:	83 ec 08             	sub    $0x8,%esp
   18ebd:	57                   	push   %edi
   18ebe:	8d 83 ae 89 ff ff    	lea    -0x7652(%ebx),%eax
   18ec4:	50                   	push   %eax
   18ec5:	e8 10 81 ff ff       	call   10fda <Print>
   18eca:	83 c4 10             	add    $0x10,%esp
        return IDE_ERROR_BAD_DRIVE;
   18ecd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   18ed2:	e9 ab 06 00 00       	jmp    19582 <IDE_Request_Thread+0x705>
        return IDE_ERROR_INVALID_BLOCK;
   18ed7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (ideDebug) Print("ide: invalid block %d\n", blockNum);
   18edc:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   18ee3:	0f 84 99 06 00 00    	je     19582 <IDE_Request_Thread+0x705>
   18ee9:	83 ec 08             	sub    $0x8,%esp
   18eec:	55                   	push   %ebp
   18eed:	8d 83 c5 89 ff ff    	lea    -0x763b(%ebx),%eax
   18ef3:	50                   	push   %eax
   18ef4:	e8 e1 80 ff ff       	call   10fda <Print>
   18ef9:	83 c4 10             	add    $0x10,%esp
        return IDE_ERROR_INVALID_BLOCK;
   18efc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   18f01:	e9 7c 06 00 00       	jmp    19582 <IDE_Request_Thread+0x705>
	Disable_Interrupts();
   18f06:	e8 41 73 ff ff       	call   1024c <Interrupts_Enabled>
   18f0b:	84 c0                	test   %al,%al
   18f0d:	74 0e                	je     18f1d <IDE_Request_Thread+0xa0>
    __asm__ __volatile__ ("cli");
   18f0f:	fa                   	cli    
	reEnable = 1;
   18f10:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
   18f17:	00 
   18f18:	e9 c0 01 00 00       	jmp    190dd <IDE_Request_Thread+0x260>
	Disable_Interrupts();
   18f1d:	83 ec 0c             	sub    $0xc,%esp
   18f20:	6a 4f                	push   $0x4f
   18f22:	e8 02 82 ff ff       	call   11129 <Set_Current_Attr>
   18f27:	83 c4 0c             	add    $0xc,%esp
   18f2a:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   18f30:	ff 30                	pushl  (%eax)
   18f32:	ff 74 24 44          	pushl  0x44(%esp)
   18f36:	68 92 00 00 00       	push   $0x92
   18f3b:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   18f41:	50                   	push   %eax
   18f42:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   18f48:	50                   	push   %eax
   18f49:	8d 83 8c 8b ff ff    	lea    -0x7474(%ebx),%eax
   18f4f:	50                   	push   %eax
   18f50:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   18f56:	50                   	push   %eax
   18f57:	e8 7e 80 ff ff       	call   10fda <Print>
   18f5c:	83 c4 20             	add    $0x20,%esp
   18f5f:	eb fe                	jmp    18f5f <IDE_Request_Thread+0xe2>
	Print ("request to read block %d\n", blockNum);
   18f61:	83 ec 08             	sub    $0x8,%esp
   18f64:	55                   	push   %ebp
   18f65:	8d 83 dc 89 ff ff    	lea    -0x7624(%ebx),%eax
   18f6b:	50                   	push   %eax
   18f6c:	e8 69 80 ff ff       	call   10fda <Print>
	Print ("    head %d\n", head);
   18f71:	83 c4 08             	add    $0x8,%esp
   18f74:	ff 74 24 08          	pushl  0x8(%esp)
   18f78:	8d 83 f6 89 ff ff    	lea    -0x760a(%ebx),%eax
   18f7e:	50                   	push   %eax
   18f7f:	e8 56 80 ff ff       	call   10fda <Print>
	Print ("    cylinder %d\n", cylinder);
   18f84:	83 c4 08             	add    $0x8,%esp
   18f87:	ff 74 24 14          	pushl  0x14(%esp)
   18f8b:	8d 83 03 8a ff ff    	lea    -0x75fd(%ebx),%eax
   18f91:	50                   	push   %eax
   18f92:	e8 43 80 ff ff       	call   10fda <Print>
	Print ("    sector %d\n", sector);
   18f97:	83 c4 08             	add    $0x8,%esp
   18f9a:	ff 74 24 0c          	pushl  0xc(%esp)
   18f9e:	8d 83 14 8a ff ff    	lea    -0x75ec(%ebx),%eax
   18fa4:	50                   	push   %eax
   18fa5:	e8 30 80 ff ff       	call   10fda <Print>
   18faa:	83 c4 10             	add    $0x10,%esp
   18fad:	e9 77 01 00 00       	jmp    19129 <IDE_Request_Thread+0x2ac>
	Out_Byte(IDE_DRIVE_HEAD_REGISTER, IDE_DRIVE_0 | head);
   18fb2:	83 ec 08             	sub    $0x8,%esp
   18fb5:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
   18fba:	83 c8 a0             	or     $0xffffffa0,%eax
   18fbd:	0f b6 c0             	movzbl %al,%eax
   18fc0:	50                   	push   %eax
   18fc1:	68 f6 01 00 00       	push   $0x1f6
   18fc6:	e8 ff 78 ff ff       	call   108ca <Out_Byte>
   18fcb:	83 c4 10             	add    $0x10,%esp
    Out_Byte(IDE_COMMAND_REGISTER, IDE_COMMAND_READ_SECTORS);
   18fce:	83 ec 08             	sub    $0x8,%esp
   18fd1:	6a 21                	push   $0x21
   18fd3:	68 f7 01 00 00       	push   $0x1f7
   18fd8:	e8 ed 78 ff ff       	call   108ca <Out_Byte>
    if (ideDebug > 2) Print("About to wait for Read \n");
   18fdd:	83 c4 10             	add    $0x10,%esp
   18fe0:	83 bb 3c 13 00 00 02 	cmpl   $0x2,0x133c(%ebx)
   18fe7:	0f 8f bd 01 00 00    	jg     191aa <IDE_Request_Thread+0x32d>
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   18fed:	83 ec 0c             	sub    $0xc,%esp
   18ff0:	68 f7 01 00 00       	push   $0x1f7
   18ff5:	e8 da 78 ff ff       	call   108d4 <In_Byte>
   18ffa:	83 c4 10             	add    $0x10,%esp
   18ffd:	84 c0                	test   %al,%al
   18fff:	78 ec                	js     18fed <IDE_Request_Thread+0x170>
    if (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_ERROR) {
   19001:	83 ec 0c             	sub    $0xc,%esp
   19004:	68 f7 01 00 00       	push   $0x1f7
   19009:	e8 c6 78 ff ff       	call   108d4 <In_Byte>
   1900e:	83 c4 10             	add    $0x10,%esp
   19011:	a8 01                	test   $0x1,%al
   19013:	0f 85 a8 01 00 00    	jne    191c1 <IDE_Request_Thread+0x344>
    if (ideDebug > 2) Print("got buffer \n");
   19019:	83 bb 3c 13 00 00 02 	cmpl   $0x2,0x133c(%ebx)
   19020:	0f 8f c8 01 00 00    	jg     191ee <IDE_Request_Thread+0x371>
    for (i=0; i < 256; i++) {
   19026:	8b 6c 24 10          	mov    0x10(%esp),%ebp
   1902a:	89 ef                	mov    %ebp,%edi
   1902c:	81 c5 00 02 00 00    	add    $0x200,%ebp
        bufferW[i] = In_Word(IDE_DATA_REGISTER);
   19032:	83 ec 0c             	sub    $0xc,%esp
   19035:	68 f0 01 00 00       	push   $0x1f0
   1903a:	e8 a6 78 ff ff       	call   108e5 <In_Word>
   1903f:	66 89 07             	mov    %ax,(%edi)
    for (i=0; i < 256; i++) {
   19042:	83 c7 02             	add    $0x2,%edi
   19045:	83 c4 10             	add    $0x10,%esp
   19048:	39 fd                	cmp    %edi,%ebp
   1904a:	75 e6                	jne    19032 <IDE_Request_Thread+0x1b5>
    if (reEnable) Enable_Interrupts();
   1904c:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   19051:	0f 85 ae 01 00 00    	jne    19205 <IDE_Request_Thread+0x388>
	    rc = IDE_Read(request->dev->unit, request->blockNum, request->buf);
	else
	    rc = IDE_Write(request->dev->unit, request->blockNum, request->buf);

	/* Notify requesting thread of final status */
	Notify_Request_Completion(request, rc == 0 ? COMPLETED : ERROR, rc);
   19057:	b8 00 00 00 00       	mov    $0x0,%eax
   1905c:	ba 01 00 00 00       	mov    $0x1,%edx
   19061:	83 ec 04             	sub    $0x4,%esp
   19064:	50                   	push   %eax
   19065:	52                   	push   %edx
   19066:	56                   	push   %esi
   19067:	e8 68 fb ff ff       	call   18bd4 <Notify_Request_Completion>
    for (;;) {
   1906c:	83 c4 10             	add    $0x10,%esp
	request = Dequeue_Request(&s_ideRequestQueue, &s_ideWaitQueue);
   1906f:	83 ec 08             	sub    $0x8,%esp
   19072:	ff 74 24 1c          	pushl  0x1c(%esp)
   19076:	ff 74 24 24          	pushl  0x24(%esp)
   1907a:	e8 6d fa ff ff       	call   18aec <Dequeue_Request>
   1907f:	89 c6                	mov    %eax,%esi
	if (request->type == BLOCK_READ)
   19081:	83 c4 10             	add    $0x10,%esp
   19084:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   19088:	0f 85 ca 01 00 00    	jne    19258 <IDE_Request_Thread+0x3db>
	    rc = IDE_Read(request->dev->unit, request->blockNum, request->buf);
   1908e:	8b 40 0c             	mov    0xc(%eax),%eax
   19091:	89 44 24 10          	mov    %eax,0x10(%esp)
   19095:	8b 6e 08             	mov    0x8(%esi),%ebp
   19098:	8b 06                	mov    (%esi),%eax
   1909a:	8b 78 14             	mov    0x14(%eax),%edi
    if (driveNum < 0 || driveNum > (numDrives-1)) {
   1909d:	85 ff                	test   %edi,%edi
   1909f:	0f 88 03 fe ff ff    	js     18ea8 <IDE_Request_Thread+0x2b>
   190a5:	3b bb 50 13 00 00    	cmp    0x1350(%ebx),%edi
   190ab:	0f 8d f7 fd ff ff    	jge    18ea8 <IDE_Request_Thread+0x2b>
    if (blockNum < 0 || blockNum >= IDE_getNumBlocks(driveNum)) {
   190b1:	85 ed                	test   %ebp,%ebp
   190b3:	0f 88 1e fe ff ff    	js     18ed7 <IDE_Request_Thread+0x5a>
   190b9:	89 f8                	mov    %edi,%eax
   190bb:	e8 ac fc ff ff       	call   18d6c <IDE_getNumBlocks>
   190c0:	39 c5                	cmp    %eax,%ebp
   190c2:	0f 8d 0f fe ff ff    	jge    18ed7 <IDE_Request_Thread+0x5a>
    if (Interrupts_Enabled()) {
   190c8:	e8 7f 71 ff ff       	call   1024c <Interrupts_Enabled>
    int reEnable = 0;
   190cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
   190d4:	00 
    if (Interrupts_Enabled()) {
   190d5:	84 c0                	test   %al,%al
   190d7:	0f 85 29 fe ff ff    	jne    18f06 <IDE_Request_Thread+0x89>
    sector = blockNum % drives[driveNum].num_SectorsPerTrack + 1;
   190dd:	8d 84 fb 40 13 00 00 	lea    0x1340(%ebx,%edi,8),%eax
   190e4:	89 04 24             	mov    %eax,(%esp)
   190e7:	0f bf 48 04          	movswl 0x4(%eax),%ecx
   190eb:	89 e8                	mov    %ebp,%eax
   190ed:	99                   	cltd   
   190ee:	f7 f9                	idiv   %ecx
   190f0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   190f4:	83 c2 01             	add    $0x1,%edx
   190f7:	89 54 24 04          	mov    %edx,0x4(%esp)
    cylinder = blockNum / (drives[driveNum].num_Heads * 
   190fb:	8b 04 24             	mov    (%esp),%eax
   190fe:	0f bf 50 02          	movswl 0x2(%eax),%edx
   19102:	89 14 24             	mov    %edx,(%esp)
   19105:	0f af ca             	imul   %edx,%ecx
   19108:	89 e8                	mov    %ebp,%eax
   1910a:	99                   	cltd   
   1910b:	f7 f9                	idiv   %ecx
   1910d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    head = (blockNum / drives[driveNum].num_SectorsPerTrack) % 
   19111:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   19115:	99                   	cltd   
   19116:	f7 3c 24             	idivl  (%esp)
   19119:	89 14 24             	mov    %edx,(%esp)
    if (ideDebug >= 2) {
   1911c:	83 bb 3c 13 00 00 01 	cmpl   $0x1,0x133c(%ebx)
   19123:	0f 8f 38 fe ff ff    	jg     18f61 <IDE_Request_Thread+0xe4>
    Out_Byte(IDE_SECTOR_COUNT_REGISTER, 1);
   19129:	83 ec 08             	sub    $0x8,%esp
   1912c:	6a 01                	push   $0x1
   1912e:	68 f2 01 00 00       	push   $0x1f2
   19133:	e8 92 77 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_SECTOR_NUMBER_REGISTER, sector);
   19138:	83 c4 08             	add    $0x8,%esp
   1913b:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   19140:	50                   	push   %eax
   19141:	68 f3 01 00 00       	push   $0x1f3
   19146:	e8 7f 77 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_CYLINDER_LOW_REGISTER, LOW_BYTE(cylinder));
   1914b:	83 c4 08             	add    $0x8,%esp
   1914e:	8b 6c 24 14          	mov    0x14(%esp),%ebp
   19152:	89 e8                	mov    %ebp,%eax
   19154:	0f b6 c0             	movzbl %al,%eax
   19157:	50                   	push   %eax
   19158:	68 f4 01 00 00       	push   $0x1f4
   1915d:	e8 68 77 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_CYLINDER_HIGH_REGISTER, HIGH_BYTE(cylinder));
   19162:	83 c4 08             	add    $0x8,%esp
   19165:	89 e8                	mov    %ebp,%eax
   19167:	0f b6 c4             	movzbl %ah,%eax
   1916a:	50                   	push   %eax
   1916b:	68 f5 01 00 00       	push   $0x1f5
   19170:	e8 55 77 ff ff       	call   108ca <Out_Byte>
    if (driveNum == 0) {
   19175:	83 c4 10             	add    $0x10,%esp
   19178:	85 ff                	test   %edi,%edi
   1917a:	0f 84 32 fe ff ff    	je     18fb2 <IDE_Request_Thread+0x135>
    } else if (driveNum == 1) {
   19180:	83 ff 01             	cmp    $0x1,%edi
   19183:	0f 85 45 fe ff ff    	jne    18fce <IDE_Request_Thread+0x151>
	Out_Byte(IDE_DRIVE_HEAD_REGISTER, IDE_DRIVE_1 | head);
   19189:	83 ec 08             	sub    $0x8,%esp
   1918c:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
   19191:	83 c8 b0             	or     $0xffffffb0,%eax
   19194:	0f b6 c0             	movzbl %al,%eax
   19197:	50                   	push   %eax
   19198:	68 f6 01 00 00       	push   $0x1f6
   1919d:	e8 28 77 ff ff       	call   108ca <Out_Byte>
   191a2:	83 c4 10             	add    $0x10,%esp
   191a5:	e9 24 fe ff ff       	jmp    18fce <IDE_Request_Thread+0x151>
    if (ideDebug > 2) Print("About to wait for Read \n");
   191aa:	83 ec 0c             	sub    $0xc,%esp
   191ad:	8d 83 23 8a ff ff    	lea    -0x75dd(%ebx),%eax
   191b3:	50                   	push   %eax
   191b4:	e8 21 7e ff ff       	call   10fda <Print>
   191b9:	83 c4 10             	add    $0x10,%esp
   191bc:	e9 2c fe ff ff       	jmp    18fed <IDE_Request_Thread+0x170>
	Print("ERROR: Got Read %d\n", In_Byte(IDE_STATUS_REGISTER));
   191c1:	83 ec 0c             	sub    $0xc,%esp
   191c4:	68 f7 01 00 00       	push   $0x1f7
   191c9:	e8 06 77 ff ff       	call   108d4 <In_Byte>
   191ce:	83 c4 08             	add    $0x8,%esp
   191d1:	0f b6 c0             	movzbl %al,%eax
   191d4:	50                   	push   %eax
   191d5:	8d 83 3c 8a ff ff    	lea    -0x75c4(%ebx),%eax
   191db:	50                   	push   %eax
   191dc:	e8 f9 7d ff ff       	call   10fda <Print>
	return IDE_ERROR_DRIVE_ERROR;
   191e1:	83 c4 10             	add    $0x10,%esp
   191e4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   191e9:	e9 94 03 00 00       	jmp    19582 <IDE_Request_Thread+0x705>
    if (ideDebug > 2) Print("got buffer \n");
   191ee:	83 ec 0c             	sub    $0xc,%esp
   191f1:	8d 83 50 8a ff ff    	lea    -0x75b0(%ebx),%eax
   191f7:	50                   	push   %eax
   191f8:	e8 dd 7d ff ff       	call   10fda <Print>
   191fd:	83 c4 10             	add    $0x10,%esp
   19200:	e9 21 fe ff ff       	jmp    19026 <IDE_Request_Thread+0x1a9>
    if (reEnable) Enable_Interrupts();
   19205:	e8 42 70 ff ff       	call   1024c <Interrupts_Enabled>
   1920a:	84 c0                	test   %al,%al
   1920c:	75 06                	jne    19214 <IDE_Request_Thread+0x397>
    __asm__ __volatile__ ("sti");
   1920e:	fb                   	sti    
}
   1920f:	e9 43 fe ff ff       	jmp    19057 <IDE_Request_Thread+0x1da>
   19214:	83 ec 0c             	sub    $0xc,%esp
   19217:	6a 4f                	push   $0x4f
   19219:	e8 0b 7f ff ff       	call   11129 <Set_Current_Attr>
   1921e:	83 c4 0c             	add    $0xc,%esp
   19221:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19227:	ff 30                	pushl  (%eax)
   19229:	ff 74 24 44          	pushl  0x44(%esp)
   1922d:	68 c1 00 00 00       	push   $0xc1
   19232:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   19238:	50                   	push   %eax
   19239:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1923f:	50                   	push   %eax
   19240:	8d 83 8c 8b ff ff    	lea    -0x7474(%ebx),%eax
   19246:	50                   	push   %eax
   19247:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1924d:	50                   	push   %eax
   1924e:	e8 87 7d ff ff       	call   10fda <Print>
   19253:	83 c4 20             	add    $0x20,%esp
   19256:	eb fe                	jmp    19256 <IDE_Request_Thread+0x3d9>
	    rc = IDE_Write(request->dev->unit, request->blockNum, request->buf);
   19258:	8b 40 0c             	mov    0xc(%eax),%eax
   1925b:	89 44 24 10          	mov    %eax,0x10(%esp)
   1925f:	8b 4e 08             	mov    0x8(%esi),%ecx
   19262:	89 cd                	mov    %ecx,%ebp
   19264:	89 0c 24             	mov    %ecx,(%esp)
   19267:	8b 06                	mov    (%esi),%eax
   19269:	8b 78 14             	mov    0x14(%eax),%edi
    if (driveNum < 0 || driveNum > (numDrives-1)) {
   1926c:	85 ff                	test   %edi,%edi
   1926e:	0f 88 f4 02 00 00    	js     19568 <IDE_Request_Thread+0x6eb>
   19274:	3b bb 50 13 00 00    	cmp    0x1350(%ebx),%edi
   1927a:	0f 8d ef 02 00 00    	jge    1956f <IDE_Request_Thread+0x6f2>
    if (blockNum < 0 || blockNum >= IDE_getNumBlocks(driveNum)) {
   19280:	85 c9                	test   %ecx,%ecx
   19282:	0f 88 ee 02 00 00    	js     19576 <IDE_Request_Thread+0x6f9>
   19288:	89 f8                	mov    %edi,%eax
   1928a:	e8 dd fa ff ff       	call   18d6c <IDE_getNumBlocks>
   1928f:	39 c5                	cmp    %eax,%ebp
   19291:	0f 8d e6 02 00 00    	jge    1957d <IDE_Request_Thread+0x700>
    if (Interrupts_Enabled()) {
   19297:	e8 b0 6f ff ff       	call   1024c <Interrupts_Enabled>
    int reEnable = 0;
   1929c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   192a3:	00 
    if (Interrupts_Enabled()) {
   192a4:	84 c0                	test   %al,%al
   192a6:	0f 85 49 01 00 00    	jne    193f5 <IDE_Request_Thread+0x578>
    sector = blockNum % drives[driveNum].num_SectorsPerTrack + 1;
   192ac:	8d ac fb 40 13 00 00 	lea    0x1340(%ebx,%edi,8),%ebp
   192b3:	0f bf 4d 04          	movswl 0x4(%ebp),%ecx
   192b7:	8b 04 24             	mov    (%esp),%eax
   192ba:	99                   	cltd   
   192bb:	f7 f9                	idiv   %ecx
   192bd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   192c1:	83 c2 01             	add    $0x1,%edx
   192c4:	89 54 24 08          	mov    %edx,0x8(%esp)
    cylinder = blockNum / (drives[driveNum].num_Heads * 
   192c8:	0f bf 55 02          	movswl 0x2(%ebp),%edx
   192cc:	89 54 24 04          	mov    %edx,0x4(%esp)
   192d0:	0f af ca             	imul   %edx,%ecx
   192d3:	8b 04 24             	mov    (%esp),%eax
   192d6:	99                   	cltd   
   192d7:	f7 f9                	idiv   %ecx
   192d9:	89 c5                	mov    %eax,%ebp
    head = (blockNum / drives[driveNum].num_SectorsPerTrack) % 
   192db:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   192df:	99                   	cltd   
   192e0:	f7 7c 24 04          	idivl  0x4(%esp)
   192e4:	89 54 24 04          	mov    %edx,0x4(%esp)
    if (ideDebug) {
   192e8:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   192ef:	0f 85 5b 01 00 00    	jne    19450 <IDE_Request_Thread+0x5d3>
    Out_Byte(IDE_SECTOR_COUNT_REGISTER, 1);
   192f5:	83 ec 08             	sub    $0x8,%esp
   192f8:	6a 01                	push   $0x1
   192fa:	68 f2 01 00 00       	push   $0x1f2
   192ff:	e8 c6 75 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_SECTOR_NUMBER_REGISTER, sector);
   19304:	83 c4 08             	add    $0x8,%esp
   19307:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
   1930c:	50                   	push   %eax
   1930d:	68 f3 01 00 00       	push   $0x1f3
   19312:	e8 b3 75 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_CYLINDER_LOW_REGISTER, LOW_BYTE(cylinder));
   19317:	83 c4 08             	add    $0x8,%esp
   1931a:	89 e8                	mov    %ebp,%eax
   1931c:	0f b6 c0             	movzbl %al,%eax
   1931f:	50                   	push   %eax
   19320:	68 f4 01 00 00       	push   $0x1f4
   19325:	e8 a0 75 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_CYLINDER_HIGH_REGISTER, HIGH_BYTE(cylinder));
   1932a:	83 c4 08             	add    $0x8,%esp
   1932d:	89 e8                	mov    %ebp,%eax
   1932f:	0f b6 c4             	movzbl %ah,%eax
   19332:	50                   	push   %eax
   19333:	68 f5 01 00 00       	push   $0x1f5
   19338:	e8 8d 75 ff ff       	call   108ca <Out_Byte>
    if (driveNum == 0) {
   1933d:	83 c4 10             	add    $0x10,%esp
   19340:	85 ff                	test   %edi,%edi
   19342:	0f 84 59 01 00 00    	je     194a1 <IDE_Request_Thread+0x624>
    } else if (driveNum == 1) {
   19348:	83 ff 01             	cmp    $0x1,%edi
   1934b:	0f 84 71 01 00 00    	je     194c2 <IDE_Request_Thread+0x645>
    Out_Byte(IDE_COMMAND_REGISTER, IDE_COMMAND_WRITE_SECTORS);
   19351:	83 ec 08             	sub    $0x8,%esp
   19354:	6a 30                	push   $0x30
   19356:	68 f7 01 00 00       	push   $0x1f7
   1935b:	e8 6a 75 ff ff       	call   108ca <Out_Byte>
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   19360:	83 c4 10             	add    $0x10,%esp
   19363:	83 ec 0c             	sub    $0xc,%esp
   19366:	68 f7 01 00 00       	push   $0x1f7
   1936b:	e8 64 75 ff ff       	call   108d4 <In_Byte>
   19370:	83 c4 10             	add    $0x10,%esp
   19373:	84 c0                	test   %al,%al
   19375:	78 ec                	js     19363 <IDE_Request_Thread+0x4e6>
   19377:	8b 6c 24 10          	mov    0x10(%esp),%ebp
   1937b:	89 ef                	mov    %ebp,%edi
   1937d:	81 c5 00 02 00 00    	add    $0x200,%ebp
        Out_Word(IDE_DATA_REGISTER, bufferW[i]);
   19383:	83 ec 08             	sub    $0x8,%esp
   19386:	0f b7 07             	movzwl (%edi),%eax
   19389:	50                   	push   %eax
   1938a:	68 f0 01 00 00       	push   $0x1f0
   1938f:	e8 46 75 ff ff       	call   108da <Out_Word>
    for (i=0; i < 256; i++) {
   19394:	83 c7 02             	add    $0x2,%edi
   19397:	83 c4 10             	add    $0x10,%esp
   1939a:	39 ef                	cmp    %ebp,%edi
   1939c:	75 e5                	jne    19383 <IDE_Request_Thread+0x506>
    if (ideDebug) Print("About to wait for Write \n");
   1939e:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   193a5:	0f 85 38 01 00 00    	jne    194e3 <IDE_Request_Thread+0x666>
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   193ab:	83 ec 0c             	sub    $0xc,%esp
   193ae:	68 f7 01 00 00       	push   $0x1f7
   193b3:	e8 1c 75 ff ff       	call   108d4 <In_Byte>
   193b8:	83 c4 10             	add    $0x10,%esp
   193bb:	84 c0                	test   %al,%al
   193bd:	78 ec                	js     193ab <IDE_Request_Thread+0x52e>
    if (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_ERROR) {
   193bf:	83 ec 0c             	sub    $0xc,%esp
   193c2:	68 f7 01 00 00       	push   $0x1f7
   193c7:	e8 08 75 ff ff       	call   108d4 <In_Byte>
   193cc:	83 c4 10             	add    $0x10,%esp
   193cf:	a8 01                	test   $0x1,%al
   193d1:	0f 85 23 01 00 00    	jne    194fa <IDE_Request_Thread+0x67d>
    if (reEnable) Enable_Interrupts();
   193d7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   193dc:	0f 84 75 fc ff ff    	je     19057 <IDE_Request_Thread+0x1da>
   193e2:	e8 65 6e ff ff       	call   1024c <Interrupts_Enabled>
   193e7:	84 c0                	test   %al,%al
   193e9:	0f 85 35 01 00 00    	jne    19524 <IDE_Request_Thread+0x6a7>
    __asm__ __volatile__ ("sti");
   193ef:	fb                   	sti    
}
   193f0:	e9 62 fc ff ff       	jmp    19057 <IDE_Request_Thread+0x1da>
	Disable_Interrupts();
   193f5:	e8 52 6e ff ff       	call   1024c <Interrupts_Enabled>
   193fa:	84 c0                	test   %al,%al
   193fc:	74 0e                	je     1940c <IDE_Request_Thread+0x58f>
    __asm__ __volatile__ ("cli");
   193fe:	fa                   	cli    
	reEnable = 1;
   193ff:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
   19406:	00 
   19407:	e9 a0 fe ff ff       	jmp    192ac <IDE_Request_Thread+0x42f>
	Disable_Interrupts();
   1940c:	83 ec 0c             	sub    $0xc,%esp
   1940f:	6a 4f                	push   $0x4f
   19411:	e8 13 7d ff ff       	call   11129 <Set_Current_Attr>
   19416:	83 c4 0c             	add    $0xc,%esp
   19419:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1941f:	ff 30                	pushl  (%eax)
   19421:	ff 74 24 44          	pushl  0x44(%esp)
   19425:	68 db 00 00 00       	push   $0xdb
   1942a:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   19430:	50                   	push   %eax
   19431:	8d 83 77 71 ff ff    	lea    -0x8e89(%ebx),%eax
   19437:	50                   	push   %eax
   19438:	8d 83 80 8b ff ff    	lea    -0x7480(%ebx),%eax
   1943e:	50                   	push   %eax
   1943f:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19445:	50                   	push   %eax
   19446:	e8 8f 7b ff ff       	call   10fda <Print>
   1944b:	83 c4 20             	add    $0x20,%esp
   1944e:	eb fe                	jmp    1944e <IDE_Request_Thread+0x5d1>
	Print ("request to write block %d\n", blockNum);
   19450:	83 ec 08             	sub    $0x8,%esp
   19453:	ff 74 24 08          	pushl  0x8(%esp)
   19457:	8d 83 5d 8a ff ff    	lea    -0x75a3(%ebx),%eax
   1945d:	50                   	push   %eax
   1945e:	e8 77 7b ff ff       	call   10fda <Print>
	Print ("    head %d\n", head);
   19463:	83 c4 08             	add    $0x8,%esp
   19466:	ff 74 24 0c          	pushl  0xc(%esp)
   1946a:	8d 83 f6 89 ff ff    	lea    -0x760a(%ebx),%eax
   19470:	50                   	push   %eax
   19471:	e8 64 7b ff ff       	call   10fda <Print>
	Print ("    cylinder %d\n", cylinder);
   19476:	83 c4 08             	add    $0x8,%esp
   19479:	55                   	push   %ebp
   1947a:	8d 83 03 8a ff ff    	lea    -0x75fd(%ebx),%eax
   19480:	50                   	push   %eax
   19481:	e8 54 7b ff ff       	call   10fda <Print>
	Print ("    sector %d\n", sector);
   19486:	83 c4 08             	add    $0x8,%esp
   19489:	ff 74 24 10          	pushl  0x10(%esp)
   1948d:	8d 83 14 8a ff ff    	lea    -0x75ec(%ebx),%eax
   19493:	50                   	push   %eax
   19494:	e8 41 7b ff ff       	call   10fda <Print>
   19499:	83 c4 10             	add    $0x10,%esp
   1949c:	e9 54 fe ff ff       	jmp    192f5 <IDE_Request_Thread+0x478>
	Out_Byte(IDE_DRIVE_HEAD_REGISTER, IDE_DRIVE_0 | head);
   194a1:	83 ec 08             	sub    $0x8,%esp
   194a4:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   194a9:	83 c8 a0             	or     $0xffffffa0,%eax
   194ac:	0f b6 c0             	movzbl %al,%eax
   194af:	50                   	push   %eax
   194b0:	68 f6 01 00 00       	push   $0x1f6
   194b5:	e8 10 74 ff ff       	call   108ca <Out_Byte>
   194ba:	83 c4 10             	add    $0x10,%esp
   194bd:	e9 8f fe ff ff       	jmp    19351 <IDE_Request_Thread+0x4d4>
	Out_Byte(IDE_DRIVE_HEAD_REGISTER, IDE_DRIVE_1 | head);
   194c2:	83 ec 08             	sub    $0x8,%esp
   194c5:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
   194ca:	83 c8 b0             	or     $0xffffffb0,%eax
   194cd:	0f b6 c0             	movzbl %al,%eax
   194d0:	50                   	push   %eax
   194d1:	68 f6 01 00 00       	push   $0x1f6
   194d6:	e8 ef 73 ff ff       	call   108ca <Out_Byte>
   194db:	83 c4 10             	add    $0x10,%esp
   194de:	e9 6e fe ff ff       	jmp    19351 <IDE_Request_Thread+0x4d4>
    if (ideDebug) Print("About to wait for Write \n");
   194e3:	83 ec 0c             	sub    $0xc,%esp
   194e6:	8d 83 78 8a ff ff    	lea    -0x7588(%ebx),%eax
   194ec:	50                   	push   %eax
   194ed:	e8 e8 7a ff ff       	call   10fda <Print>
   194f2:	83 c4 10             	add    $0x10,%esp
   194f5:	e9 b1 fe ff ff       	jmp    193ab <IDE_Request_Thread+0x52e>
	Print("ERROR: Got Read %d\n", In_Byte(IDE_STATUS_REGISTER));
   194fa:	83 ec 0c             	sub    $0xc,%esp
   194fd:	68 f7 01 00 00       	push   $0x1f7
   19502:	e8 cd 73 ff ff       	call   108d4 <In_Byte>
   19507:	83 c4 08             	add    $0x8,%esp
   1950a:	0f b6 c0             	movzbl %al,%eax
   1950d:	50                   	push   %eax
   1950e:	8d 83 3c 8a ff ff    	lea    -0x75c4(%ebx),%eax
   19514:	50                   	push   %eax
   19515:	e8 c0 7a ff ff       	call   10fda <Print>
	return IDE_ERROR_DRIVE_ERROR;
   1951a:	83 c4 10             	add    $0x10,%esp
   1951d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   19522:	eb 5e                	jmp    19582 <IDE_Request_Thread+0x705>
    if (reEnable) Enable_Interrupts();
   19524:	83 ec 0c             	sub    $0xc,%esp
   19527:	6a 4f                	push   $0x4f
   19529:	e8 fb 7b ff ff       	call   11129 <Set_Current_Attr>
   1952e:	83 c4 0c             	add    $0xc,%esp
   19531:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19537:	ff 30                	pushl  (%eax)
   19539:	ff 74 24 44          	pushl  0x44(%esp)
   1953d:	68 0c 01 00 00       	push   $0x10c
   19542:	8d 83 9a 89 ff ff    	lea    -0x7666(%ebx),%eax
   19548:	50                   	push   %eax
   19549:	8d 83 76 71 ff ff    	lea    -0x8e8a(%ebx),%eax
   1954f:	50                   	push   %eax
   19550:	8d 83 80 8b ff ff    	lea    -0x7480(%ebx),%eax
   19556:	50                   	push   %eax
   19557:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1955d:	50                   	push   %eax
   1955e:	e8 77 7a ff ff       	call   10fda <Print>
   19563:	83 c4 20             	add    $0x20,%esp
   19566:	eb fe                	jmp    19566 <IDE_Request_Thread+0x6e9>
        return IDE_ERROR_BAD_DRIVE;
   19568:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1956d:	eb 13                	jmp    19582 <IDE_Request_Thread+0x705>
   1956f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   19574:	eb 0c                	jmp    19582 <IDE_Request_Thread+0x705>
        return IDE_ERROR_INVALID_BLOCK;
   19576:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1957b:	eb 05                	jmp    19582 <IDE_Request_Thread+0x705>
   1957d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	Notify_Request_Completion(request, rc == 0 ? COMPLETED : ERROR, rc);
   19582:	ba 02 00 00 00       	mov    $0x2,%edx
   19587:	e9 d5 fa ff ff       	jmp    19061 <IDE_Request_Thread+0x1e4>

0001958c <readDriveConfig>:
    }
}

static int readDriveConfig(int drive)
{
   1958c:	55                   	push   %ebp
   1958d:	57                   	push   %edi
   1958e:	56                   	push   %esi
   1958f:	53                   	push   %ebx
   19590:	81 ec 1c 02 00 00    	sub    $0x21c,%esp
   19596:	e8 77 6c ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1959b:	81 c3 65 ca 00 00    	add    $0xca65,%ebx
   195a1:	89 c5                	mov    %eax,%ebp
    int status;
    short info[256];
    char devname[BLOCKDEV_MAX_NAME_LEN];
    int rc;

    if (ideDebug > 1) Print("ide: about to read drive config for drive #%d\n", drive);
   195a3:	83 bb 3c 13 00 00 01 	cmpl   $0x1,0x133c(%ebx)
   195aa:	0f 8f 17 01 00 00    	jg     196c7 <readDriveConfig+0x13b>

    Out_Byte(IDE_DRIVE_HEAD_REGISTER, (drive == 0) ? IDE_DRIVE_0 : IDE_DRIVE_1);
   195b0:	83 fd 01             	cmp    $0x1,%ebp
   195b3:	19 f6                	sbb    %esi,%esi
   195b5:	83 e6 f0             	and    $0xfffffff0,%esi
   195b8:	81 c6 b0 00 00 00    	add    $0xb0,%esi
   195be:	83 ec 08             	sub    $0x8,%esp
   195c1:	56                   	push   %esi
   195c2:	68 f6 01 00 00       	push   $0x1f6
   195c7:	e8 fe 72 ff ff       	call   108ca <Out_Byte>
    Out_Byte(IDE_COMMAND_REGISTER, IDE_COMMAND_IDENTIFY_DRIVE);
   195cc:	83 c4 08             	add    $0x8,%esp
   195cf:	68 ec 00 00 00       	push   $0xec
   195d4:	68 f7 01 00 00       	push   $0x1f7
   195d9:	e8 ec 72 ff ff       	call   108ca <Out_Byte>
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   195de:	83 c4 10             	add    $0x10,%esp
   195e1:	83 ec 0c             	sub    $0xc,%esp
   195e4:	68 f7 01 00 00       	push   $0x1f7
   195e9:	e8 e6 72 ff ff       	call   108d4 <In_Byte>
   195ee:	83 c4 10             	add    $0x10,%esp
   195f1:	84 c0                	test   %al,%al
   195f3:	78 ec                	js     195e1 <readDriveConfig+0x55>

    status = In_Byte(IDE_STATUS_REGISTER);
   195f5:	83 ec 0c             	sub    $0xc,%esp
   195f8:	68 f7 01 00 00       	push   $0x1f7
   195fd:	e8 d2 72 ff ff       	call   108d4 <In_Byte>
    /*
     * simulate failure
     * status = 0x50;
     */
    if ((status & IDE_STATUS_DRIVE_DATA_REQUEST)) {
   19602:	83 c4 10             	add    $0x10,%esp
   19605:	a8 08                	test   $0x8,%al
   19607:	0f 84 d2 00 00 00    	je     196df <readDriveConfig+0x153>
   1960d:	8d 74 24 10          	lea    0x10(%esp),%esi
   19611:	8d bc 24 10 02 00 00 	lea    0x210(%esp),%edi
       /*Print("ide: probe found ATA drive\n");*/
         /* drive responded to ATA probe */
	for (i=0; i < 256; i++) {
	    info[i] = In_Word(IDE_DATA_REGISTER);
   19618:	83 ec 0c             	sub    $0xc,%esp
   1961b:	68 f0 01 00 00       	push   $0x1f0
   19620:	e8 c0 72 ff ff       	call   108e5 <In_Word>
   19625:	66 89 06             	mov    %ax,(%esi)
	for (i=0; i < 256; i++) {
   19628:	83 c6 02             	add    $0x2,%esi
   1962b:	83 c4 10             	add    $0x10,%esp
   1962e:	39 fe                	cmp    %edi,%esi
   19630:	75 e6                	jne    19618 <readDriveConfig+0x8c>
	}

	drives[drive].num_Cylinders = info[IDE_INDENTIFY_NUM_CYLINDERS];
   19632:	0f b7 44 24 12       	movzwl 0x12(%esp),%eax
   19637:	66 89 84 eb 40 13 00 	mov    %ax,0x1340(%ebx,%ebp,8)
   1963e:	00 
	drives[drive].num_Heads = info[IDE_INDENTIFY_NUM_HEADS];
   1963f:	0f b7 54 24 16       	movzwl 0x16(%esp),%edx
   19644:	8d b4 eb 40 13 00 00 	lea    0x1340(%ebx,%ebp,8),%esi
   1964b:	66 89 56 02          	mov    %dx,0x2(%esi)
	drives[drive].num_SectorsPerTrack = info[IDE_INDENTIFY_NUM_SECTORS_TRACK];
   1964f:	0f b7 4c 24 1c       	movzwl 0x1c(%esp),%ecx
   19654:	66 89 4e 04          	mov    %cx,0x4(%esi)
	drives[drive].num_BytesPerSector = info[IDE_INDENTIFY_NUM_BYTES_SECTOR];
   19658:	0f b7 7c 24 1a       	movzwl 0x1a(%esp),%edi
   1965d:	66 89 7e 06          	mov    %di,0x6(%esi)
       status = In_Byte(IDE_STATUS_REGISTER);
       /*Print("ide: found atapi drive\n");*/
       return -1;
    }

    Print("    ide%d: cyl=%d, heads=%d, sectors=%d\n", drive, drives[drive].num_Cylinders,
   19661:	83 ec 0c             	sub    $0xc,%esp
   19664:	0f bf c9             	movswl %cx,%ecx
   19667:	51                   	push   %ecx
   19668:	0f bf d2             	movswl %dx,%edx
   1966b:	52                   	push   %edx
   1966c:	98                   	cwtl   
   1966d:	50                   	push   %eax
   1966e:	55                   	push   %ebp
   1966f:	8d 83 1c 8b ff ff    	lea    -0x74e4(%ebx),%eax
   19675:	50                   	push   %eax
   19676:	e8 5f 79 ff ff       	call   10fda <Print>
	drives[drive].num_Heads, drives[drive].num_SectorsPerTrack);

    /* Register the drive as a block device */
    snprintf(devname, sizeof(devname), "ide%d", drive);
   1967b:	83 c4 20             	add    $0x20,%esp
   1967e:	55                   	push   %ebp
   1967f:	8d 83 92 8a ff ff    	lea    -0x756e(%ebx),%eax
   19685:	50                   	push   %eax
   19686:	6a 0f                	push   $0xf
   19688:	8d 74 24 0d          	lea    0xd(%esp),%esi
   1968c:	56                   	push   %esi
   1968d:	e8 0e 37 00 00       	call   1cda0 <snprintf>
    rc = Register_Block_Device(devname, &s_ideDeviceOps, drive, 0, &s_ideWaitQueue, &s_ideRequestQueue);
   19692:	83 c4 08             	add    $0x8,%esp
   19695:	ff b3 e8 ff ff ff    	pushl  -0x18(%ebx)
   1969b:	ff b3 ec ff ff ff    	pushl  -0x14(%ebx)
   196a1:	6a 00                	push   $0x0
   196a3:	55                   	push   %ebp
   196a4:	8d 83 e4 00 00 00    	lea    0xe4(%ebx),%eax
   196aa:	50                   	push   %eax
   196ab:	56                   	push   %esi
   196ac:	e8 ff ed ff ff       	call   184b0 <Register_Block_Device>
    if (rc != 0)
   196b1:	83 c4 20             	add    $0x20,%esp
   196b4:	85 c0                	test   %eax,%eax
   196b6:	0f 85 80 00 00 00    	jne    1973c <readDriveConfig+0x1b0>
	Print("  Error: could not create block device for %s\n", devname);

    return 0;
}
   196bc:	81 c4 1c 02 00 00    	add    $0x21c,%esp
   196c2:	5b                   	pop    %ebx
   196c3:	5e                   	pop    %esi
   196c4:	5f                   	pop    %edi
   196c5:	5d                   	pop    %ebp
   196c6:	c3                   	ret    
    if (ideDebug > 1) Print("ide: about to read drive config for drive #%d\n", drive);
   196c7:	83 ec 08             	sub    $0x8,%esp
   196ca:	50                   	push   %eax
   196cb:	8d 83 ec 8a ff ff    	lea    -0x7514(%ebx),%eax
   196d1:	50                   	push   %eax
   196d2:	e8 03 79 ff ff       	call   10fda <Print>
   196d7:	83 c4 10             	add    $0x10,%esp
   196da:	e9 d1 fe ff ff       	jmp    195b0 <readDriveConfig+0x24>
       Out_Byte(IDE_FEATURE_REG, 0);		 /* disable dma & overlap */
   196df:	83 ec 08             	sub    $0x8,%esp
   196e2:	6a 00                	push   $0x0
   196e4:	68 f1 01 00 00       	push   $0x1f1
   196e9:	e8 dc 71 ff ff       	call   108ca <Out_Byte>
       Out_Byte(IDE_DRIVE_HEAD_REGISTER, (drive == 0) ? IDE_DRIVE_0 : IDE_DRIVE_1);
   196ee:	83 c4 08             	add    $0x8,%esp
   196f1:	56                   	push   %esi
   196f2:	68 f6 01 00 00       	push   $0x1f6
   196f7:	e8 ce 71 ff ff       	call   108ca <Out_Byte>
       Out_Byte(IDE_COMMAND_REGISTER, IDE_COMMAND_ATAPI_IDENT_DRIVE);
   196fc:	83 c4 08             	add    $0x8,%esp
   196ff:	68 a1 00 00 00       	push   $0xa1
   19704:	68 f7 01 00 00       	push   $0x1f7
   19709:	e8 bc 71 ff ff       	call   108ca <Out_Byte>
       while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   1970e:	83 c4 10             	add    $0x10,%esp
   19711:	83 ec 0c             	sub    $0xc,%esp
   19714:	68 f7 01 00 00       	push   $0x1f7
   19719:	e8 b6 71 ff ff       	call   108d4 <In_Byte>
   1971e:	83 c4 10             	add    $0x10,%esp
   19721:	84 c0                	test   %al,%al
   19723:	78 ec                	js     19711 <readDriveConfig+0x185>
       status = In_Byte(IDE_STATUS_REGISTER);
   19725:	83 ec 0c             	sub    $0xc,%esp
   19728:	68 f7 01 00 00       	push   $0x1f7
   1972d:	e8 a2 71 ff ff       	call   108d4 <In_Byte>
       return -1;
   19732:	83 c4 10             	add    $0x10,%esp
   19735:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1973a:	eb 80                	jmp    196bc <readDriveConfig+0x130>
	Print("  Error: could not create block device for %s\n", devname);
   1973c:	83 ec 08             	sub    $0x8,%esp
   1973f:	8d 44 24 09          	lea    0x9(%esp),%eax
   19743:	50                   	push   %eax
   19744:	8d 83 4c 85 ff ff    	lea    -0x7ab4(%ebx),%eax
   1974a:	50                   	push   %eax
   1974b:	e8 8a 78 ff ff       	call   10fda <Print>
   19750:	83 c4 10             	add    $0x10,%esp
    return 0;
   19753:	b8 00 00 00 00       	mov    $0x0,%eax
   19758:	e9 5f ff ff ff       	jmp    196bc <readDriveConfig+0x130>

0001975d <Init_IDE>:


void Init_IDE(void)
{
   1975d:	53                   	push   %ebx
   1975e:	83 ec 14             	sub    $0x14,%esp
   19761:	e8 ac 6a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19766:	81 c3 9a c8 00 00    	add    $0xc89a,%ebx
    int errorCode;

    Print("Initializing IDE controller...\n");
   1976c:	8d 83 48 8b ff ff    	lea    -0x74b8(%ebx),%eax
   19772:	50                   	push   %eax
   19773:	e8 62 78 ff ff       	call   10fda <Print>

    /* Reset the controller and drives */
    Out_Byte(IDE_DEVICE_CONTROL_REGISTER, IDE_DCR_NOINTERRUPT | IDE_DCR_RESET);
   19778:	83 c4 08             	add    $0x8,%esp
   1977b:	6a 06                	push   $0x6
   1977d:	68 f6 03 00 00       	push   $0x3f6
   19782:	e8 43 71 ff ff       	call   108ca <Out_Byte>
    Micro_Delay(100);
   19787:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
   1978e:	e8 00 8b ff ff       	call   12293 <Micro_Delay>
    Out_Byte(IDE_DEVICE_CONTROL_REGISTER, IDE_DCR_NOINTERRUPT);
   19793:	83 c4 08             	add    $0x8,%esp
   19796:	6a 02                	push   $0x2
   19798:	68 f6 03 00 00       	push   $0x3f6
   1979d:	e8 28 71 ff ff       	call   108ca <Out_Byte>
 *    while ((In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_READY) == 0)
 *	;
 */

    /* This code does work on Bochs 2.0. */
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY)
   197a2:	83 c4 10             	add    $0x10,%esp
   197a5:	83 ec 0c             	sub    $0xc,%esp
   197a8:	68 f7 01 00 00       	push   $0x1f7
   197ad:	e8 22 71 ff ff       	call   108d4 <In_Byte>
   197b2:	83 c4 10             	add    $0x10,%esp
   197b5:	84 c0                	test   %al,%al
   197b7:	78 ec                	js     197a5 <Init_IDE+0x48>
	;

    if (ideDebug) Print("About to run drive Diagnosis\n");
   197b9:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   197c0:	0f 85 83 00 00 00    	jne    19849 <Init_IDE+0xec>

    Out_Byte(IDE_COMMAND_REGISTER, IDE_COMMAND_DIAGNOSTIC);
   197c6:	83 ec 08             	sub    $0x8,%esp
   197c9:	68 90 00 00 00       	push   $0x90
   197ce:	68 f7 01 00 00       	push   $0x1f7
   197d3:	e8 f2 70 ff ff       	call   108ca <Out_Byte>
    while (In_Byte(IDE_STATUS_REGISTER) & IDE_STATUS_DRIVE_BUSY);
   197d8:	83 c4 10             	add    $0x10,%esp
   197db:	83 ec 0c             	sub    $0xc,%esp
   197de:	68 f7 01 00 00       	push   $0x1f7
   197e3:	e8 ec 70 ff ff       	call   108d4 <In_Byte>
   197e8:	83 c4 10             	add    $0x10,%esp
   197eb:	84 c0                	test   %al,%al
   197ed:	78 ec                	js     197db <Init_IDE+0x7e>
    errorCode = In_Byte(IDE_ERROR_REGISTER);
   197ef:	83 ec 0c             	sub    $0xc,%esp
   197f2:	68 f1 01 00 00       	push   $0x1f1
   197f7:	e8 d8 70 ff ff       	call   108d4 <In_Byte>
    if (ideDebug > 1) Print("ide: ide error register = %x\n", errorCode);
   197fc:	83 c4 10             	add    $0x10,%esp
   197ff:	83 bb 3c 13 00 00 01 	cmpl   $0x1,0x133c(%ebx)
   19806:	7f 58                	jg     19860 <Init_IDE+0x103>

    /* Probe and register drives */
    if (readDriveConfig(0) == 0)
   19808:	b8 00 00 00 00       	mov    $0x0,%eax
   1980d:	e8 7a fd ff ff       	call   1958c <readDriveConfig>
   19812:	85 c0                	test   %eax,%eax
   19814:	75 07                	jne    1981d <Init_IDE+0xc0>
	++numDrives;
   19816:	83 83 50 13 00 00 01 	addl   $0x1,0x1350(%ebx)
    if (readDriveConfig(1) == 0)
   1981d:	b8 01 00 00 00       	mov    $0x1,%eax
   19822:	e8 65 fd ff ff       	call   1958c <readDriveConfig>
   19827:	85 c0                	test   %eax,%eax
   19829:	75 07                	jne    19832 <Init_IDE+0xd5>
	++numDrives;
   1982b:	83 83 50 13 00 00 01 	addl   $0x1,0x1350(%ebx)
    if (ideDebug) Print("Found %d IDE drives\n", numDrives);
   19832:	83 bb 3c 13 00 00 00 	cmpl   $0x0,0x133c(%ebx)
   19839:	75 3d                	jne    19878 <Init_IDE+0x11b>

    /* Start request thread */
    if (numDrives > 0)
   1983b:	83 bb 50 13 00 00 00 	cmpl   $0x0,0x1350(%ebx)
   19842:	7f 4e                	jg     19892 <Init_IDE+0x135>
	Start_Kernel_Thread(IDE_Request_Thread, 0, PRIORITY_NORMAL, true);
}
   19844:	83 c4 08             	add    $0x8,%esp
   19847:	5b                   	pop    %ebx
   19848:	c3                   	ret    
    if (ideDebug) Print("About to run drive Diagnosis\n");
   19849:	83 ec 0c             	sub    $0xc,%esp
   1984c:	8d 83 98 8a ff ff    	lea    -0x7568(%ebx),%eax
   19852:	50                   	push   %eax
   19853:	e8 82 77 ff ff       	call   10fda <Print>
   19858:	83 c4 10             	add    $0x10,%esp
   1985b:	e9 66 ff ff ff       	jmp    197c6 <Init_IDE+0x69>
    if (ideDebug > 1) Print("ide: ide error register = %x\n", errorCode);
   19860:	83 ec 08             	sub    $0x8,%esp
    errorCode = In_Byte(IDE_ERROR_REGISTER);
   19863:	0f b6 c0             	movzbl %al,%eax
    if (ideDebug > 1) Print("ide: ide error register = %x\n", errorCode);
   19866:	50                   	push   %eax
   19867:	8d 83 b6 8a ff ff    	lea    -0x754a(%ebx),%eax
   1986d:	50                   	push   %eax
   1986e:	e8 67 77 ff ff       	call   10fda <Print>
   19873:	83 c4 10             	add    $0x10,%esp
   19876:	eb 90                	jmp    19808 <Init_IDE+0xab>
    if (ideDebug) Print("Found %d IDE drives\n", numDrives);
   19878:	83 ec 08             	sub    $0x8,%esp
   1987b:	ff b3 50 13 00 00    	pushl  0x1350(%ebx)
   19881:	8d 83 d4 8a ff ff    	lea    -0x752c(%ebx),%eax
   19887:	50                   	push   %eax
   19888:	e8 4d 77 ff ff       	call   10fda <Print>
   1988d:	83 c4 10             	add    $0x10,%esp
   19890:	eb a9                	jmp    1983b <Init_IDE+0xde>
	Start_Kernel_Thread(IDE_Request_Thread, 0, PRIORITY_NORMAL, true);
   19892:	6a 01                	push   $0x1
   19894:	6a 05                	push   $0x5
   19896:	6a 00                	push   $0x0
   19898:	8d 83 7d 2e ff ff    	lea    -0xd183(%ebx),%eax
   1989e:	50                   	push   %eax
   1989f:	e8 d1 b4 ff ff       	call   14d75 <Start_Kernel_Thread>
   198a4:	83 c4 10             	add    $0x10,%esp
}
   198a7:	eb 9b                	jmp    19844 <Init_IDE+0xe7>

000198a9 <Do_Open_File>:

/*
 * Adapter for Open().
 */
static int Do_Open_File(struct Mount_Point *mountPoint, const char *path, int mode, struct File **pFile)
{
   198a9:	53                   	push   %ebx
   198aa:	83 ec 08             	sub    $0x8,%esp
   198ad:	e8 60 69 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   198b2:	81 c3 4e c7 00 00    	add    $0xc74e,%ebx
   198b8:	8b 54 24 10          	mov    0x10(%esp),%edx
    KASSERT(mountPoint->ops->Open != 0); /* All filesystems must implement Open(). */
   198bc:	8b 02                	mov    (%edx),%eax
   198be:	8b 00                	mov    (%eax),%eax
   198c0:	85 c0                	test   %eax,%eax
   198c2:	74 14                	je     198d8 <Do_Open_File+0x2f>
    return mountPoint->ops->Open(mountPoint, path, mode, pFile);
   198c4:	ff 74 24 1c          	pushl  0x1c(%esp)
   198c8:	ff 74 24 1c          	pushl  0x1c(%esp)
   198cc:	ff 74 24 1c          	pushl  0x1c(%esp)
   198d0:	52                   	push   %edx
   198d1:	ff d0                	call   *%eax
}
   198d3:	83 c4 18             	add    $0x18,%esp
   198d6:	5b                   	pop    %ebx
   198d7:	c3                   	ret    
    KASSERT(mountPoint->ops->Open != 0); /* All filesystems must implement Open(). */
   198d8:	83 ec 0c             	sub    $0xc,%esp
   198db:	6a 4f                	push   $0x4f
   198dd:	e8 47 78 ff ff       	call   11129 <Set_Current_Attr>
   198e2:	83 c4 0c             	add    $0xc,%esp
   198e5:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   198eb:	ff 30                	pushl  (%eax)
   198ed:	ff 74 24 14          	pushl  0x14(%esp)
   198f1:	68 d3 00 00 00       	push   $0xd3
   198f6:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   198fc:	50                   	push   %eax
   198fd:	8d 83 a9 8b ff ff    	lea    -0x7457(%ebx),%eax
   19903:	50                   	push   %eax
   19904:	8d 83 c8 8e ff ff    	lea    -0x7138(%ebx),%eax
   1990a:	50                   	push   %eax
   1990b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19911:	50                   	push   %eax
   19912:	e8 c3 76 ff ff       	call   10fda <Print>
   19917:	83 c4 20             	add    $0x20,%esp
   1991a:	eb fe                	jmp    1991a <Do_Open_File+0x71>

0001991c <Do_Open_Directory>:

/*
 * Adapter for Open_Directory().
 */
static int Do_Open_Directory(struct Mount_Point *mountPoint, const char *path, int mode, struct File **pDir)
{
   1991c:	53                   	push   %ebx
   1991d:	83 ec 08             	sub    $0x8,%esp
   19920:	e8 ed 68 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19925:	81 c3 db c6 00 00    	add    $0xc6db,%ebx
   1992b:	8b 54 24 10          	mov    0x10(%esp),%edx
    KASSERT(mountPoint->ops->Open_Directory != 0); /* All filesystems must implement Open_Directory(). */
   1992f:	8b 02                	mov    (%edx),%eax
   19931:	8b 40 08             	mov    0x8(%eax),%eax
   19934:	85 c0                	test   %eax,%eax
   19936:	74 13                	je     1994b <Do_Open_Directory+0x2f>
    return mountPoint->ops->Open_Directory(mountPoint, path, pDir);
   19938:	83 ec 04             	sub    $0x4,%esp
   1993b:	ff 74 24 20          	pushl  0x20(%esp)
   1993f:	ff 74 24 1c          	pushl  0x1c(%esp)
   19943:	52                   	push   %edx
   19944:	ff d0                	call   *%eax
}
   19946:	83 c4 18             	add    $0x18,%esp
   19949:	5b                   	pop    %ebx
   1994a:	c3                   	ret    
    KASSERT(mountPoint->ops->Open_Directory != 0); /* All filesystems must implement Open_Directory(). */
   1994b:	83 ec 0c             	sub    $0xc,%esp
   1994e:	6a 4f                	push   $0x4f
   19950:	e8 d4 77 ff ff       	call   11129 <Set_Current_Attr>
   19955:	83 c4 0c             	add    $0xc,%esp
   19958:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1995e:	ff 30                	pushl  (%eax)
   19960:	ff 74 24 14          	pushl  0x14(%esp)
   19964:	68 dc 00 00 00       	push   $0xdc
   19969:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1996f:	50                   	push   %eax
   19970:	8d 83 c4 8c ff ff    	lea    -0x733c(%ebx),%eax
   19976:	50                   	push   %eax
   19977:	8d 83 98 8e ff ff    	lea    -0x7168(%ebx),%eax
   1997d:	50                   	push   %eax
   1997e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19984:	50                   	push   %eax
   19985:	e8 50 76 ff ff       	call   10fda <Print>
   1998a:	83 c4 20             	add    $0x20,%esp
   1998d:	eb fe                	jmp    1998d <Do_Open_Directory+0x71>

0001998f <Lookup_Filesystem>:
{
   1998f:	57                   	push   %edi
   19990:	56                   	push   %esi
   19991:	53                   	push   %ebx
   19992:	e8 7b 68 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19997:	81 c3 69 c6 00 00    	add    $0xc669,%ebx
   1999d:	89 c7                	mov    %eax,%edi
    Mutex_Lock(&s_vfsLock);
   1999f:	83 ec 0c             	sub    $0xc,%esp
   199a2:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   199a8:	50                   	push   %eax
   199a9:	e8 31 a6 ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Filesystem_List, Filesystem);
   199ae:	8b b3 5c 13 00 00    	mov    0x135c(%ebx),%esi
    while (fs != 0) {
   199b4:	83 c4 10             	add    $0x10,%esp
   199b7:	85 f6                	test   %esi,%esi
   199b9:	74 1b                	je     199d6 <Lookup_Filesystem+0x47>
	if (strcmp(fs->fsName, fstype) == 0)
   199bb:	8d 46 04             	lea    0x4(%esi),%eax
   199be:	83 ec 08             	sub    $0x8,%esp
   199c1:	57                   	push   %edi
   199c2:	50                   	push   %eax
   199c3:	e8 51 31 00 00       	call   1cb19 <strcmp>
   199c8:	83 c4 10             	add    $0x10,%esp
   199cb:	85 c0                	test   %eax,%eax
   199cd:	74 07                	je     199d6 <Lookup_Filesystem+0x47>
IMPLEMENT_LIST(Filesystem_List, Filesystem);
   199cf:	8b 76 18             	mov    0x18(%esi),%esi
    while (fs != 0) {
   199d2:	85 f6                	test   %esi,%esi
   199d4:	75 e5                	jne    199bb <Lookup_Filesystem+0x2c>
    Mutex_Unlock(&s_vfsLock);
   199d6:	83 ec 0c             	sub    $0xc,%esp
   199d9:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   199df:	50                   	push   %eax
   199e0:	e8 2d a7 ff ff       	call   14112 <Mutex_Unlock>
    return fs;
   199e5:	83 c4 10             	add    $0x10,%esp
}
   199e8:	89 f0                	mov    %esi,%eax
   199ea:	5b                   	pop    %ebx
   199eb:	5e                   	pop    %esi
   199ec:	5f                   	pop    %edi
   199ed:	c3                   	ret    

000199ee <Lookup_Mount_Point>:
{
   199ee:	55                   	push   %ebp
   199ef:	57                   	push   %edi
   199f0:	56                   	push   %esi
   199f1:	53                   	push   %ebx
   199f2:	83 ec 18             	sub    $0x18,%esp
   199f5:	e8 18 68 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   199fa:	81 c3 06 c6 00 00    	add    $0xc606,%ebx
   19a00:	89 c7                	mov    %eax,%edi
    Mutex_Lock(&s_vfsLock);
   19a02:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   19a08:	50                   	push   %eax
   19a09:	e8 d1 a5 ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   19a0e:	8b b3 64 13 00 00    	mov    0x1364(%ebx),%esi
    while (mountPoint != 0) {
   19a14:	83 c4 10             	add    $0x10,%esp
   19a17:	85 f6                	test   %esi,%esi
   19a19:	74 3d                	je     19a58 <Lookup_Mount_Point+0x6a>
	Debug("Lookup mount point: %s,%s\n", prefix, mountPoint->pathPrefix);
   19a1b:	8d ab ec 8c ff ff    	lea    -0x7314(%ebx),%ebp
   19a21:	eb 2a                	jmp    19a4d <Lookup_Mount_Point+0x5f>
   19a23:	83 ec 04             	sub    $0x4,%esp
   19a26:	ff 76 04             	pushl  0x4(%esi)
   19a29:	57                   	push   %edi
   19a2a:	55                   	push   %ebp
   19a2b:	e8 aa 75 ff ff       	call   10fda <Print>
   19a30:	83 c4 10             	add    $0x10,%esp
	if (strcmp(prefix, mountPoint->pathPrefix) == 0)
   19a33:	83 ec 08             	sub    $0x8,%esp
   19a36:	ff 76 04             	pushl  0x4(%esi)
   19a39:	57                   	push   %edi
   19a3a:	e8 da 30 00 00       	call   1cb19 <strcmp>
   19a3f:	83 c4 10             	add    $0x10,%esp
   19a42:	85 c0                	test   %eax,%eax
   19a44:	74 12                	je     19a58 <Lookup_Mount_Point+0x6a>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   19a46:	8b 76 14             	mov    0x14(%esi),%esi
    while (mountPoint != 0) {
   19a49:	85 f6                	test   %esi,%esi
   19a4b:	74 0b                	je     19a58 <Lookup_Mount_Point+0x6a>
	Debug("Lookup mount point: %s,%s\n", prefix, mountPoint->pathPrefix);
   19a4d:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19a54:	74 dd                	je     19a33 <Lookup_Mount_Point+0x45>
   19a56:	eb cb                	jmp    19a23 <Lookup_Mount_Point+0x35>
    Mutex_Unlock(&s_vfsLock);
   19a58:	83 ec 0c             	sub    $0xc,%esp
   19a5b:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   19a61:	50                   	push   %eax
   19a62:	e8 ab a6 ff ff       	call   14112 <Mutex_Unlock>
}
   19a67:	89 f0                	mov    %esi,%eax
   19a69:	83 c4 1c             	add    $0x1c,%esp
   19a6c:	5b                   	pop    %ebx
   19a6d:	5e                   	pop    %esi
   19a6e:	5f                   	pop    %edi
   19a6f:	5d                   	pop    %ebp
   19a70:	c3                   	ret    

00019a71 <Unpack_Path>:
{
   19a71:	55                   	push   %ebp
   19a72:	57                   	push   %edi
   19a73:	56                   	push   %esi
   19a74:	53                   	push   %ebx
   19a75:	83 ec 1c             	sub    $0x1c,%esp
   19a78:	e8 95 67 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19a7d:	81 c3 83 c5 00 00    	add    $0xc583,%ebx
   19a83:	89 c6                	mov    %eax,%esi
   19a85:	89 d5                	mov    %edx,%ebp
   19a87:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    Debug("path=%s\n", path);
   19a8b:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19a92:	0f 85 b7 00 00 00    	jne    19b4f <Unpack_Path+0xde>
    if (*path != '/')
   19a98:	80 3e 2f             	cmpb   $0x2f,(%esi)
   19a9b:	0f 85 25 01 00 00    	jne    19bc6 <Unpack_Path+0x155>
    ++path;
   19aa1:	83 c6 01             	add    $0x1,%esi
    slash = strchr(path, '/');
   19aa4:	83 ec 08             	sub    $0x8,%esp
   19aa7:	6a 2f                	push   $0x2f
   19aa9:	56                   	push   %esi
   19aaa:	e8 38 32 00 00       	call   1cce7 <strchr>
   19aaf:	83 c4 10             	add    $0x10,%esp
   19ab2:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (slash == 0) {
   19ab6:	85 c0                	test   %eax,%eax
   19ab8:	0f 84 a9 00 00 00    	je     19b67 <Unpack_Path+0xf6>
	pfxLen = slash - path;
   19abe:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   19ac2:	29 f7                	sub    %esi,%edi
	if (pfxLen == 0 || pfxLen > MAX_PREFIX_LEN)
   19ac4:	8d 47 ff             	lea    -0x1(%edi),%eax
	    return false;
   19ac7:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pfxLen == 0 || pfxLen > MAX_PREFIX_LEN)
   19acc:	83 f8 0f             	cmp    $0xf,%eax
   19acf:	0f 87 f6 00 00 00    	ja     19bcb <Unpack_Path+0x15a>
	memcpy(prefix, path, pfxLen);
   19ad5:	83 ec 04             	sub    $0x4,%esp
   19ad8:	57                   	push   %edi
   19ad9:	56                   	push   %esi
   19ada:	55                   	push   %ebp
   19adb:	e8 9e 2f 00 00       	call   1ca7e <memcpy>
	prefix[pfxLen] = '\0';
   19ae0:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
	*pSuffix = slash;
   19ae5:	8b 44 24 18          	mov    0x18(%esp),%eax
   19ae9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
   19aed:	89 38                	mov    %edi,(%eax)
    Debug("prefix=%s, suffix=%s\n", prefix, *pSuffix);
   19aef:	83 c4 10             	add    $0x10,%esp
   19af2:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19af9:	0f 85 a9 00 00 00    	jne    19ba8 <Unpack_Path+0x137>
    KASSERT(**pSuffix == '/');
   19aff:	8b 44 24 08          	mov    0x8(%esp),%eax
   19b03:	8b 00                	mov    (%eax),%eax
   19b05:	80 38 2f             	cmpb   $0x2f,(%eax)
   19b08:	0f 84 c7 00 00 00    	je     19bd5 <Unpack_Path+0x164>
   19b0e:	83 ec 0c             	sub    $0xc,%esp
   19b11:	6a 4f                	push   $0x4f
   19b13:	e8 11 76 ff ff       	call   11129 <Set_Current_Attr>
   19b18:	83 c4 0c             	add    $0xc,%esp
   19b1b:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19b21:	ff 30                	pushl  (%eax)
   19b23:	ff 74 24 34          	pushl  0x34(%esp)
   19b27:	6a 7a                	push   $0x7a
   19b29:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   19b2f:	50                   	push   %eax
   19b30:	8d 83 ef 8b ff ff    	lea    -0x7411(%ebx),%eax
   19b36:	50                   	push   %eax
   19b37:	8d 83 bc 8e ff ff    	lea    -0x7144(%ebx),%eax
   19b3d:	50                   	push   %eax
   19b3e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19b44:	50                   	push   %eax
   19b45:	e8 90 74 ff ff       	call   10fda <Print>
   19b4a:	83 c4 20             	add    $0x20,%esp
   19b4d:	eb fe                	jmp    19b4d <Unpack_Path+0xdc>
    Debug("path=%s\n", path);
   19b4f:	83 ec 08             	sub    $0x8,%esp
   19b52:	50                   	push   %eax
   19b53:	8d 83 c4 8b ff ff    	lea    -0x743c(%ebx),%eax
   19b59:	50                   	push   %eax
   19b5a:	e8 7b 74 ff ff       	call   10fda <Print>
   19b5f:	83 c4 10             	add    $0x10,%esp
   19b62:	e9 31 ff ff ff       	jmp    19a98 <Unpack_Path+0x27>
	pfxLen = strlen(path);
   19b67:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   19b6c:	89 f7                	mov    %esi,%edi
   19b6e:	f2 ae                	repnz scas %es:(%edi),%al
   19b70:	89 c8                	mov    %ecx,%eax
   19b72:	f7 d0                	not    %eax
	if (pfxLen == 0 || pfxLen > MAX_PREFIX_LEN)
   19b74:	83 e8 02             	sub    $0x2,%eax
	    return false;
   19b77:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pfxLen == 0 || pfxLen > MAX_PREFIX_LEN)
   19b7c:	83 f8 0f             	cmp    $0xf,%eax
   19b7f:	77 4a                	ja     19bcb <Unpack_Path+0x15a>
	strcpy(prefix, path);
   19b81:	83 ec 08             	sub    $0x8,%esp
   19b84:	56                   	push   %esi
   19b85:	55                   	push   %ebp
   19b86:	e8 77 30 00 00       	call   1cc02 <strcpy>
	*pSuffix = "/";
   19b8b:	8d 83 d2 8b ff ff    	lea    -0x742e(%ebx),%eax
   19b91:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   19b95:	89 01                	mov    %eax,(%ecx)
    Debug("prefix=%s, suffix=%s\n", prefix, *pSuffix);
   19b97:	83 c4 10             	add    $0x10,%esp
    return true;
   19b9a:	ba 01 00 00 00       	mov    $0x1,%edx
    Debug("prefix=%s, suffix=%s\n", prefix, *pSuffix);
   19b9f:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19ba6:	74 23                	je     19bcb <Unpack_Path+0x15a>
   19ba8:	83 ec 04             	sub    $0x4,%esp
   19bab:	8b 44 24 0c          	mov    0xc(%esp),%eax
   19baf:	ff 30                	pushl  (%eax)
   19bb1:	55                   	push   %ebp
   19bb2:	8d 83 d4 8b ff ff    	lea    -0x742c(%ebx),%eax
   19bb8:	50                   	push   %eax
   19bb9:	e8 1c 74 ff ff       	call   10fda <Print>
   19bbe:	83 c4 10             	add    $0x10,%esp
   19bc1:	e9 39 ff ff ff       	jmp    19aff <Unpack_Path+0x8e>
	return false;
   19bc6:	ba 00 00 00 00       	mov    $0x0,%edx
}
   19bcb:	89 d0                	mov    %edx,%eax
   19bcd:	83 c4 1c             	add    $0x1c,%esp
   19bd0:	5b                   	pop    %ebx
   19bd1:	5e                   	pop    %esi
   19bd2:	5f                   	pop    %edi
   19bd3:	5d                   	pop    %ebp
   19bd4:	c3                   	ret    
    return true;
   19bd5:	ba 01 00 00 00       	mov    $0x1,%edx
   19bda:	eb ef                	jmp    19bcb <Unpack_Path+0x15a>

00019bdc <Do_Open>:
{
   19bdc:	57                   	push   %edi
   19bdd:	56                   	push   %esi
   19bde:	53                   	push   %ebx
   19bdf:	83 ec 20             	sub    $0x20,%esp
   19be2:	89 d7                	mov    %edx,%edi
   19be4:	89 ce                	mov    %ecx,%esi
    if (!Unpack_Path(path, prefix, &suffix))
   19be6:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   19bea:	8d 54 24 0f          	lea    0xf(%esp),%edx
   19bee:	e8 7e fe ff ff       	call   19a71 <Unpack_Path>
   19bf3:	84 c0                	test   %al,%al
   19bf5:	74 32                	je     19c29 <Do_Open+0x4d>
    mountPoint = Lookup_Mount_Point(prefix);
   19bf7:	8d 44 24 0f          	lea    0xf(%esp),%eax
   19bfb:	e8 ee fd ff ff       	call   199ee <Lookup_Mount_Point>
   19c00:	89 c3                	mov    %eax,%ebx
    if (mountPoint == 0)
   19c02:	85 c0                	test   %eax,%eax
   19c04:	74 2a                	je     19c30 <Do_Open+0x54>
    rc = openFunc(mountPoint, suffix, mode, pFile);
   19c06:	56                   	push   %esi
   19c07:	57                   	push   %edi
   19c08:	ff 74 24 10          	pushl  0x10(%esp)
   19c0c:	50                   	push   %eax
   19c0d:	ff 54 24 40          	call   *0x40(%esp)
    if (rc == 0) {
   19c11:	83 c4 10             	add    $0x10,%esp
   19c14:	85 c0                	test   %eax,%eax
   19c16:	75 0a                	jne    19c22 <Do_Open+0x46>
	(*pFile)->mode = mode;
   19c18:	8b 16                	mov    (%esi),%edx
   19c1a:	89 7a 10             	mov    %edi,0x10(%edx)
	(*pFile)->mountPoint = mountPoint;
   19c1d:	8b 16                	mov    (%esi),%edx
   19c1f:	89 5a 14             	mov    %ebx,0x14(%edx)
}
   19c22:	83 c4 20             	add    $0x20,%esp
   19c25:	5b                   	pop    %ebx
   19c26:	5e                   	pop    %esi
   19c27:	5f                   	pop    %edi
   19c28:	c3                   	ret    
	return ENOTFOUND;
   19c29:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   19c2e:	eb f2                	jmp    19c22 <Do_Open+0x46>
	return ENOTFOUND;
   19c30:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   19c35:	eb eb                	jmp    19c22 <Do_Open+0x46>

00019c37 <Register_Filesystem>:
 *   fsName - name of the filesystem type, e.g. "pfat", "gosfs"
 *   fsOps - the Filesystem_Ops for the filesystem
 * Returns true if successful, false if not.
 */
bool Register_Filesystem(const char *fsName, struct Filesystem_Ops *fsOps)
{
   19c37:	55                   	push   %ebp
   19c38:	57                   	push   %edi
   19c39:	56                   	push   %esi
   19c3a:	53                   	push   %ebx
   19c3b:	83 ec 0c             	sub    $0xc,%esp
   19c3e:	e8 cf 65 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19c43:	81 c3 bd c3 00 00    	add    $0xc3bd,%ebx
   19c49:	8b 7c 24 20          	mov    0x20(%esp),%edi
   19c4d:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    struct Filesystem *fs;

    KASSERT(fsName != 0);
   19c51:	85 ff                	test   %edi,%edi
   19c53:	0f 84 be 00 00 00    	je     19d17 <Register_Filesystem+0xe0>
    KASSERT(fsOps != 0);
   19c59:	85 ed                	test   %ebp,%ebp
   19c5b:	0f 84 fa 00 00 00    	je     19d5b <Register_Filesystem+0x124>
    KASSERT(fsOps->Mount != 0);
   19c61:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
   19c65:	0f 84 34 01 00 00    	je     19d9f <Register_Filesystem+0x168>

    Debug("Registering %s filesystem type\n", fsName);
   19c6b:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19c72:	0f 85 6b 01 00 00    	jne    19de3 <Register_Filesystem+0x1ac>

    /* Allocate Filesystem struct */
    fs = (struct Filesystem*) Malloc(sizeof(*fs));
   19c78:	83 ec 0c             	sub    $0xc,%esp
   19c7b:	6a 1c                	push   $0x1c
   19c7d:	e8 2a 9f ff ff       	call   13bac <Malloc>
   19c82:	89 c6                	mov    %eax,%esi
    if (fs == 0)
   19c84:	83 c4 10             	add    $0x10,%esp
   19c87:	85 c0                	test   %eax,%eax
   19c89:	0f 84 81 01 00 00    	je     19e10 <Register_Filesystem+0x1d9>
	return false;

    /* Copy filesystem name and vtable. */
    fs->ops = fsOps;
   19c8f:	89 28                	mov    %ebp,(%eax)
    strncpy(fs->fsName, fsName, VFS_MAX_FS_NAME_LEN);
   19c91:	83 ec 04             	sub    $0x4,%esp
   19c94:	6a 0f                	push   $0xf
   19c96:	57                   	push   %edi
   19c97:	8d 40 04             	lea    0x4(%eax),%eax
   19c9a:	50                   	push   %eax
   19c9b:	e8 8f 2f 00 00       	call   1cc2f <strncpy>
    fs->fsName[VFS_MAX_FS_NAME_LEN] = '\0';
   19ca0:	c6 46 13 00          	movb   $0x0,0x13(%esi)

    /* Add the filesystem to the list */
    Mutex_Lock(&s_vfsLock);
   19ca4:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   19caa:	89 04 24             	mov    %eax,(%esp)
   19cad:	e8 2d a3 ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Filesystem_List, Filesystem);
   19cb2:	8b 83 5c 13 00 00    	mov    0x135c(%ebx),%eax
   19cb8:	83 c4 10             	add    $0x10,%esp
   19cbb:	85 c0                	test   %eax,%eax
   19cbd:	0f 84 54 01 00 00    	je     19e17 <Register_Filesystem+0x1e0>
   19cc3:	39 c6                	cmp    %eax,%esi
   19cc5:	74 0f                	je     19cd6 <Register_Filesystem+0x9f>
   19cc7:	8b 40 18             	mov    0x18(%eax),%eax
   19cca:	85 c0                	test   %eax,%eax
   19ccc:	0f 84 45 01 00 00    	je     19e17 <Register_Filesystem+0x1e0>
   19cd2:	39 c6                	cmp    %eax,%esi
   19cd4:	75 f1                	jne    19cc7 <Register_Filesystem+0x90>
   19cd6:	83 ec 0c             	sub    $0xc,%esp
   19cd9:	6a 4f                	push   $0x4f
   19cdb:	e8 49 74 ff ff       	call   11129 <Set_Current_Attr>
   19ce0:	83 c4 0c             	add    $0xc,%esp
   19ce3:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19ce9:	ff 30                	pushl  (%eax)
   19ceb:	ff 74 24 24          	pushl  0x24(%esp)
   19cef:	6a 37                	push   $0x37
   19cf1:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   19cf7:	50                   	push   %eax
   19cf8:	8d 83 34 8d ff ff    	lea    -0x72cc(%ebx),%eax
   19cfe:	50                   	push   %eax
   19cff:	8d 83 08 8f ff ff    	lea    -0x70f8(%ebx),%eax
   19d05:	50                   	push   %eax
   19d06:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19d0c:	50                   	push   %eax
   19d0d:	e8 c8 72 ff ff       	call   10fda <Print>
   19d12:	83 c4 20             	add    $0x20,%esp
   19d15:	eb fe                	jmp    19d15 <Register_Filesystem+0xde>
    KASSERT(fsName != 0);
   19d17:	83 ec 0c             	sub    $0xc,%esp
   19d1a:	6a 4f                	push   $0x4f
   19d1c:	e8 08 74 ff ff       	call   11129 <Set_Current_Attr>
   19d21:	83 c4 0c             	add    $0xc,%esp
   19d24:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19d2a:	ff 30                	pushl  (%eax)
   19d2c:	ff 74 24 24          	pushl  0x24(%esp)
   19d30:	68 f1 00 00 00       	push   $0xf1
   19d35:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   19d3b:	50                   	push   %eax
   19d3c:	8d 83 00 8c ff ff    	lea    -0x7400(%ebx),%eax
   19d42:	50                   	push   %eax
   19d43:	8d 83 28 8f ff ff    	lea    -0x70d8(%ebx),%eax
   19d49:	50                   	push   %eax
   19d4a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19d50:	50                   	push   %eax
   19d51:	e8 84 72 ff ff       	call   10fda <Print>
   19d56:	83 c4 20             	add    $0x20,%esp
   19d59:	eb fe                	jmp    19d59 <Register_Filesystem+0x122>
    KASSERT(fsOps != 0);
   19d5b:	83 ec 0c             	sub    $0xc,%esp
   19d5e:	6a 4f                	push   $0x4f
   19d60:	e8 c4 73 ff ff       	call   11129 <Set_Current_Attr>
   19d65:	83 c4 0c             	add    $0xc,%esp
   19d68:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19d6e:	ff 30                	pushl  (%eax)
   19d70:	ff 74 24 24          	pushl  0x24(%esp)
   19d74:	68 f2 00 00 00       	push   $0xf2
   19d79:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   19d7f:	50                   	push   %eax
   19d80:	8d 83 0c 8c ff ff    	lea    -0x73f4(%ebx),%eax
   19d86:	50                   	push   %eax
   19d87:	8d 83 28 8f ff ff    	lea    -0x70d8(%ebx),%eax
   19d8d:	50                   	push   %eax
   19d8e:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19d94:	50                   	push   %eax
   19d95:	e8 40 72 ff ff       	call   10fda <Print>
   19d9a:	83 c4 20             	add    $0x20,%esp
   19d9d:	eb fe                	jmp    19d9d <Register_Filesystem+0x166>
    KASSERT(fsOps->Mount != 0);
   19d9f:	83 ec 0c             	sub    $0xc,%esp
   19da2:	6a 4f                	push   $0x4f
   19da4:	e8 80 73 ff ff       	call   11129 <Set_Current_Attr>
   19da9:	83 c4 0c             	add    $0xc,%esp
   19dac:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   19db2:	ff 30                	pushl  (%eax)
   19db4:	ff 74 24 24          	pushl  0x24(%esp)
   19db8:	68 f3 00 00 00       	push   $0xf3
   19dbd:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   19dc3:	50                   	push   %eax
   19dc4:	8d 83 17 8c ff ff    	lea    -0x73e9(%ebx),%eax
   19dca:	50                   	push   %eax
   19dcb:	8d 83 28 8f ff ff    	lea    -0x70d8(%ebx),%eax
   19dd1:	50                   	push   %eax
   19dd2:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   19dd8:	50                   	push   %eax
   19dd9:	e8 fc 71 ff ff       	call   10fda <Print>
   19dde:	83 c4 20             	add    $0x20,%esp
   19de1:	eb fe                	jmp    19de1 <Register_Filesystem+0x1aa>
    Debug("Registering %s filesystem type\n", fsName);
   19de3:	83 ec 08             	sub    $0x8,%esp
   19de6:	57                   	push   %edi
   19de7:	8d 83 0c 8d ff ff    	lea    -0x72f4(%ebx),%eax
   19ded:	50                   	push   %eax
   19dee:	e8 e7 71 ff ff       	call   10fda <Print>
   19df3:	83 c4 10             	add    $0x10,%esp
   19df6:	e9 7d fe ff ff       	jmp    19c78 <Register_Filesystem+0x41>
IMPLEMENT_LIST(Filesystem_List, Filesystem);
   19dfb:	89 b3 60 13 00 00    	mov    %esi,0x1360(%ebx)
   19e01:	89 b3 5c 13 00 00    	mov    %esi,0x135c(%ebx)
   19e07:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
   19e0e:	eb 24                	jmp    19e34 <Register_Filesystem+0x1fd>
	return false;
   19e10:	b8 00 00 00 00       	mov    $0x0,%eax
   19e15:	eb 34                	jmp    19e4b <Register_Filesystem+0x214>
IMPLEMENT_LIST(Filesystem_List, Filesystem);
   19e17:	c7 46 18 00 00 00 00 	movl   $0x0,0x18(%esi)
   19e1e:	8b 83 60 13 00 00    	mov    0x1360(%ebx),%eax
   19e24:	85 c0                	test   %eax,%eax
   19e26:	74 d3                	je     19dfb <Register_Filesystem+0x1c4>
   19e28:	89 70 18             	mov    %esi,0x18(%eax)
   19e2b:	89 46 14             	mov    %eax,0x14(%esi)
   19e2e:	89 b3 60 13 00 00    	mov    %esi,0x1360(%ebx)
    Add_To_Back_Of_Filesystem_List(&s_filesystemList, fs);
    Mutex_Unlock(&s_vfsLock);
   19e34:	83 ec 0c             	sub    $0xc,%esp
   19e37:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   19e3d:	50                   	push   %eax
   19e3e:	e8 cf a2 ff ff       	call   14112 <Mutex_Unlock>

    return true;
   19e43:	83 c4 10             	add    $0x10,%esp
   19e46:	b8 01 00 00 00       	mov    $0x1,%eax
}
   19e4b:	83 c4 0c             	add    $0xc,%esp
   19e4e:	5b                   	pop    %ebx
   19e4f:	5e                   	pop    %esi
   19e50:	5f                   	pop    %edi
   19e51:	5d                   	pop    %ebp
   19e52:	c3                   	ret    

00019e53 <Format>:
 *   devname - name of block device to format
 *   fstype - fstype, e.g. "pfat", "gosfs"
 * Returns: 0 if successful, error code (< 0) if not
 */
int Format(const char *devname, const char *fstype)
{
   19e53:	57                   	push   %edi
   19e54:	56                   	push   %esi
   19e55:	53                   	push   %ebx
   19e56:	83 ec 10             	sub    $0x10,%esp
   19e59:	e8 b4 63 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19e5e:	81 c3 a2 c1 00 00    	add    $0xc1a2,%ebx
    struct Filesystem *fs;
    struct Block_Device *dev = 0;
   19e64:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   19e6b:	00 
    int rc;

    /* Find the named filesystem type */
    fs = Lookup_Filesystem(fstype);
   19e6c:	8b 44 24 24          	mov    0x24(%esp),%eax
   19e70:	e8 1a fb ff ff       	call   1998f <Lookup_Filesystem>
    if (fs == 0)
   19e75:	85 c0                	test   %eax,%eax
   19e77:	0f 84 8a 00 00 00    	je     19f07 <Format+0xb4>
   19e7d:	89 c7                	mov    %eax,%edi
	return ENOFILESYS;
    Debug("Found %s filesystem type\n", fstype);
   19e7f:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19e86:	75 4f                	jne    19ed7 <Format+0x84>

    /* The Format() operation is optional. */
    if (fs->ops->Format == 0)
   19e88:	8b 07                	mov    (%edi),%eax
   19e8a:	83 38 00             	cmpl   $0x0,(%eax)
   19e8d:	74 7f                	je     19f0e <Format+0xbb>
	return EUNSUPPORTED;

    /* Attempt to open the block device */
    if ((rc = Open_Block_Device(devname, &dev)) < 0)
   19e8f:	83 ec 08             	sub    $0x8,%esp
   19e92:	8d 44 24 14          	lea    0x14(%esp),%eax
   19e96:	50                   	push   %eax
   19e97:	ff 74 24 2c          	pushl  0x2c(%esp)
   19e9b:	e8 16 e8 ff ff       	call   186b6 <Open_Block_Device>
   19ea0:	89 c6                	mov    %eax,%esi
   19ea2:	83 c4 10             	add    $0x10,%esp
   19ea5:	85 c0                	test   %eax,%eax
   19ea7:	78 25                	js     19ece <Format+0x7b>
	return rc;
    Debug("Opened device %s\n", dev->name);
   19ea9:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   19eb0:	75 3d                	jne    19eef <Format+0x9c>

    /* Dispatch to fs Format() function. */
    rc = fs->ops->Format(dev);
   19eb2:	83 ec 0c             	sub    $0xc,%esp
   19eb5:	8b 07                	mov    (%edi),%eax
   19eb7:	ff 74 24 18          	pushl  0x18(%esp)
   19ebb:	ff 10                	call   *(%eax)
   19ebd:	89 c6                	mov    %eax,%esi

    Close_Block_Device(dev);
   19ebf:	83 c4 04             	add    $0x4,%esp
   19ec2:	ff 74 24 18          	pushl  0x18(%esp)
   19ec6:	e8 8b e8 ff ff       	call   18756 <Close_Block_Device>

    return rc;
   19ecb:	83 c4 10             	add    $0x10,%esp
}
   19ece:	89 f0                	mov    %esi,%eax
   19ed0:	83 c4 10             	add    $0x10,%esp
   19ed3:	5b                   	pop    %ebx
   19ed4:	5e                   	pop    %esi
   19ed5:	5f                   	pop    %edi
   19ed6:	c3                   	ret    
    Debug("Found %s filesystem type\n", fstype);
   19ed7:	83 ec 08             	sub    $0x8,%esp
   19eda:	ff 74 24 2c          	pushl  0x2c(%esp)
   19ede:	8d 83 64 8d ff ff    	lea    -0x729c(%ebx),%eax
   19ee4:	50                   	push   %eax
   19ee5:	e8 f0 70 ff ff       	call   10fda <Print>
   19eea:	83 c4 10             	add    $0x10,%esp
   19eed:	eb 99                	jmp    19e88 <Format+0x35>
    Debug("Opened device %s\n", dev->name);
   19eef:	83 ec 08             	sub    $0x8,%esp
   19ef2:	ff 74 24 14          	pushl  0x14(%esp)
   19ef6:	8d 83 29 8c ff ff    	lea    -0x73d7(%ebx),%eax
   19efc:	50                   	push   %eax
   19efd:	e8 d8 70 ff ff       	call   10fda <Print>
   19f02:	83 c4 10             	add    $0x10,%esp
   19f05:	eb ab                	jmp    19eb2 <Format+0x5f>
	return ENOFILESYS;
   19f07:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
   19f0c:	eb c0                	jmp    19ece <Format+0x7b>
	return EUNSUPPORTED;
   19f0e:	be fd ff ff ff       	mov    $0xfffffffd,%esi
   19f13:	eb b9                	jmp    19ece <Format+0x7b>

00019f15 <Mount>:
 *   pathPrefix - where to mount the filesystem in the overall namespace
 *   fstype - filesystem type, e.g. "pfat", "gosfs"
 * Returns: 0 if successful, error code (< 0) if not
 */
int Mount(const char *devname, const char *pathPrefix, const char *fstype)
{
   19f15:	55                   	push   %ebp
   19f16:	57                   	push   %edi
   19f17:	56                   	push   %esi
   19f18:	53                   	push   %ebx
   19f19:	83 ec 2c             	sub    $0x2c,%esp
   19f1c:	e8 f1 62 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   19f21:	81 c3 df c0 00 00    	add    $0xc0df,%ebx
   19f27:	8b 6c 24 44          	mov    0x44(%esp),%ebp
    struct Filesystem *fs;
    struct Block_Device *dev = 0;
   19f2b:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   19f32:	00 
    struct Mount_Point *mountPoint = 0;
    int rc;

    /* Skip leading slash character(s) */
    while (*pathPrefix == '/')
   19f33:	80 7d 00 2f          	cmpb   $0x2f,0x0(%ebp)
   19f37:	75 09                	jne    19f42 <Mount+0x2d>
	++pathPrefix;
   19f39:	83 c5 01             	add    $0x1,%ebp
    while (*pathPrefix == '/')
   19f3c:	80 7d 00 2f          	cmpb   $0x2f,0x0(%ebp)
   19f40:	74 f7                	je     19f39 <Mount+0x24>

    if (strlen(pathPrefix) > MAX_PREFIX_LEN)
   19f42:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   19f47:	b8 00 00 00 00       	mov    $0x0,%eax
   19f4c:	89 ef                	mov    %ebp,%edi
   19f4e:	f2 ae                	repnz scas %es:(%edi),%al
   19f50:	89 c8                	mov    %ecx,%eax
   19f52:	f7 d0                	not    %eax
   19f54:	83 e8 01             	sub    $0x1,%eax
   19f57:	83 f8 10             	cmp    $0x10,%eax
   19f5a:	0f 87 e6 01 00 00    	ja     1a146 <Mount+0x231>
	return ENAMETOOLONG;

    /* Find the named filesystem type */
    fs = Lookup_Filesystem(fstype);
   19f60:	8b 44 24 48          	mov    0x48(%esp),%eax
   19f64:	e8 26 fa ff ff       	call   1998f <Lookup_Filesystem>
   19f69:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (fs == 0)
   19f6d:	85 c0                	test   %eax,%eax
   19f6f:	0f 84 d8 01 00 00    	je     1a14d <Mount+0x238>
	return ENOFILESYS;
    KASSERT(fs->ops->Mount != 0); /* All filesystems must implement Mount(). */
   19f75:	8b 00                	mov    (%eax),%eax
   19f77:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
   19f7b:	0f 84 2a 01 00 00    	je     1a0ab <Mount+0x196>

    /* Attempt to open the block device */
    if ((rc = Open_Block_Device(devname, &dev)) < 0)
   19f81:	83 ec 08             	sub    $0x8,%esp
   19f84:	8d 44 24 24          	lea    0x24(%esp),%eax
   19f88:	50                   	push   %eax
   19f89:	ff 74 24 4c          	pushl  0x4c(%esp)
   19f8d:	e8 24 e7 ff ff       	call   186b6 <Open_Block_Device>
   19f92:	89 c7                	mov    %eax,%edi
   19f94:	83 c4 10             	add    $0x10,%esp
   19f97:	85 c0                	test   %eax,%eax
   19f99:	0f 88 1e 02 00 00    	js     1a1bd <Mount+0x2a8>
	return rc;

    /* Create Mount_Point structure. */
    mountPoint = (struct Mount_Point*) Malloc(sizeof(*mountPoint));
   19f9f:	83 ec 0c             	sub    $0xc,%esp
   19fa2:	6a 18                	push   $0x18
   19fa4:	e8 03 9c ff ff       	call   13bac <Malloc>
   19fa9:	89 c6                	mov    %eax,%esi
    if (mountPoint == 0)
   19fab:	83 c4 10             	add    $0x10,%esp
   19fae:	85 c0                	test   %eax,%eax
   19fb0:	0f 84 89 01 00 00    	je     1a13f <Mount+0x22a>
	goto memfail;
    memset(mountPoint, '\0', sizeof(*mountPoint));
   19fb6:	bf 00 00 00 00       	mov    $0x0,%edi
   19fbb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   19fc1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   19fc8:	8d 48 04             	lea    0x4(%eax),%ecx
   19fcb:	83 e1 fc             	and    $0xfffffffc,%ecx
   19fce:	29 c8                	sub    %ecx,%eax
   19fd0:	83 c0 18             	add    $0x18,%eax
   19fd3:	83 e0 fc             	and    $0xfffffffc,%eax
   19fd6:	ba 00 00 00 00       	mov    $0x0,%edx
   19fdb:	89 3c 11             	mov    %edi,(%ecx,%edx,1)
   19fde:	83 c2 04             	add    $0x4,%edx
   19fe1:	39 c2                	cmp    %eax,%edx
   19fe3:	72 f6                	jb     19fdb <Mount+0xc6>
    mountPoint->dev = dev;
   19fe5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   19fe9:	89 46 08             	mov    %eax,0x8(%esi)
    mountPoint->pathPrefix = strdup(pathPrefix);
   19fec:	83 ec 0c             	sub    $0xc,%esp
   19fef:	55                   	push   %ebp
   19ff0:	e8 7a 2c 00 00       	call   1cc6f <strdup>
   19ff5:	89 46 04             	mov    %eax,0x4(%esi)
    if (mountPoint->pathPrefix == 0)
   19ff8:	83 c4 10             	add    $0x10,%esp
   19ffb:	85 c0                	test   %eax,%eax
   19ffd:	0f 84 35 01 00 00    	je     1a138 <Mount+0x223>
	goto memfail;

    Debug("Mounting %s on %s using %s fs\n", devname, pathPrefix, fstype);
   1a003:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   1a00a:	0f 85 df 00 00 00    	jne    1a0ef <Mount+0x1da>

    /* Call the filesystem mount function. */
    if ((rc = fs->ops->Mount(mountPoint)) < 0)
   1a010:	83 ec 0c             	sub    $0xc,%esp
   1a013:	8b 44 24 18          	mov    0x18(%esp),%eax
   1a017:	8b 00                	mov    (%eax),%eax
   1a019:	56                   	push   %esi
   1a01a:	ff 50 04             	call   *0x4(%eax)
   1a01d:	89 c7                	mov    %eax,%edi
   1a01f:	83 c4 10             	add    $0x10,%esp
   1a022:	85 c0                	test   %eax,%eax
   1a024:	0f 88 2a 01 00 00    	js     1a154 <Mount+0x23f>
	goto fail;

    Debug("Mount succeeded!\n");
   1a02a:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   1a031:	0f 85 d5 00 00 00    	jne    1a10c <Mount+0x1f7>
     * Add filesystem to mount point list.
     * It is now ready to receive requests.
     * FIXME: should ensure that there aren't any filesystems
     * mounted on the same filesystem root.
     */
    Mutex_Lock(&s_vfsLock);
   1a037:	83 ec 0c             	sub    $0xc,%esp
   1a03a:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   1a040:	50                   	push   %eax
   1a041:	e8 99 9f ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   1a046:	8b 83 64 13 00 00    	mov    0x1364(%ebx),%eax
   1a04c:	83 c4 10             	add    $0x10,%esp
   1a04f:	85 c0                	test   %eax,%eax
   1a051:	0f 84 32 01 00 00    	je     1a189 <Mount+0x274>
   1a057:	39 c6                	cmp    %eax,%esi
   1a059:	74 0f                	je     1a06a <Mount+0x155>
   1a05b:	8b 40 14             	mov    0x14(%eax),%eax
   1a05e:	85 c0                	test   %eax,%eax
   1a060:	0f 84 23 01 00 00    	je     1a189 <Mount+0x274>
   1a066:	39 c6                	cmp    %eax,%esi
   1a068:	75 f1                	jne    1a05b <Mount+0x146>
   1a06a:	83 ec 0c             	sub    $0xc,%esp
   1a06d:	6a 4f                	push   $0x4f
   1a06f:	e8 b5 70 ff ff       	call   11129 <Set_Current_Attr>
   1a074:	83 c4 0c             	add    $0xc,%esp
   1a077:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a07d:	ff 30                	pushl  (%eax)
   1a07f:	ff 74 24 44          	pushl  0x44(%esp)
   1a083:	6a 2a                	push   $0x2a
   1a085:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a08b:	50                   	push   %eax
   1a08c:	8d 83 a8 8d ff ff    	lea    -0x7258(%ebx),%eax
   1a092:	50                   	push   %eax
   1a093:	8d 83 e0 8e ff ff    	lea    -0x7120(%ebx),%eax
   1a099:	50                   	push   %eax
   1a09a:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a0a0:	50                   	push   %eax
   1a0a1:	e8 34 6f ff ff       	call   10fda <Print>
   1a0a6:	83 c4 20             	add    $0x20,%esp
   1a0a9:	eb fe                	jmp    1a0a9 <Mount+0x194>
    KASSERT(fs->ops->Mount != 0); /* All filesystems must implement Mount(). */
   1a0ab:	83 ec 0c             	sub    $0xc,%esp
   1a0ae:	6a 4f                	push   $0x4f
   1a0b0:	e8 74 70 ff ff       	call   11129 <Set_Current_Attr>
   1a0b5:	83 c4 0c             	add    $0xc,%esp
   1a0b8:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a0be:	ff 30                	pushl  (%eax)
   1a0c0:	ff 74 24 44          	pushl  0x44(%esp)
   1a0c4:	68 47 01 00 00       	push   $0x147
   1a0c9:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a0cf:	50                   	push   %eax
   1a0d0:	8d 83 40 8c ff ff    	lea    -0x73c0(%ebx),%eax
   1a0d6:	50                   	push   %eax
   1a0d7:	8d 83 00 8f ff ff    	lea    -0x7100(%ebx),%eax
   1a0dd:	50                   	push   %eax
   1a0de:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a0e4:	50                   	push   %eax
   1a0e5:	e8 f0 6e ff ff       	call   10fda <Print>
   1a0ea:	83 c4 20             	add    $0x20,%esp
   1a0ed:	eb fe                	jmp    1a0ed <Mount+0x1d8>
    Debug("Mounting %s on %s using %s fs\n", devname, pathPrefix, fstype);
   1a0ef:	ff 74 24 48          	pushl  0x48(%esp)
   1a0f3:	55                   	push   %ebp
   1a0f4:	ff 74 24 48          	pushl  0x48(%esp)
   1a0f8:	8d 83 84 8d ff ff    	lea    -0x727c(%ebx),%eax
   1a0fe:	50                   	push   %eax
   1a0ff:	e8 d6 6e ff ff       	call   10fda <Print>
   1a104:	83 c4 10             	add    $0x10,%esp
   1a107:	e9 04 ff ff ff       	jmp    1a010 <Mount+0xfb>
    Debug("Mount succeeded!\n");
   1a10c:	83 ec 0c             	sub    $0xc,%esp
   1a10f:	8d 83 54 8c ff ff    	lea    -0x73ac(%ebx),%eax
   1a115:	50                   	push   %eax
   1a116:	e8 bf 6e ff ff       	call   10fda <Print>
   1a11b:	83 c4 10             	add    $0x10,%esp
   1a11e:	e9 14 ff ff ff       	jmp    1a037 <Mount+0x122>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   1a123:	89 b3 68 13 00 00    	mov    %esi,0x1368(%ebx)
   1a129:	89 b3 64 13 00 00    	mov    %esi,0x1364(%ebx)
   1a12f:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
   1a136:	eb 6e                	jmp    1a1a6 <Mount+0x291>
    Mutex_Unlock(&s_vfsLock);

    return 0;

memfail:
    rc = ENOMEM;
   1a138:	bf f9 ff ff ff       	mov    $0xfffffff9,%edi
   1a13d:	eb 28                	jmp    1a167 <Mount+0x252>
   1a13f:	bf f9 ff ff ff       	mov    $0xfffffff9,%edi
   1a144:	eb 2d                	jmp    1a173 <Mount+0x25e>
	return ENAMETOOLONG;
   1a146:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
   1a14b:	eb 70                	jmp    1a1bd <Mount+0x2a8>
	return ENOFILESYS;
   1a14d:	bf f8 ff ff ff       	mov    $0xfffffff8,%edi
   1a152:	eb 69                	jmp    1a1bd <Mount+0x2a8>
fail:
    if (mountPoint != 0) {
	if (mountPoint->pathPrefix != 0)
   1a154:	8b 46 04             	mov    0x4(%esi),%eax
   1a157:	85 c0                	test   %eax,%eax
   1a159:	74 0c                	je     1a167 <Mount+0x252>
	    Free(mountPoint->pathPrefix);
   1a15b:	83 ec 0c             	sub    $0xc,%esp
   1a15e:	50                   	push   %eax
   1a15f:	e8 c6 9b ff ff       	call   13d2a <Free>
   1a164:	83 c4 10             	add    $0x10,%esp
	Free(mountPoint);
   1a167:	83 ec 0c             	sub    $0xc,%esp
   1a16a:	56                   	push   %esi
   1a16b:	e8 ba 9b ff ff       	call   13d2a <Free>
   1a170:	83 c4 10             	add    $0x10,%esp
    }
    if (dev != 0)
   1a173:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1a177:	85 c0                	test   %eax,%eax
   1a179:	74 42                	je     1a1bd <Mount+0x2a8>
	Close_Block_Device(dev);
   1a17b:	83 ec 0c             	sub    $0xc,%esp
   1a17e:	50                   	push   %eax
   1a17f:	e8 d2 e5 ff ff       	call   18756 <Close_Block_Device>
   1a184:	83 c4 10             	add    $0x10,%esp
   1a187:	eb 34                	jmp    1a1bd <Mount+0x2a8>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   1a189:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
   1a190:	8b 83 68 13 00 00    	mov    0x1368(%ebx),%eax
   1a196:	85 c0                	test   %eax,%eax
   1a198:	74 89                	je     1a123 <Mount+0x20e>
   1a19a:	89 70 14             	mov    %esi,0x14(%eax)
   1a19d:	89 46 10             	mov    %eax,0x10(%esi)
   1a1a0:	89 b3 68 13 00 00    	mov    %esi,0x1368(%ebx)
    Mutex_Unlock(&s_vfsLock);
   1a1a6:	83 ec 0c             	sub    $0xc,%esp
   1a1a9:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   1a1af:	50                   	push   %eax
   1a1b0:	e8 5d 9f ff ff       	call   14112 <Mutex_Unlock>
    return 0;
   1a1b5:	83 c4 10             	add    $0x10,%esp
   1a1b8:	bf 00 00 00 00       	mov    $0x0,%edi
    return rc;
}
   1a1bd:	89 f8                	mov    %edi,%eax
   1a1bf:	83 c4 2c             	add    $0x2c,%esp
   1a1c2:	5b                   	pop    %ebx
   1a1c3:	5e                   	pop    %esi
   1a1c4:	5f                   	pop    %edi
   1a1c5:	5d                   	pop    %ebp
   1a1c6:	c3                   	ret    

0001a1c7 <Open>:
 *   mode - open flags: combination of O_CREATE, O_READ, O_WRITE, O_EXCL
 *   pFile - where to store pointer to File object if successful
 * Returns: 0 if successful, error code (< 0) if not
 */
int Open(const char *path, int mode, struct File **pFile)
{
   1a1c7:	83 ec 18             	sub    $0x18,%esp
   1a1ca:	e8 f7 66 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   1a1cf:	05 31 be 00 00       	add    $0xbe31,%eax
    int rc = Do_Open(path, mode, pFile, &Do_Open_File);
   1a1d4:	8d 80 a9 38 ff ff    	lea    -0xc757(%eax),%eax
   1a1da:	50                   	push   %eax
   1a1db:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   1a1df:	8b 54 24 24          	mov    0x24(%esp),%edx
   1a1e3:	8b 44 24 20          	mov    0x20(%esp),%eax
   1a1e7:	e8 f0 f9 ff ff       	call   19bdc <Do_Open>
    /*if (rc != 0) { Print("File open failed with code %d\n", rc); }*/
    return rc;
}
   1a1ec:	83 c4 1c             	add    $0x1c,%esp
   1a1ef:	c3                   	ret    

0001a1f0 <Close>:
 * Params:
 *   file - the File to close
 * Returns: 0 if successful, error code (< 0) if not
 */
int Close(struct File *file)
{
   1a1f0:	57                   	push   %edi
   1a1f1:	56                   	push   %esi
   1a1f2:	53                   	push   %ebx
   1a1f3:	e8 1a 60 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a1f8:	81 c3 08 be 00 00    	add    $0xbe08,%ebx
   1a1fe:	8b 7c 24 10          	mov    0x10(%esp),%edi
    int rc;

    KASSERT(file->ops->Close != 0); /* All filesystems must implement Close(). */
   1a202:	8b 07                	mov    (%edi),%eax
   1a204:	8b 40 10             	mov    0x10(%eax),%eax
   1a207:	85 c0                	test   %eax,%eax
   1a209:	74 15                	je     1a220 <Close+0x30>

    rc = file->ops->Close(file);
   1a20b:	83 ec 0c             	sub    $0xc,%esp
   1a20e:	57                   	push   %edi
   1a20f:	ff d0                	call   *%eax
   1a211:	89 c6                	mov    %eax,%esi
    if (rc == 0)
   1a213:	83 c4 10             	add    $0x10,%esp
   1a216:	85 c0                	test   %eax,%eax
   1a218:	74 4a                	je     1a264 <Close+0x74>
	Free(file);
    return rc;
}
   1a21a:	89 f0                	mov    %esi,%eax
   1a21c:	5b                   	pop    %ebx
   1a21d:	5e                   	pop    %esi
   1a21e:	5f                   	pop    %edi
   1a21f:	c3                   	ret    
    KASSERT(file->ops->Close != 0); /* All filesystems must implement Close(). */
   1a220:	83 ec 0c             	sub    $0xc,%esp
   1a223:	6a 4f                	push   $0x4f
   1a225:	e8 ff 6e ff ff       	call   11129 <Set_Current_Attr>
   1a22a:	83 c4 0c             	add    $0xc,%esp
   1a22d:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a233:	ff 30                	pushl  (%eax)
   1a235:	ff 74 24 14          	pushl  0x14(%esp)
   1a239:	68 93 01 00 00       	push   $0x193
   1a23e:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a244:	50                   	push   %eax
   1a245:	8d 83 6b 8c ff ff    	lea    -0x7395(%ebx),%eax
   1a24b:	50                   	push   %eax
   1a24c:	8d 83 b4 8e ff ff    	lea    -0x714c(%ebx),%eax
   1a252:	50                   	push   %eax
   1a253:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a259:	50                   	push   %eax
   1a25a:	e8 7b 6d ff ff       	call   10fda <Print>
   1a25f:	83 c4 20             	add    $0x20,%esp
   1a262:	eb fe                	jmp    1a262 <Close+0x72>
	Free(file);
   1a264:	83 ec 0c             	sub    $0xc,%esp
   1a267:	57                   	push   %edi
   1a268:	e8 bd 9a ff ff       	call   13d2a <Free>
   1a26d:	83 c4 10             	add    $0x10,%esp
    return rc;
   1a270:	eb a8                	jmp    1a21a <Close+0x2a>

0001a272 <Stat>:
 *   path - path of file
 *   stat - pointer to VFS_File_Stat
 * Return: 0 if successful, error code (< 0) if not
 */
int Stat(const char *path, struct VFS_File_Stat *stat)
{
   1a272:	56                   	push   %esi
   1a273:	53                   	push   %ebx
   1a274:	83 ec 24             	sub    $0x24,%esp
   1a277:	e8 96 5f ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a27c:	81 c3 84 bd 00 00    	add    $0xbd84,%ebx
    char prefix[MAX_PREFIX_LEN + 1];
    const char *suffix;
    struct Mount_Point *mountPoint;

    if (!Unpack_Path(path, prefix, &suffix))
   1a282:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   1a286:	8d 54 24 0f          	lea    0xf(%esp),%edx
   1a28a:	8b 44 24 30          	mov    0x30(%esp),%eax
   1a28e:	e8 de f7 ff ff       	call   19a71 <Unpack_Path>
   1a293:	84 c0                	test   %al,%al
   1a295:	74 6e                	je     1a305 <Stat+0x93>
	return ENOTFOUND;

    /* Get mount point for path */
    Debug("Stat: lookup mount point for %s\n", prefix);
   1a297:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   1a29e:	75 38                	jne    1a2d8 <Stat+0x66>
    mountPoint = Lookup_Mount_Point(prefix);
   1a2a0:	8d 44 24 0f          	lea    0xf(%esp),%eax
   1a2a4:	e8 45 f7 ff ff       	call   199ee <Lookup_Mount_Point>
   1a2a9:	89 c6                	mov    %eax,%esi
    if (mountPoint == 0)
   1a2ab:	85 c0                	test   %eax,%eax
   1a2ad:	74 5d                	je     1a30c <Stat+0x9a>
	return ENOTFOUND;

    Debug("Stat: found mount point, dispatching to filesystem\n");
   1a2af:	83 bb 54 13 00 00 00 	cmpl   $0x0,0x1354(%ebx)
   1a2b6:	75 39                	jne    1a2f1 <Stat+0x7f>
    if (mountPoint->ops->Stat == 0)
   1a2b8:	8b 06                	mov    (%esi),%eax
   1a2ba:	8b 40 0c             	mov    0xc(%eax),%eax
   1a2bd:	85 c0                	test   %eax,%eax
   1a2bf:	74 52                	je     1a313 <Stat+0xa1>
	return EUNSUPPORTED;
    else
	return mountPoint->ops->Stat(mountPoint, suffix, stat);
   1a2c1:	83 ec 04             	sub    $0x4,%esp
   1a2c4:	ff 74 24 38          	pushl  0x38(%esp)
   1a2c8:	ff 74 24 10          	pushl  0x10(%esp)
   1a2cc:	56                   	push   %esi
   1a2cd:	ff d0                	call   *%eax
   1a2cf:	83 c4 10             	add    $0x10,%esp
}
   1a2d2:	83 c4 24             	add    $0x24,%esp
   1a2d5:	5b                   	pop    %ebx
   1a2d6:	5e                   	pop    %esi
   1a2d7:	c3                   	ret    
    Debug("Stat: lookup mount point for %s\n", prefix);
   1a2d8:	83 ec 08             	sub    $0x8,%esp
   1a2db:	8d 44 24 17          	lea    0x17(%esp),%eax
   1a2df:	50                   	push   %eax
   1a2e0:	8d 83 dc 8d ff ff    	lea    -0x7224(%ebx),%eax
   1a2e6:	50                   	push   %eax
   1a2e7:	e8 ee 6c ff ff       	call   10fda <Print>
   1a2ec:	83 c4 10             	add    $0x10,%esp
   1a2ef:	eb af                	jmp    1a2a0 <Stat+0x2e>
    Debug("Stat: found mount point, dispatching to filesystem\n");
   1a2f1:	83 ec 0c             	sub    $0xc,%esp
   1a2f4:	8d 83 04 8e ff ff    	lea    -0x71fc(%ebx),%eax
   1a2fa:	50                   	push   %eax
   1a2fb:	e8 da 6c ff ff       	call   10fda <Print>
   1a300:	83 c4 10             	add    $0x10,%esp
   1a303:	eb b3                	jmp    1a2b8 <Stat+0x46>
	return ENOTFOUND;
   1a305:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a30a:	eb c6                	jmp    1a2d2 <Stat+0x60>
	return ENOTFOUND;
   1a30c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a311:	eb bf                	jmp    1a2d2 <Stat+0x60>
	return EUNSUPPORTED;
   1a313:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a318:	eb b8                	jmp    1a2d2 <Stat+0x60>

0001a31a <Sync>:
/*
 * Sync all mounted filesystems.
 * Returns: 0 if successful, error code (< 0) if not
 */
int Sync(void)
{
   1a31a:	57                   	push   %edi
   1a31b:	56                   	push   %esi
   1a31c:	53                   	push   %ebx
   1a31d:	e8 f0 5e ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a322:	81 c3 de bc 00 00    	add    $0xbcde,%ebx
    int rc = 0;
    struct Mount_Point *mountPoint;

    Mutex_Lock(&s_vfsLock);
   1a328:	83 ec 0c             	sub    $0xc,%esp
   1a32b:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   1a331:	50                   	push   %eax
   1a332:	e8 a8 9c ff ff       	call   13fdf <Mutex_Lock>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   1a337:	8b b3 64 13 00 00    	mov    0x1364(%ebx),%esi
    for (mountPoint = Get_Front_Of_Mount_Point_List(&s_mountPointList);
   1a33d:	83 c4 10             	add    $0x10,%esp
   1a340:	85 f6                	test   %esi,%esi
   1a342:	74 7b                	je     1a3bf <Sync+0xa5>
	 mountPoint != 0;
	 mountPoint = Get_Next_In_Mount_Point_List(mountPoint)) {
	KASSERT(mountPoint->ops->Sync != 0);/* All filesystems must implement Sync */
   1a344:	8b 06                	mov    (%esi),%eax
   1a346:	8b 40 10             	mov    0x10(%eax),%eax
   1a349:	85 c0                	test   %eax,%eax
   1a34b:	74 2e                	je     1a37b <Sync+0x61>
	rc = mountPoint->ops->Sync(mountPoint);
   1a34d:	83 ec 0c             	sub    $0xc,%esp
   1a350:	56                   	push   %esi
   1a351:	ff d0                	call   *%eax
   1a353:	89 c7                	mov    %eax,%edi
	if (rc != 0)
   1a355:	83 c4 10             	add    $0x10,%esp
   1a358:	85 c0                	test   %eax,%eax
   1a35a:	75 07                	jne    1a363 <Sync+0x49>
IMPLEMENT_LIST(Mount_Point_List, Mount_Point);
   1a35c:	8b 76 14             	mov    0x14(%esi),%esi
    for (mountPoint = Get_Front_Of_Mount_Point_List(&s_mountPointList);
   1a35f:	85 f6                	test   %esi,%esi
   1a361:	75 e1                	jne    1a344 <Sync+0x2a>
	    break;
    }
    Mutex_Unlock(&s_vfsLock);
   1a363:	83 ec 0c             	sub    $0xc,%esp
   1a366:	8d 83 6c 13 00 00    	lea    0x136c(%ebx),%eax
   1a36c:	50                   	push   %eax
   1a36d:	e8 a0 9d ff ff       	call   14112 <Mutex_Unlock>

    return rc;
   1a372:	83 c4 10             	add    $0x10,%esp
}
   1a375:	89 f8                	mov    %edi,%eax
   1a377:	5b                   	pop    %ebx
   1a378:	5e                   	pop    %esi
   1a379:	5f                   	pop    %edi
   1a37a:	c3                   	ret    
	KASSERT(mountPoint->ops->Sync != 0);/* All filesystems must implement Sync */
   1a37b:	83 ec 0c             	sub    $0xc,%esp
   1a37e:	6a 4f                	push   $0x4f
   1a380:	e8 a4 6d ff ff       	call   11129 <Set_Current_Attr>
   1a385:	83 c4 0c             	add    $0xc,%esp
   1a388:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a38e:	ff 30                	pushl  (%eax)
   1a390:	ff 74 24 14          	pushl  0x14(%esp)
   1a394:	68 c5 01 00 00       	push   $0x1c5
   1a399:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a39f:	50                   	push   %eax
   1a3a0:	8d 83 81 8c ff ff    	lea    -0x737f(%ebx),%eax
   1a3a6:	50                   	push   %eax
   1a3a7:	8d 83 ac 8e ff ff    	lea    -0x7154(%ebx),%eax
   1a3ad:	50                   	push   %eax
   1a3ae:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a3b4:	50                   	push   %eax
   1a3b5:	e8 20 6c ff ff       	call   10fda <Print>
   1a3ba:	83 c4 20             	add    $0x20,%esp
   1a3bd:	eb fe                	jmp    1a3bd <Sync+0xa3>
    int rc = 0;
   1a3bf:	bf 00 00 00 00       	mov    $0x0,%edi
   1a3c4:	eb 9d                	jmp    1a363 <Sync+0x49>

0001a3c6 <Allocate_File>:
 *
 * Returns: new File object, or null if out of memory
 */
struct File *Allocate_File(struct File_Ops *ops, int filePos, int endPos, void *fsData,
    int mode, struct Mount_Point *mountPoint)
{
   1a3c6:	53                   	push   %ebx
   1a3c7:	83 ec 14             	sub    $0x14,%esp
   1a3ca:	e8 43 5e ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a3cf:	81 c3 31 bc 00 00    	add    $0xbc31,%ebx
    struct File *file;

    file = (struct File *) Malloc(sizeof(struct File));
   1a3d5:	6a 18                	push   $0x18
   1a3d7:	e8 d0 97 ff ff       	call   13bac <Malloc>
    if (file != 0) {
   1a3dc:	83 c4 10             	add    $0x10,%esp
   1a3df:	85 c0                	test   %eax,%eax
   1a3e1:	74 29                	je     1a40c <Allocate_File+0x46>
	file->ops = ops;
   1a3e3:	8b 54 24 10          	mov    0x10(%esp),%edx
   1a3e7:	89 10                	mov    %edx,(%eax)
	file->filePos = filePos;
   1a3e9:	8b 54 24 14          	mov    0x14(%esp),%edx
   1a3ed:	89 50 04             	mov    %edx,0x4(%eax)
	file->endPos = endPos;
   1a3f0:	8b 54 24 18          	mov    0x18(%esp),%edx
   1a3f4:	89 50 08             	mov    %edx,0x8(%eax)
	file->fsData = fsData;
   1a3f7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1a3fb:	89 50 0c             	mov    %edx,0xc(%eax)
	file->mode = mode;
   1a3fe:	8b 54 24 20          	mov    0x20(%esp),%edx
   1a402:	89 50 10             	mov    %edx,0x10(%eax)
	file->mountPoint = mountPoint;
   1a405:	8b 54 24 24          	mov    0x24(%esp),%edx
   1a409:	89 50 14             	mov    %edx,0x14(%eax)
    }
    return file;
}
   1a40c:	83 c4 08             	add    $0x8,%esp
   1a40f:	5b                   	pop    %ebx
   1a410:	c3                   	ret    

0001a411 <FStat>:
 *   file - File object
 *   stat - pointer to VFS_File_Stat
 * Returns: 0 if successful, error code (< 0) if not
 */
int FStat(struct File *file, struct VFS_File_Stat *stat)
{
   1a411:	83 ec 0c             	sub    $0xc,%esp
   1a414:	8b 54 24 10          	mov    0x10(%esp),%edx
    if (file->ops->FStat == 0)
   1a418:	8b 02                	mov    (%edx),%eax
   1a41a:	8b 00                	mov    (%eax),%eax
   1a41c:	85 c0                	test   %eax,%eax
   1a41e:	74 11                	je     1a431 <FStat+0x20>
	return EUNSUPPORTED;
    else
	return file->ops->FStat(file, stat);
   1a420:	83 ec 08             	sub    $0x8,%esp
   1a423:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a427:	52                   	push   %edx
   1a428:	ff d0                	call   *%eax
   1a42a:	83 c4 10             	add    $0x10,%esp
}
   1a42d:	83 c4 0c             	add    $0xc,%esp
   1a430:	c3                   	ret    
	return EUNSUPPORTED;
   1a431:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a436:	eb f5                	jmp    1a42d <FStat+0x1c>

0001a438 <Read>:
 *   len - number of bytes to read
 * Returns: number of bytes read, 0 if end-of-file is reached,
 *   or error code (< 0) if read fails
 */
int Read(struct File *file, void *buf, ulong_t len)
{
   1a438:	83 ec 0c             	sub    $0xc,%esp
   1a43b:	8b 54 24 10          	mov    0x10(%esp),%edx
    if (file->ops->Read == 0)
   1a43f:	8b 02                	mov    (%edx),%eax
   1a441:	8b 40 04             	mov    0x4(%eax),%eax
   1a444:	85 c0                	test   %eax,%eax
   1a446:	74 15                	je     1a45d <Read+0x25>
	return EUNSUPPORTED;
    else
	return file->ops->Read(file, buf, len);
   1a448:	83 ec 04             	sub    $0x4,%esp
   1a44b:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a44f:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a453:	52                   	push   %edx
   1a454:	ff d0                	call   *%eax
   1a456:	83 c4 10             	add    $0x10,%esp
}
   1a459:	83 c4 0c             	add    $0xc,%esp
   1a45c:	c3                   	ret    
	return EUNSUPPORTED;
   1a45d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a462:	eb f5                	jmp    1a459 <Read+0x21>

0001a464 <Write>:
 *   buf - kernel buffer containing data to be written
 *   len - number of bytes to write
 * Returns: number of bytes written, or error code (< 0) if read fails
 */
int Write(struct File *file, void *buf, ulong_t len)
{
   1a464:	83 ec 0c             	sub    $0xc,%esp
   1a467:	8b 54 24 10          	mov    0x10(%esp),%edx
    if (file->ops->Write == 0)
   1a46b:	8b 02                	mov    (%edx),%eax
   1a46d:	8b 40 08             	mov    0x8(%eax),%eax
   1a470:	85 c0                	test   %eax,%eax
   1a472:	74 15                	je     1a489 <Write+0x25>
	return EUNSUPPORTED;
    else
	return file->ops->Write(file, buf, len);
   1a474:	83 ec 04             	sub    $0x4,%esp
   1a477:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a47b:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a47f:	52                   	push   %edx
   1a480:	ff d0                	call   *%eax
   1a482:	83 c4 10             	add    $0x10,%esp
}
   1a485:	83 c4 0c             	add    $0xc,%esp
   1a488:	c3                   	ret    
	return EUNSUPPORTED;
   1a489:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a48e:	eb f5                	jmp    1a485 <Write+0x21>

0001a490 <Seek>:
 *   len - new position
 * Returns: 0 if successful,
 *   or error code (< 0) if it fails
 */
int Seek(struct File *file, ulong_t len)
{
   1a490:	83 ec 0c             	sub    $0xc,%esp
   1a493:	8b 54 24 10          	mov    0x10(%esp),%edx
    if (file->ops->Seek == 0)
   1a497:	8b 02                	mov    (%edx),%eax
   1a499:	8b 40 0c             	mov    0xc(%eax),%eax
   1a49c:	85 c0                	test   %eax,%eax
   1a49e:	74 11                	je     1a4b1 <Seek+0x21>
	return EUNSUPPORTED;
    else
	return file->ops->Seek(file, len);
   1a4a0:	83 ec 08             	sub    $0x8,%esp
   1a4a3:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a4a7:	52                   	push   %edx
   1a4a8:	ff d0                	call   *%eax
   1a4aa:	83 c4 10             	add    $0x10,%esp
}
   1a4ad:	83 c4 0c             	add    $0xc,%esp
   1a4b0:	c3                   	ret    
	return EUNSUPPORTED;
   1a4b1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a4b6:	eb f5                	jmp    1a4ad <Seek+0x1d>

0001a4b8 <Read_Fully>:
 *   pLen - reference to variable where length of file should
 *     be stored
 * Returns: 0 if successful, error code (< 0) if not
 */
int Read_Fully(const char *path, void **pBuffer, ulong_t *pLen)
{
   1a4b8:	55                   	push   %ebp
   1a4b9:	57                   	push   %edi
   1a4ba:	56                   	push   %esi
   1a4bb:	53                   	push   %ebx
   1a4bc:	83 ec 54             	sub    $0x54,%esp
   1a4bf:	e8 8a df ff ff       	call   1844e <__x86.get_pc_thunk.bp>
   1a4c4:	81 c5 3c bb 00 00    	add    $0xbb3c,%ebp
   1a4ca:	8b 5c 24 68          	mov    0x68(%esp),%ebx
    struct File *file = 0;
   1a4ce:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
   1a4d5:	00 
    struct VFS_File_Stat stat;
    int rc;
    char *buf = 0;
    int numBytesRead;

    if ((rc = Stat(path, &stat)) < 0 || (rc = Open(path, O_READ, &file)) < 0)
   1a4d6:	8d 44 24 14          	lea    0x14(%esp),%eax
   1a4da:	50                   	push   %eax
   1a4db:	53                   	push   %ebx
   1a4dc:	e8 91 fd ff ff       	call   1a272 <Stat>
   1a4e1:	89 c6                	mov    %eax,%esi
   1a4e3:	83 c4 10             	add    $0x10,%esp
   1a4e6:	85 c0                	test   %eax,%eax
   1a4e8:	0f 88 93 00 00 00    	js     1a581 <Read_Fully+0xc9>
   1a4ee:	83 ec 04             	sub    $0x4,%esp
   1a4f1:	8d 44 24 40          	lea    0x40(%esp),%eax
   1a4f5:	50                   	push   %eax
   1a4f6:	6a 02                	push   $0x2
   1a4f8:	53                   	push   %ebx
   1a4f9:	e8 c9 fc ff ff       	call   1a1c7 <Open>
   1a4fe:	89 c6                	mov    %eax,%esi
   1a500:	83 c4 10             	add    $0x10,%esp
   1a503:	85 c0                	test   %eax,%eax
   1a505:	78 7a                	js     1a581 <Read_Fully+0xc9>
	goto fail;
    if (stat.size < 0) {
   1a507:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a50b:	85 c0                	test   %eax,%eax
   1a50d:	78 6d                	js     1a57c <Read_Fully+0xc4>
	rc = ENOTFOUND;
	goto fail;
    }

    buf = (char*) Malloc(stat.size);
   1a50f:	83 ec 0c             	sub    $0xc,%esp
   1a512:	50                   	push   %eax
   1a513:	89 eb                	mov    %ebp,%ebx
   1a515:	e8 92 96 ff ff       	call   13bac <Malloc>
   1a51a:	89 c7                	mov    %eax,%edi
    if (buf == 0)
   1a51c:	83 c4 10             	add    $0x10,%esp
   1a51f:	85 c0                	test   %eax,%eax
   1a521:	74 74                	je     1a597 <Read_Fully+0xdf>
	goto memfail;

    /* Read until buffer is full */
    numBytesRead = 0;
    while (numBytesRead < stat.size) {
   1a523:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a527:	85 c0                	test   %eax,%eax
   1a529:	7e 2b                	jle    1a556 <Read_Fully+0x9e>
    numBytesRead = 0;
   1a52b:	bb 00 00 00 00       	mov    $0x0,%ebx
	rc = Read(file, buf + numBytesRead, stat.size - numBytesRead);
   1a530:	83 ec 04             	sub    $0x4,%esp
   1a533:	29 d8                	sub    %ebx,%eax
   1a535:	50                   	push   %eax
   1a536:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
   1a539:	50                   	push   %eax
   1a53a:	ff 74 24 48          	pushl  0x48(%esp)
   1a53e:	e8 f5 fe ff ff       	call   1a438 <Read>
   1a543:	89 c6                	mov    %eax,%esi
	if (rc < 0)
   1a545:	83 c4 10             	add    $0x10,%esp
   1a548:	85 c0                	test   %eax,%eax
   1a54a:	78 52                	js     1a59e <Read_Fully+0xe6>
	    goto fail;
	numBytesRead += rc;
   1a54c:	01 c3                	add    %eax,%ebx
    while (numBytesRead < stat.size) {
   1a54e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a552:	39 d8                	cmp    %ebx,%eax
   1a554:	7f da                	jg     1a530 <Read_Fully+0x78>
    }

    /* Success! */
    Close(file);
   1a556:	83 ec 0c             	sub    $0xc,%esp
   1a559:	ff 74 24 48          	pushl  0x48(%esp)
   1a55d:	e8 8e fc ff ff       	call   1a1f0 <Close>
    *pBuffer = (void*) buf;
   1a562:	8b 44 24 74          	mov    0x74(%esp),%eax
   1a566:	89 38                	mov    %edi,(%eax)
    *pLen = stat.size;
   1a568:	8b 44 24 78          	mov    0x78(%esp),%eax
   1a56c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   1a570:	89 10                	mov    %edx,(%eax)
    return 0;
   1a572:	83 c4 10             	add    $0x10,%esp
   1a575:	be 00 00 00 00       	mov    $0x0,%esi
   1a57a:	eb 44                	jmp    1a5c0 <Read_Fully+0x108>
	rc = ENOTFOUND;
   1a57c:	be fe ff ff ff       	mov    $0xfffffffe,%esi

memfail:
    rc = ENOMEM;
fail:
    if (file != 0)
   1a581:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1a585:	85 c0                	test   %eax,%eax
   1a587:	74 37                	je     1a5c0 <Read_Fully+0x108>
	Close(file);
   1a589:	83 ec 0c             	sub    $0xc,%esp
   1a58c:	50                   	push   %eax
   1a58d:	e8 5e fc ff ff       	call   1a1f0 <Close>
   1a592:	83 c4 10             	add    $0x10,%esp
   1a595:	eb 29                	jmp    1a5c0 <Read_Fully+0x108>
    rc = ENOMEM;
   1a597:	be f9 ff ff ff       	mov    $0xfffffff9,%esi
   1a59c:	eb e3                	jmp    1a581 <Read_Fully+0xc9>
    if (file != 0)
   1a59e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
   1a5a2:	85 c0                	test   %eax,%eax
   1a5a4:	74 0c                	je     1a5b2 <Read_Fully+0xfa>
	Close(file);
   1a5a6:	83 ec 0c             	sub    $0xc,%esp
   1a5a9:	50                   	push   %eax
   1a5aa:	e8 41 fc ff ff       	call   1a1f0 <Close>
   1a5af:	83 c4 10             	add    $0x10,%esp
    if (buf != 0)
	Free(buf);
   1a5b2:	83 ec 0c             	sub    $0xc,%esp
   1a5b5:	57                   	push   %edi
   1a5b6:	89 eb                	mov    %ebp,%ebx
   1a5b8:	e8 6d 97 ff ff       	call   13d2a <Free>
   1a5bd:	83 c4 10             	add    $0x10,%esp
    return rc;
}
   1a5c0:	89 f0                	mov    %esi,%eax
   1a5c2:	83 c4 4c             	add    $0x4c,%esp
   1a5c5:	5b                   	pop    %ebx
   1a5c6:	5e                   	pop    %esi
   1a5c7:	5f                   	pop    %edi
   1a5c8:	5d                   	pop    %ebp
   1a5c9:	c3                   	ret    

0001a5ca <Create_Directory>:
 * Params:
 *   path - full path of directory to create
 * Returns: 0 if successful, error code (< 0) if not
 */
int Create_Directory(const char *path)
{
   1a5ca:	83 ec 2c             	sub    $0x2c,%esp
    char prefix[MAX_PREFIX_LEN + 1];
    const char *suffix;
    struct Mount_Point *mountPoint;

    /* Split path into prefix and suffix */
    if (!Unpack_Path(path, prefix, &suffix))
   1a5cd:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   1a5d1:	8d 54 24 0f          	lea    0xf(%esp),%edx
   1a5d5:	8b 44 24 30          	mov    0x30(%esp),%eax
   1a5d9:	e8 93 f4 ff ff       	call   19a71 <Unpack_Path>
   1a5de:	84 c0                	test   %al,%al
   1a5e0:	74 27                	je     1a609 <Create_Directory+0x3f>
	return ENOTFOUND;

    /* Get mount point for path */
    mountPoint = Lookup_Mount_Point(prefix);
   1a5e2:	8d 44 24 0f          	lea    0xf(%esp),%eax
   1a5e6:	e8 03 f4 ff ff       	call   199ee <Lookup_Mount_Point>
    if (mountPoint == 0)
   1a5eb:	85 c0                	test   %eax,%eax
   1a5ed:	74 21                	je     1a610 <Create_Directory+0x46>
	return ENOTFOUND;

    if (mountPoint->ops->Create_Directory == 0)
   1a5ef:	8b 10                	mov    (%eax),%edx
   1a5f1:	8b 52 04             	mov    0x4(%edx),%edx
   1a5f4:	85 d2                	test   %edx,%edx
   1a5f6:	74 1f                	je     1a617 <Create_Directory+0x4d>
	return EUNSUPPORTED;
    else
	return mountPoint->ops->Create_Directory(mountPoint, suffix);
   1a5f8:	83 ec 08             	sub    $0x8,%esp
   1a5fb:	ff 74 24 10          	pushl  0x10(%esp)
   1a5ff:	50                   	push   %eax
   1a600:	ff d2                	call   *%edx
   1a602:	83 c4 10             	add    $0x10,%esp
}
   1a605:	83 c4 2c             	add    $0x2c,%esp
   1a608:	c3                   	ret    
	return ENOTFOUND;
   1a609:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a60e:	eb f5                	jmp    1a605 <Create_Directory+0x3b>
	return ENOTFOUND;
   1a610:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a615:	eb ee                	jmp    1a605 <Create_Directory+0x3b>
	return EUNSUPPORTED;
   1a617:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a61c:	eb e7                	jmp    1a605 <Create_Directory+0x3b>

0001a61e <Delete>:
 * Params:
 *   path - full path of file/directory to delete
 * Returns: 0 if successful, error code (< 0) if not
 */
int Delete(const char *path)
{
   1a61e:	83 ec 2c             	sub    $0x2c,%esp
    char prefix[MAX_PREFIX_LEN + 1];
    const char *suffix;
    struct Mount_Point *mountPoint;

    /* Split path into prefix and suffix */
    if (!Unpack_Path(path, prefix, &suffix))
   1a621:	8d 4c 24 08          	lea    0x8(%esp),%ecx
   1a625:	8d 54 24 0f          	lea    0xf(%esp),%edx
   1a629:	8b 44 24 30          	mov    0x30(%esp),%eax
   1a62d:	e8 3f f4 ff ff       	call   19a71 <Unpack_Path>
   1a632:	84 c0                	test   %al,%al
   1a634:	74 27                	je     1a65d <Delete+0x3f>
	return ENOTFOUND;

    /* Get mount point for path */
    mountPoint = Lookup_Mount_Point(prefix);
   1a636:	8d 44 24 0f          	lea    0xf(%esp),%eax
   1a63a:	e8 af f3 ff ff       	call   199ee <Lookup_Mount_Point>
    if (mountPoint == 0)
   1a63f:	85 c0                	test   %eax,%eax
   1a641:	74 21                	je     1a664 <Delete+0x46>
	return ENOTFOUND;

    if (mountPoint->ops->Delete == 0)
   1a643:	8b 10                	mov    (%eax),%edx
   1a645:	8b 52 14             	mov    0x14(%edx),%edx
   1a648:	85 d2                	test   %edx,%edx
   1a64a:	74 1f                	je     1a66b <Delete+0x4d>
	return EUNSUPPORTED;
    else
	return mountPoint->ops->Delete(mountPoint, suffix);
   1a64c:	83 ec 08             	sub    $0x8,%esp
   1a64f:	ff 74 24 10          	pushl  0x10(%esp)
   1a653:	50                   	push   %eax
   1a654:	ff d2                	call   *%edx
   1a656:	83 c4 10             	add    $0x10,%esp
}
   1a659:	83 c4 2c             	add    $0x2c,%esp
   1a65c:	c3                   	ret    
	return ENOTFOUND;
   1a65d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a662:	eb f5                	jmp    1a659 <Delete+0x3b>
	return ENOTFOUND;
   1a664:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   1a669:	eb ee                	jmp    1a659 <Delete+0x3b>
	return EUNSUPPORTED;
   1a66b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a670:	eb e7                	jmp    1a659 <Delete+0x3b>

0001a672 <Open_Directory>:
 *   path - full path of directory
 *   pDir - where File object of opened directory should be stored
 * Returns: 0 if successful, error code (< 0) if not
 */
int Open_Directory(const char *path, struct File **pDir)
{
   1a672:	83 ec 18             	sub    $0x18,%esp
   1a675:	e8 4c 62 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   1a67a:	05 86 b9 00 00       	add    $0xb986,%eax
    return Do_Open(path, 0, pDir, &Do_Open_Directory);
   1a67f:	8d 80 1c 39 ff ff    	lea    -0xc6e4(%eax),%eax
   1a685:	50                   	push   %eax
   1a686:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   1a68a:	ba 00 00 00 00       	mov    $0x0,%edx
   1a68f:	8b 44 24 20          	mov    0x20(%esp),%eax
   1a693:	e8 44 f5 ff ff       	call   19bdc <Do_Open>
}
   1a698:	83 c4 1c             	add    $0x1c,%esp
   1a69b:	c3                   	ret    

0001a69c <Read_Entry>:
 *   file - the File object representing the opened directory
 *   entry - pointer to VFS_Dir_Entry object
 * Returns: 0 if successful, error code (< 0) if not
 */
int Read_Entry(struct File *file, struct VFS_Dir_Entry *entry)
{
   1a69c:	83 ec 0c             	sub    $0xc,%esp
   1a69f:	8b 54 24 10          	mov    0x10(%esp),%edx
    if (file->ops->Read_Entry == 0)
   1a6a3:	8b 02                	mov    (%edx),%eax
   1a6a5:	8b 40 14             	mov    0x14(%eax),%eax
   1a6a8:	85 c0                	test   %eax,%eax
   1a6aa:	74 11                	je     1a6bd <Read_Entry+0x21>
	return EUNSUPPORTED;
    else
	return file->ops->Read_Entry(file, entry);
   1a6ac:	83 ec 08             	sub    $0x8,%esp
   1a6af:	ff 74 24 1c          	pushl  0x1c(%esp)
   1a6b3:	52                   	push   %edx
   1a6b4:	ff d0                	call   *%eax
   1a6b6:	83 c4 10             	add    $0x10,%esp
}
   1a6b9:	83 c4 0c             	add    $0xc,%esp
   1a6bc:	c3                   	ret    
	return EUNSUPPORTED;
   1a6bd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
   1a6c2:	eb f5                	jmp    1a6b9 <Read_Entry+0x1d>

0001a6c4 <Register_Paging_Device>:

/*
 * Register a paging device.
 */
void Register_Paging_Device(struct Paging_Device *pagingDevice)
{
   1a6c4:	56                   	push   %esi
   1a6c5:	53                   	push   %ebx
   1a6c6:	83 ec 04             	sub    $0x4,%esp
   1a6c9:	e8 44 5b ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a6ce:	81 c3 32 b9 00 00    	add    $0xb932,%ebx
   1a6d4:	8b 74 24 10          	mov    0x10(%esp),%esi
    KASSERT(s_pagingDevice == 0);
   1a6d8:	83 bb 58 13 00 00 00 	cmpl   $0x0,0x1358(%ebx)
   1a6df:	74 44                	je     1a725 <Register_Paging_Device+0x61>
   1a6e1:	83 ec 0c             	sub    $0xc,%esp
   1a6e4:	6a 4f                	push   $0x4f
   1a6e6:	e8 3e 6a ff ff       	call   11129 <Set_Current_Attr>
   1a6eb:	83 c4 0c             	add    $0xc,%esp
   1a6ee:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a6f4:	ff 30                	pushl  (%eax)
   1a6f6:	ff 74 24 14          	pushl  0x14(%esp)
   1a6fa:	68 b8 02 00 00       	push   $0x2b8
   1a6ff:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a705:	50                   	push   %eax
   1a706:	8d 83 9c 8c ff ff    	lea    -0x7364(%ebx),%eax
   1a70c:	50                   	push   %eax
   1a70d:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
   1a713:	50                   	push   %eax
   1a714:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a71a:	50                   	push   %eax
   1a71b:	e8 ba 68 ff ff       	call   10fda <Print>
   1a720:	83 c4 20             	add    $0x20,%esp
   1a723:	eb fe                	jmp    1a723 <Register_Paging_Device+0x5f>
    KASSERT(pagingDevice != 0);
   1a725:	85 f6                	test   %esi,%esi
   1a727:	74 20                	je     1a749 <Register_Paging_Device+0x85>
    Print("Registering paging device: %s on %s\n", pagingDevice->fileName, pagingDevice->dev->name);
   1a729:	83 ec 04             	sub    $0x4,%esp
   1a72c:	ff 76 04             	pushl  0x4(%esi)
   1a72f:	ff 36                	pushl  (%esi)
   1a731:	8d 83 40 8e ff ff    	lea    -0x71c0(%ebx),%eax
   1a737:	50                   	push   %eax
   1a738:	e8 9d 68 ff ff       	call   10fda <Print>
    s_pagingDevice = pagingDevice;
   1a73d:	89 b3 58 13 00 00    	mov    %esi,0x1358(%ebx)
}
   1a743:	83 c4 14             	add    $0x14,%esp
   1a746:	5b                   	pop    %ebx
   1a747:	5e                   	pop    %esi
   1a748:	c3                   	ret    
    KASSERT(pagingDevice != 0);
   1a749:	83 ec 0c             	sub    $0xc,%esp
   1a74c:	6a 4f                	push   $0x4f
   1a74e:	e8 d6 69 ff ff       	call   11129 <Set_Current_Attr>
   1a753:	83 c4 0c             	add    $0xc,%esp
   1a756:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1a75c:	ff 30                	pushl  (%eax)
   1a75e:	ff 74 24 14          	pushl  0x14(%esp)
   1a762:	68 b9 02 00 00       	push   $0x2b9
   1a767:	8d 83 95 8b ff ff    	lea    -0x746b(%ebx),%eax
   1a76d:	50                   	push   %eax
   1a76e:	8d 83 b0 8c ff ff    	lea    -0x7350(%ebx),%eax
   1a774:	50                   	push   %eax
   1a775:	8d 83 80 8e ff ff    	lea    -0x7180(%ebx),%eax
   1a77b:	50                   	push   %eax
   1a77c:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1a782:	50                   	push   %eax
   1a783:	e8 52 68 ff ff       	call   10fda <Print>
   1a788:	83 c4 20             	add    $0x20,%esp
   1a78b:	eb fe                	jmp    1a78b <Register_Paging_Device+0xc7>

0001a78d <Get_Paging_Device>:
/*
 * Get the paging device.
 * Returns null if no paging device has been registered.
 */
struct Paging_Device *Get_Paging_Device(void)
{
   1a78d:	e8 34 61 ff ff       	call   108c6 <__x86.get_pc_thunk.ax>
   1a792:	05 6e b8 00 00       	add    $0xb86e,%eax
    return s_pagingDevice;
   1a797:	8b 80 58 13 00 00    	mov    0x1358(%eax),%eax
}
   1a79d:	c3                   	ret    

0001a79e <Fat16_Format>:
    0
};

static
int
Fat16_Format(struct Block_Device* dev) {
   1a79e:	55                   	push   %ebp
   1a79f:	57                   	push   %edi
   1a7a0:	56                   	push   %esi
   1a7a1:	53                   	push   %ebx
   1a7a2:	81 ec 28 02 00 00    	sub    $0x228,%esp
   1a7a8:	e8 65 5a ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a7ad:	81 c3 53 b8 00 00    	add    $0xb853,%ebx
   1a7b3:	8b ac 24 3c 02 00 00 	mov    0x23c(%esp),%ebp
    Print(s);
   1a7ba:	8d 83 3c 8f ff ff    	lea    -0x70c4(%ebx),%eax
   1a7c0:	50                   	push   %eax
   1a7c1:	e8 14 68 ff ff       	call   10fda <Print>
    Debug("Formatting...\n");
    char buf[SECTOR_SIZE];
    memset(buf, 0, SECTOR_SIZE);
   1a7c6:	8d 54 24 20          	lea    0x20(%esp),%edx
   1a7ca:	b9 80 00 00 00       	mov    $0x80,%ecx
   1a7cf:	b8 00 00 00 00       	mov    $0x0,%eax
   1a7d4:	89 d7                	mov    %edx,%edi
   1a7d6:	f3 ab                	rep stos %eax,%es:(%edi)
    Fat16_BootSector bSector;
    memset(&bSector, 0, sizeof(bSector));
   1a7d8:	c7 44 24 13 00 00 00 	movl   $0x0,0x13(%esp)
   1a7df:	00 
   1a7e0:	c7 44 24 17 00 00 00 	movl   $0x0,0x17(%esp)
   1a7e7:	00 
   1a7e8:	66 c7 44 24 1b 00 00 	movw   $0x0,0x1b(%esp)
   1a7ef:	c6 44 24 1d 00       	movb   $0x0,0x1d(%esp)
   1a7f4:	83 c4 10             	add    $0x10,%esp

    // write fat table
    for (int i = 1; i < FIRST_DIR_BLOCK; i++) {
   1a7f7:	be 01 00 00 00       	mov    $0x1,%esi
        Block_Write(dev, i, buf);
   1a7fc:	8d 7c 24 10          	lea    0x10(%esp),%edi
   1a800:	83 ec 04             	sub    $0x4,%esp
   1a803:	57                   	push   %edi
   1a804:	56                   	push   %esi
   1a805:	55                   	push   %ebp
   1a806:	e8 ff e4 ff ff       	call   18d0a <Block_Write>
    for (int i = 1; i < FIRST_DIR_BLOCK; i++) {
   1a80b:	83 c6 01             	add    $0x1,%esi
   1a80e:	83 c4 10             	add    $0x10,%esp
   1a811:	81 fe 01 02 00 00    	cmp    $0x201,%esi
   1a817:	75 e7                	jne    1a800 <Fat16_Format+0x62>
    }

    bSector.sectorPerCluster = 1;
   1a819:	c6 44 24 05 01       	movb   $0x1,0x5(%esp)
    bSector.fatCount = 2;
   1a81e:	c6 44 24 08 02       	movb   $0x2,0x8(%esp)
    bSector.sectorPerFatTable = SECTOR_PER_FATT;
   1a823:	66 c7 44 24 0e 00 01 	movw   $0x100,0xe(%esp)
    bSector.sectorSize = SECTOR_SIZE;
   1a82a:	66 c7 44 24 03 00 02 	movw   $0x200,0x3(%esp)
    memcpy(buf, &bSector, sizeof(bSector));
   1a831:	8b 44 24 03          	mov    0x3(%esp),%eax
   1a835:	89 44 24 10          	mov    %eax,0x10(%esp)
   1a839:	8b 44 24 07          	mov    0x7(%esp),%eax
   1a83d:	89 44 24 14          	mov    %eax,0x14(%esp)
   1a841:	8b 44 24 0b          	mov    0xb(%esp),%eax
   1a845:	89 44 24 18          	mov    %eax,0x18(%esp)
   1a849:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
   1a84e:	88 44 24 1c          	mov    %al,0x1c(%esp)
    Block_Write(dev, 0, buf);
   1a852:	83 ec 04             	sub    $0x4,%esp
   1a855:	8d 44 24 14          	lea    0x14(%esp),%eax
   1a859:	50                   	push   %eax
   1a85a:	6a 00                	push   $0x0
   1a85c:	55                   	push   %ebp
   1a85d:	e8 a8 e4 ff ff       	call   18d0a <Block_Write>
    return 0;
}
   1a862:	b8 00 00 00 00       	mov    $0x0,%eax
   1a867:	81 c4 2c 02 00 00    	add    $0x22c,%esp
   1a86d:	5b                   	pop    %ebx
   1a86e:	5e                   	pop    %esi
   1a86f:	5f                   	pop    %edi
   1a870:	5d                   	pop    %ebp
   1a871:	c3                   	ret    

0001a872 <Fat16_Mount>:

static
int
Fat16_Mount(struct Mount_Point* mountPoint) {
   1a872:	55                   	push   %ebp
   1a873:	57                   	push   %edi
   1a874:	56                   	push   %esi
   1a875:	53                   	push   %ebx
   1a876:	83 ec 28             	sub    $0x28,%esp
   1a879:	e8 94 59 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1a87e:	81 c3 82 b7 00 00    	add    $0xb782,%ebx
    Print(s);
   1a884:	8d 83 4b 8f ff ff    	lea    -0x70b5(%ebx),%eax
   1a88a:	50                   	push   %eax
   1a88b:	e8 4a 67 ff ff       	call   10fda <Print>
    Debug("Mounting\n");
    uint_t rc;
    Fat16_Fsinfo* info = (Fat16_Fsinfo*)Malloc(sizeof(Fat16_Fsinfo));
   1a890:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
   1a897:	e8 10 93 ff ff       	call   13bac <Malloc>
    if (!info) goto fail;
   1a89c:	83 c4 10             	add    $0x10,%esp
   1a89f:	85 c0                	test   %eax,%eax
   1a8a1:	74 65                	je     1a908 <Fat16_Mount+0x96>
   1a8a3:	89 c6                	mov    %eax,%esi
    Mutex_Init(&info->mutex);
   1a8a5:	83 ec 0c             	sub    $0xc,%esp
   1a8a8:	8d 40 28             	lea    0x28(%eax),%eax
   1a8ab:	50                   	push   %eax
   1a8ac:	e8 0e 97 ff ff       	call   13fbf <Mutex_Init>
    Print(s);
   1a8b1:	8d 83 55 8f ff ff    	lea    -0x70ab(%ebx),%eax
   1a8b7:	89 04 24             	mov    %eax,(%esp)
   1a8ba:	e8 1b 67 ff ff       	call   10fda <Print>
    
    Debug("Init boot sector\n");
    struct Block_Device* dev = mountPoint->dev;
   1a8bf:	8b 44 24 40          	mov    0x40(%esp),%eax
   1a8c3:	8b 68 08             	mov    0x8(%eax),%ebp
    Print("%p\n", dev);
   1a8c6:	83 c4 08             	add    $0x8,%esp
   1a8c9:	55                   	push   %ebp
   1a8ca:	8d bb 91 8f ff ff    	lea    -0x706f(%ebx),%edi
   1a8d0:	57                   	push   %edi
   1a8d1:	e8 04 67 ff ff       	call   10fda <Print>
    rc = Block_Read(dev, 0, &info->bSector);
   1a8d6:	83 c4 0c             	add    $0xc,%esp
   1a8d9:	89 74 24 08          	mov    %esi,0x8(%esp)
   1a8dd:	56                   	push   %esi
   1a8de:	6a 00                	push   $0x0
   1a8e0:	55                   	push   %ebp
   1a8e1:	e8 c1 e3 ff ff       	call   18ca7 <Block_Read>
   1a8e6:	89 c6                	mov    %eax,%esi
    Print("%p\n", dev);
   1a8e8:	83 c4 08             	add    $0x8,%esp
   1a8eb:	55                   	push   %ebp
   1a8ec:	57                   	push   %edi
   1a8ed:	e8 e8 66 ff ff       	call   10fda <Print>
    if (rc) goto fail;
   1a8f2:	83 c4 10             	add    $0x10,%esp
   1a8f5:	85 f6                	test   %esi,%esi
   1a8f7:	74 50                	je     1a949 <Fat16_Mount+0xd7>
    mountPoint->ops = fat16_mountPointOps;
    mountPoint->fsData = info;
    test(info);
    return 0;
fail:
    if (info) Free(info);
   1a8f9:	83 ec 0c             	sub    $0xc,%esp
   1a8fc:	ff 74 24 10          	pushl  0x10(%esp)
   1a900:	e8 25 94 ff ff       	call   13d2a <Free>
   1a905:	83 c4 10             	add    $0x10,%esp
    if (fat) Free(fat);
   1a908:	8b 44 24 08          	mov    0x8(%esp),%eax
   1a90c:	85 c0                	test   %eax,%eax
   1a90e:	74 0c                	je     1a91c <Fat16_Mount+0xaa>
   1a910:	83 ec 0c             	sub    $0xc,%esp
   1a913:	50                   	push   %eax
   1a914:	e8 11 94 ff ff       	call   13d2a <Free>
   1a919:	83 c4 10             	add    $0x10,%esp
    if (entries) Free(entries);
    return -1;
   1a91c:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
    if (entries) Free(entries);
   1a923:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a927:	85 c0                	test   %eax,%eax
   1a929:	74 13                	je     1a93e <Fat16_Mount+0xcc>
   1a92b:	83 ec 0c             	sub    $0xc,%esp
   1a92e:	50                   	push   %eax
   1a92f:	e8 f6 93 ff ff       	call   13d2a <Free>
   1a934:	83 c4 10             	add    $0x10,%esp
    return -1;
   1a937:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
}
   1a93e:	8b 04 24             	mov    (%esp),%eax
   1a941:	83 c4 1c             	add    $0x1c,%esp
   1a944:	5b                   	pop    %ebx
   1a945:	5e                   	pop    %esi
   1a946:	5f                   	pop    %edi
   1a947:	5d                   	pop    %ebp
   1a948:	c3                   	ret    
    Print("Read: file count: %d\n", info->bSector.rootEntryCount);
   1a949:	83 ec 08             	sub    $0x8,%esp
   1a94c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1a950:	0f bf 40 06          	movswl 0x6(%eax),%eax
   1a954:	50                   	push   %eax
   1a955:	8d 83 67 8f ff ff    	lea    -0x7099(%ebx),%eax
   1a95b:	50                   	push   %eax
   1a95c:	e8 79 66 ff ff       	call   10fda <Print>
    Print(s);
   1a961:	8d 83 7d 8f ff ff    	lea    -0x7083(%ebx),%eax
   1a967:	89 04 24             	mov    %eax,(%esp)
   1a96a:	e8 6b 66 ff ff       	call   10fda <Print>
    char* fat = (char*)Malloc(FAT16_TSIZE);
   1a96f:	c7 04 24 00 00 02 00 	movl   $0x20000,(%esp)
   1a976:	e8 31 92 ff ff       	call   13bac <Malloc>
   1a97b:	89 44 24 18          	mov    %eax,0x18(%esp)
    if (!fat) goto fail;
   1a97f:	83 c4 10             	add    $0x10,%esp
   1a982:	85 c0                	test   %eax,%eax
   1a984:	0f 84 6f ff ff ff    	je     1a8f9 <Fat16_Mount+0x87>
   1a98a:	89 c7                	mov    %eax,%edi
        Print("%d: %p\n", i, dev);
   1a98c:	8d 83 8d 8f ff ff    	lea    -0x7073(%ebx),%eax
   1a992:	89 04 24             	mov    %eax,(%esp)
   1a995:	83 ec 04             	sub    $0x4,%esp
   1a998:	55                   	push   %ebp
   1a999:	56                   	push   %esi
   1a99a:	ff 74 24 0c          	pushl  0xc(%esp)
   1a99e:	e8 37 66 ff ff       	call   10fda <Print>
        rc = Block_Read(dev, i+1, fat+SECTOR_SIZE*i);
   1a9a3:	83 c6 01             	add    $0x1,%esi
   1a9a6:	83 c4 0c             	add    $0xc,%esp
   1a9a9:	57                   	push   %edi
   1a9aa:	56                   	push   %esi
   1a9ab:	55                   	push   %ebp
   1a9ac:	e8 f6 e2 ff ff       	call   18ca7 <Block_Read>
        if (rc) goto fail;
   1a9b1:	83 c4 10             	add    $0x10,%esp
   1a9b4:	85 c0                	test   %eax,%eax
   1a9b6:	0f 85 3d ff ff ff    	jne    1a8f9 <Fat16_Mount+0x87>
    for (int i = 0; i < SECTOR_PER_FATT; i++) {
   1a9bc:	81 c7 00 02 00 00    	add    $0x200,%edi
   1a9c2:	81 fe 00 01 00 00    	cmp    $0x100,%esi
   1a9c8:	75 cb                	jne    1a995 <Fat16_Mount+0x123>
    info->fat = (short*)fat;
   1a9ca:	8b 7c 24 04          	mov    0x4(%esp),%edi
   1a9ce:	8b 44 24 08          	mov    0x8(%esp),%eax
   1a9d2:	89 47 1c             	mov    %eax,0x1c(%edi)
    info->maxFatBit = MAX_SECTOR;
   1a9d5:	c7 47 24 00 00 01 00 	movl   $0x10000,0x24(%edi)
    info->fatBitset = Create_Bit_Set(MAX_SECTOR);
   1a9dc:	83 ec 0c             	sub    $0xc,%esp
   1a9df:	68 00 00 01 00       	push   $0x10000
   1a9e4:	e8 13 01 00 00       	call   1aafc <Create_Bit_Set>
   1a9e9:	89 47 20             	mov    %eax,0x20(%edi)
    Print(s);
   1a9ec:	8d 83 95 8f ff ff    	lea    -0x706b(%ebx),%eax
   1a9f2:	89 04 24             	mov    %eax,(%esp)
   1a9f5:	e8 e0 65 ff ff       	call   10fda <Print>
    char* entries = (char*)Malloc(DIR_BLOCKS*SECTOR_SIZE);
   1a9fa:	c7 04 24 00 40 00 00 	movl   $0x4000,(%esp)
   1aa01:	e8 a6 91 ff ff       	call   13bac <Malloc>
   1aa06:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    if (!entries) goto fail;
   1aa0a:	83 c4 10             	add    $0x10,%esp
   1aa0d:	85 c0                	test   %eax,%eax
   1aa0f:	0f 84 e4 fe ff ff    	je     1a8f9 <Fat16_Mount+0x87>
   1aa15:	89 c7                	mov    %eax,%edi
   1aa17:	be 01 02 00 00       	mov    $0x201,%esi
        rc = Block_Read(dev, i+FIRST_DIR_BLOCK, entries+SECTOR_SIZE*i);
   1aa1c:	83 ec 04             	sub    $0x4,%esp
   1aa1f:	57                   	push   %edi
   1aa20:	56                   	push   %esi
   1aa21:	55                   	push   %ebp
   1aa22:	e8 80 e2 ff ff       	call   18ca7 <Block_Read>
        if (rc) goto fail;
   1aa27:	83 c4 10             	add    $0x10,%esp
   1aa2a:	85 c0                	test   %eax,%eax
   1aa2c:	0f 85 c7 fe ff ff    	jne    1a8f9 <Fat16_Mount+0x87>
    for (int i = 0; i < DIR_BLOCKS; i++) {
   1aa32:	83 c6 01             	add    $0x1,%esi
   1aa35:	81 c7 00 02 00 00    	add    $0x200,%edi
   1aa3b:	81 fe 21 02 00 00    	cmp    $0x221,%esi
   1aa41:	75 d9                	jne    1aa1c <Fat16_Mount+0x1aa>
   1aa43:	89 c7                	mov    %eax,%edi
   1aa45:	89 04 24             	mov    %eax,(%esp)
    info->entries = (DirEntry*)entries;
   1aa48:	8b 74 24 04          	mov    0x4(%esp),%esi
   1aa4c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1aa50:	89 46 10             	mov    %eax,0x10(%esi)
    info->maxEntryBit = MAX_DIR_COUNT;
   1aa53:	c7 46 18 49 02 00 00 	movl   $0x249,0x18(%esi)
    info->entryBitset = Create_Bit_Set(MAX_DIR_COUNT);
   1aa5a:	83 ec 0c             	sub    $0xc,%esp
   1aa5d:	68 49 02 00 00       	push   $0x249
   1aa62:	e8 95 00 00 00       	call   1aafc <Create_Bit_Set>
   1aa67:	89 f2                	mov    %esi,%edx
   1aa69:	89 46 14             	mov    %eax,0x14(%esi)
    mountPoint->ops = fat16_mountPointOps;
   1aa6c:	8b 83 7c 13 00 00    	mov    0x137c(%ebx),%eax
   1aa72:	8b 4c 24 40          	mov    0x40(%esp),%ecx
   1aa76:	89 01                	mov    %eax,(%ecx)
    mountPoint->fsData = info;
   1aa78:	89 71 0c             	mov    %esi,0xc(%ecx)
/**
 * Test Function
 */
static void test(Fat16_Fsinfo* info) {
#ifdef DEBUG_FAT16
    DirEntry* entries = info->entries;
   1aa7b:	8b 76 10             	mov    0x10(%esi),%esi
    uint_t count = info->bSector.rootEntryCount;
   1aa7e:	0f b7 42 06          	movzwl 0x6(%edx),%eax
    for (int i = 0; i < count; i++) {
   1aa82:	83 c4 10             	add    $0x10,%esp
   1aa85:	66 85 c0             	test   %ax,%ax
   1aa88:	0f 84 b0 fe ff ff    	je     1a93e <Fat16_Mount+0xcc>
   1aa8e:	98                   	cwtl   
   1aa8f:	89 44 24 04          	mov    %eax,0x4(%esp)
        DirEntry* entry = entries + i;
        Print("%d:  name: %s, size: %s\n", i, entry->name, entry->size);
   1aa93:	8d ab a4 8f ff ff    	lea    -0x705c(%ebx),%ebp
   1aa99:	ff 76 18             	pushl  0x18(%esi)
   1aa9c:	56                   	push   %esi
   1aa9d:	57                   	push   %edi
   1aa9e:	55                   	push   %ebp
   1aa9f:	e8 36 65 ff ff       	call   10fda <Print>
    for (int i = 0; i < count; i++) {
   1aaa4:	83 c7 01             	add    $0x1,%edi
   1aaa7:	83 c6 1c             	add    $0x1c,%esi
   1aaaa:	83 c4 10             	add    $0x10,%esp
   1aaad:	39 7c 24 04          	cmp    %edi,0x4(%esp)
   1aab1:	75 e6                	jne    1aa99 <Fat16_Mount+0x227>
   1aab3:	e9 86 fe ff ff       	jmp    1a93e <Fat16_Mount+0xcc>

0001aab8 <Debug>:
void Debug(char* s) {
   1aab8:	53                   	push   %ebx
   1aab9:	83 ec 14             	sub    $0x14,%esp
   1aabc:	e8 51 57 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1aac1:	81 c3 3f b5 00 00    	add    $0xb53f,%ebx
    Print(s);
   1aac7:	ff 74 24 1c          	pushl  0x1c(%esp)
   1aacb:	e8 0a 65 ff ff       	call   10fda <Print>
}
   1aad0:	83 c4 18             	add    $0x18,%esp
   1aad3:	5b                   	pop    %ebx
   1aad4:	c3                   	ret    

0001aad5 <Init_Fat16>:
Init_Fat16() {
   1aad5:	53                   	push   %ebx
   1aad6:	83 ec 10             	sub    $0x10,%esp
   1aad9:	e8 34 57 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1aade:	81 c3 22 b5 00 00    	add    $0xb522,%ebx
    Register_Filesystem("fat16", &fat16_FilesystemOps);
   1aae4:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
   1aaea:	50                   	push   %eax
   1aaeb:	8d 83 bd 8f ff ff    	lea    -0x7043(%ebx),%eax
   1aaf1:	50                   	push   %eax
   1aaf2:	e8 40 f1 ff ff       	call   19c37 <Register_Filesystem>
}
   1aaf7:	83 c4 18             	add    $0x18,%esp
   1aafa:	5b                   	pop    %ebx
   1aafb:	c3                   	ret    

0001aafc <Create_Bit_Set>:

#define FIND_NUM_BYTES(totalBits) \
    ((totalBits / 8) + ((totalBits % 8 != 0) ? 1 : 0))

void* Create_Bit_Set(uint_t totalBits)
{
   1aafc:	57                   	push   %edi
   1aafd:	56                   	push   %esi
   1aafe:	53                   	push   %ebx
   1aaff:	e8 0e 57 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1ab04:	81 c3 fc b4 00 00    	add    $0xb4fc,%ebx
   1ab0a:	8b 7c 24 10          	mov    0x10(%esp),%edi
    ulong_t numBytes;
    void *bitSet;

    numBytes = FIND_NUM_BYTES(totalBits);
   1ab0e:	f7 c7 07 00 00 00    	test   $0x7,%edi
   1ab14:	0f 95 c0             	setne  %al
   1ab17:	0f b6 c0             	movzbl %al,%eax
   1ab1a:	c1 ef 03             	shr    $0x3,%edi
   1ab1d:	01 c7                	add    %eax,%edi

    bitSet = Malloc(numBytes);
   1ab1f:	83 ec 0c             	sub    $0xc,%esp
   1ab22:	57                   	push   %edi
   1ab23:	e8 84 90 ff ff       	call   13bac <Malloc>
   1ab28:	89 c6                	mov    %eax,%esi
    if (bitSet != 0)
   1ab2a:	83 c4 10             	add    $0x10,%esp
   1ab2d:	85 c0                	test   %eax,%eax
   1ab2f:	74 0f                	je     1ab40 <Create_Bit_Set+0x44>
	memset(bitSet, '\0', numBytes);
   1ab31:	83 ec 04             	sub    $0x4,%esp
   1ab34:	57                   	push   %edi
   1ab35:	6a 00                	push   $0x0
   1ab37:	50                   	push   %eax
   1ab38:	e8 1e 1f 00 00       	call   1ca5b <memset>
   1ab3d:	83 c4 10             	add    $0x10,%esp

    return bitSet;
}
   1ab40:	89 f0                	mov    %esi,%eax
   1ab42:	5b                   	pop    %ebx
   1ab43:	5e                   	pop    %esi
   1ab44:	5f                   	pop    %edi
   1ab45:	c3                   	ret    

0001ab46 <Set_Bit>:

void Set_Bit(void *bitSet, uint_t bitPos)
{
   1ab46:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    ulong_t offset, bit;

    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab4a:	89 c8                	mov    %ecx,%eax
   1ab4c:	c1 e8 03             	shr    $0x3,%eax
    ((uchar_t*)bitSet)[offset] |= (1 << bit);
   1ab4f:	03 44 24 04          	add    0x4(%esp),%eax
    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab53:	83 e1 07             	and    $0x7,%ecx
    ((uchar_t*)bitSet)[offset] |= (1 << bit);
   1ab56:	ba 01 00 00 00       	mov    $0x1,%edx
   1ab5b:	d3 e2                	shl    %cl,%edx
   1ab5d:	08 10                	or     %dl,(%eax)
}
   1ab5f:	c3                   	ret    

0001ab60 <Clear_Bit>:

void Clear_Bit(void *bitSet, uint_t bitPos)
{
   1ab60:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    ulong_t offset, bit;

    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab64:	89 ca                	mov    %ecx,%edx
   1ab66:	c1 ea 03             	shr    $0x3,%edx
    ((uchar_t*)bitSet)[offset] &= ~(1 << bit);
   1ab69:	03 54 24 04          	add    0x4(%esp),%edx
    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab6d:	83 e1 07             	and    $0x7,%ecx
    ((uchar_t*)bitSet)[offset] &= ~(1 << bit);
   1ab70:	b8 01 00 00 00       	mov    $0x1,%eax
   1ab75:	d3 e0                	shl    %cl,%eax
   1ab77:	f7 d0                	not    %eax
   1ab79:	20 02                	and    %al,(%edx)
}
   1ab7b:	c3                   	ret    

0001ab7c <Is_Bit_Set>:

bool Is_Bit_Set(void *bitSet, uint_t bitPos)
{
   1ab7c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    ulong_t offset, bit;

    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab80:	89 c8                	mov    %ecx,%eax
   1ab82:	c1 e8 03             	shr    $0x3,%eax
    return (((uchar_t*)bitSet)[offset] & (1 << bit)) != 0;
   1ab85:	8b 54 24 04          	mov    0x4(%esp),%edx
   1ab89:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
    FIND_OFFSET_AND_BIT(bitPos, offset, bit);
   1ab8d:	83 e1 07             	and    $0x7,%ecx
    return (((uchar_t*)bitSet)[offset] & (1 << bit)) != 0;
   1ab90:	d3 f8                	sar    %cl,%eax
   1ab92:	83 e0 01             	and    $0x1,%eax
}
   1ab95:	c3                   	ret    

0001ab96 <Find_First_Free_Bit>:

int Find_First_Free_Bit(void *bitSet, ulong_t totalBits)
{
   1ab96:	56                   	push   %esi
   1ab97:	53                   	push   %ebx
   1ab98:	83 ec 04             	sub    $0x4,%esp
   1ab9b:	e8 72 56 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1aba0:	81 c3 60 b4 00 00    	add    $0xb460,%ebx
   1aba6:	8b 74 24 10          	mov    0x10(%esp),%esi
   1abaa:	8b 44 24 14          	mov    0x14(%esp),%eax
    uint_t numBytes = FIND_NUM_BYTES(totalBits);
   1abae:	a8 07                	test   $0x7,%al
   1abb0:	0f 95 c1             	setne  %cl
   1abb3:	0f b6 c9             	movzbl %cl,%ecx
   1abb6:	c1 e8 03             	shr    $0x3,%eax
    ulong_t offset;
    uchar_t *bits = (uchar_t*) bitSet;

    for (offset = 0; offset < numBytes; ++offset) {
   1abb9:	01 c1                	add    %eax,%ecx
   1abbb:	0f 84 85 00 00 00    	je     1ac46 <Find_First_Free_Bit+0xb0>
   1abc1:	b8 00 00 00 00       	mov    $0x0,%eax
	if (bits[offset] != 0xff) {
   1abc6:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
   1abca:	80 fa ff             	cmp    $0xff,%dl
   1abcd:	75 12                	jne    1abe1 <Find_First_Free_Bit+0x4b>
    for (offset = 0; offset < numBytes; ++offset) {
   1abcf:	83 c0 01             	add    $0x1,%eax
   1abd2:	39 c1                	cmp    %eax,%ecx
   1abd4:	75 f0                	jne    1abc6 <Find_First_Free_Bit+0x30>
	    }
	    KASSERT(false);
	}
    }

    return -1;
   1abd6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1abdb:	83 c4 04             	add    $0x4,%esp
   1abde:	5b                   	pop    %ebx
   1abdf:	5e                   	pop    %esi
   1abe0:	c3                   	ret    
		if ((bits[offset] & (1 << bit)) == 0)
   1abe1:	0f b6 ca             	movzbl %dl,%ecx
   1abe4:	f6 c2 01             	test   $0x1,%dl
   1abe7:	74 53                	je     1ac3c <Find_First_Free_Bit+0xa6>
	    for (bit = 0; bit < 8; ++bit) {
   1abe9:	ba 01 00 00 00       	mov    $0x1,%edx
		if ((bits[offset] & (1 << bit)) == 0)
   1abee:	0f a3 d1             	bt     %edx,%ecx
   1abf1:	73 4e                	jae    1ac41 <Find_First_Free_Bit+0xab>
	    for (bit = 0; bit < 8; ++bit) {
   1abf3:	83 c2 01             	add    $0x1,%edx
   1abf6:	83 fa 08             	cmp    $0x8,%edx
   1abf9:	75 f3                	jne    1abee <Find_First_Free_Bit+0x58>
	    KASSERT(false);
   1abfb:	83 ec 0c             	sub    $0xc,%esp
   1abfe:	6a 4f                	push   $0x4f
   1ac00:	e8 24 65 ff ff       	call   11129 <Set_Current_Attr>
   1ac05:	83 c4 0c             	add    $0xc,%esp
   1ac08:	c7 c0 90 77 02 00    	mov    $0x27790,%eax
   1ac0e:	ff 30                	pushl  (%eax)
   1ac10:	ff 74 24 14          	pushl  0x14(%esp)
   1ac14:	6a 4d                	push   $0x4d
   1ac16:	8d 83 c3 8f ff ff    	lea    -0x703d(%ebx),%eax
   1ac1c:	50                   	push   %eax
   1ac1d:	8d 83 ab 75 ff ff    	lea    -0x8a55(%ebx),%eax
   1ac23:	50                   	push   %eax
   1ac24:	8d 83 dc 8f ff ff    	lea    -0x7024(%ebx),%eax
   1ac2a:	50                   	push   %eax
   1ac2b:	8d 83 54 70 ff ff    	lea    -0x8fac(%ebx),%eax
   1ac31:	50                   	push   %eax
   1ac32:	e8 a3 63 ff ff       	call   10fda <Print>
   1ac37:	83 c4 20             	add    $0x20,%esp
   1ac3a:	eb fe                	jmp    1ac3a <Find_First_Free_Bit+0xa4>
	    for (bit = 0; bit < 8; ++bit) {
   1ac3c:	ba 00 00 00 00       	mov    $0x0,%edx
		    return (offset * 8) + bit;
   1ac41:	8d 04 c2             	lea    (%edx,%eax,8),%eax
   1ac44:	eb 95                	jmp    1abdb <Find_First_Free_Bit+0x45>
    return -1;
   1ac46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1ac4b:	eb 8e                	jmp    1abdb <Find_First_Free_Bit+0x45>

0001ac4d <Find_First_N_Free>:

/*
 * This is slow!!
 */
int Find_First_N_Free(void *bitSet, uint_t runLength, ulong_t totalBits)
{
   1ac4d:	55                   	push   %ebp
   1ac4e:	57                   	push   %edi
   1ac4f:	56                   	push   %esi
   1ac50:	53                   	push   %ebx
   1ac51:	83 ec 04             	sub    $0x4,%esp
   1ac54:	8b 7c 24 18          	mov    0x18(%esp),%edi
   1ac58:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
    uint_t i,j;

    for (i=0; i < totalBits - runLength; i++) {
   1ac5c:	8b 44 24 20          	mov    0x20(%esp),%eax
   1ac60:	29 e8                	sub    %ebp,%eax
   1ac62:	89 04 24             	mov    %eax,(%esp)
   1ac65:	74 59                	je     1acc0 <Find_First_N_Free+0x73>
   1ac67:	be 00 00 00 00       	mov    $0x0,%esi
   1ac6c:	eb 11                	jmp    1ac7f <Find_First_N_Free+0x32>
        if (!Is_Bit_Set(bitSet, i)) {
	    for (j=1; j < runLength; j++) {
   1ac6e:	bb 01 00 00 00       	mov    $0x1,%ebx
	        if (Is_Bit_Set(bitSet, i+j)) {
		    break;
		}
	    }
	    if (j == runLength) {
   1ac73:	39 dd                	cmp    %ebx,%ebp
   1ac75:	74 38                	je     1acaf <Find_First_N_Free+0x62>
    for (i=0; i < totalBits - runLength; i++) {
   1ac77:	83 c6 01             	add    $0x1,%esi
   1ac7a:	3b 34 24             	cmp    (%esp),%esi
   1ac7d:	74 34                	je     1acb3 <Find_First_N_Free+0x66>
        if (!Is_Bit_Set(bitSet, i)) {
   1ac7f:	56                   	push   %esi
   1ac80:	57                   	push   %edi
   1ac81:	e8 f6 fe ff ff       	call   1ab7c <Is_Bit_Set>
   1ac86:	83 c4 08             	add    $0x8,%esp
   1ac89:	84 c0                	test   %al,%al
   1ac8b:	75 ea                	jne    1ac77 <Find_First_N_Free+0x2a>
	    for (j=1; j < runLength; j++) {
   1ac8d:	83 fd 01             	cmp    $0x1,%ebp
   1ac90:	76 dc                	jbe    1ac6e <Find_First_N_Free+0x21>
   1ac92:	bb 01 00 00 00       	mov    $0x1,%ebx
	        if (Is_Bit_Set(bitSet, i+j)) {
   1ac97:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
   1ac9a:	50                   	push   %eax
   1ac9b:	57                   	push   %edi
   1ac9c:	e8 db fe ff ff       	call   1ab7c <Is_Bit_Set>
   1aca1:	83 c4 08             	add    $0x8,%esp
   1aca4:	84 c0                	test   %al,%al
   1aca6:	75 cb                	jne    1ac73 <Find_First_N_Free+0x26>
	    for (j=1; j < runLength; j++) {
   1aca8:	83 c3 01             	add    $0x1,%ebx
   1acab:	39 dd                	cmp    %ebx,%ebp
   1acad:	75 e8                	jne    1ac97 <Find_First_N_Free+0x4a>
	        return i;
   1acaf:	89 f0                	mov    %esi,%eax
   1acb1:	eb 05                	jmp    1acb8 <Find_First_N_Free+0x6b>
	    }
	}
    }
    return -1;
   1acb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1acb8:	83 c4 04             	add    $0x4,%esp
   1acbb:	5b                   	pop    %ebx
   1acbc:	5e                   	pop    %esi
   1acbd:	5f                   	pop    %edi
   1acbe:	5d                   	pop    %ebp
   1acbf:	c3                   	ret    
    return -1;
   1acc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1acc5:	eb f1                	jmp    1acb8 <Find_First_N_Free+0x6b>

0001acc7 <Destroy_Bit_Set>:

void Destroy_Bit_Set(void *bitSet)
{
   1acc7:	53                   	push   %ebx
   1acc8:	83 ec 14             	sub    $0x14,%esp
   1accb:	e8 42 55 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1acd0:	81 c3 30 b3 00 00    	add    $0xb330,%ebx
    Free(bitSet);
   1acd6:	ff 74 24 1c          	pushl  0x1c(%esp)
   1acda:	e8 4b 90 ff ff       	call   13d2a <Free>
}
   1acdf:	83 c4 18             	add    $0x18,%esp
   1ace2:	5b                   	pop    %ebx
   1ace3:	c3                   	ret    

0001ace4 <Main>:
 * Kernel C code entry point.
 * Initializes kernel subsystems, mounts filesystems,
 * and spawns init process.
 */
void Main(struct Boot_Info* bootInfo)
{
   1ace4:	53                   	push   %ebx
   1ace5:	83 ec 08             	sub    $0x8,%esp
   1ace8:	e8 25 55 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1aced:	81 c3 13 b3 00 00    	add    $0xb313,%ebx
    Init_BSS();
   1acf3:	e8 31 79 ff ff       	call   12629 <Init_BSS>
    Init_Screen();
   1acf8:	e8 45 6a ff ff       	call   11742 <Init_Screen>
    Init_Mem(bootInfo);
   1acfd:	83 ec 0c             	sub    $0xc,%esp
   1ad00:	ff 74 24 1c          	pushl  0x1c(%esp)
   1ad04:	e8 93 77 ff ff       	call   1249c <Init_Mem>
    Init_CRC32();
   1ad09:	e8 69 7d ff ff       	call   12a77 <Init_CRC32>
    Init_TSS();
   1ad0e:	e8 95 82 ff ff       	call   12fa8 <Init_TSS>
    Init_Interrupts();
   1ad13:	e8 53 55 ff ff       	call   1026b <Init_Interrupts>
    Init_Scheduler();
   1ad18:	e8 a2 a1 ff ff       	call   14ebf <Init_Scheduler>
    Init_Traps();
   1ad1d:	e8 6e 57 ff ff       	call   10490 <Init_Traps>
    Init_Timer();
   1ad22:	e8 97 73 ff ff       	call   120be <Init_Timer>
    Init_Keyboard();
   1ad27:	e8 92 5d ff ff       	call   10abe <Init_Keyboard>
    Init_DMA();
   1ad2c:	e8 5b c3 ff ff       	call   1708c <Init_DMA>
    Init_Floppy();
   1ad31:	e8 c5 d4 ff ff       	call   181fb <Init_Floppy>
    Init_IDE();
   1ad36:	e8 22 ea ff ff       	call   1975d <Init_IDE>
    Init_Fat16();
   1ad3b:	e8 95 fd ff ff       	call   1aad5 <Init_Fat16>



static void Mount_Root_Filesystem(void)
{
    if (Mount(ROOT_DEVICE, ROOT_PREFIX, "fat16") != 0)
   1ad40:	83 c4 0c             	add    $0xc,%esp
   1ad43:	8d 83 bd 8f ff ff    	lea    -0x7043(%ebx),%eax
   1ad49:	50                   	push   %eax
   1ad4a:	8d 83 2d 79 ff ff    	lea    -0x86d3(%ebx),%eax
   1ad50:	50                   	push   %eax
   1ad51:	8d 83 f0 8f ff ff    	lea    -0x7010(%ebx),%eax
   1ad57:	50                   	push   %eax
   1ad58:	e8 b8 f1 ff ff       	call   19f15 <Mount>
   1ad5d:	83 c4 10             	add    $0x10,%esp
   1ad60:	85 c0                	test   %eax,%eax
   1ad62:	74 3b                	je     1ad9f <Main+0xbb>
	Print("Failed to mount /" ROOT_PREFIX " filesystem\n");
   1ad64:	83 ec 0c             	sub    $0xc,%esp
   1ad67:	8d 83 24 90 ff ff    	lea    -0x6fdc(%ebx),%eax
   1ad6d:	50                   	push   %eax
   1ad6e:	e8 67 62 ff ff       	call   10fda <Print>
   1ad73:	83 c4 10             	add    $0x10,%esp
    Set_Current_Attr(ATTRIB(BLACK, GREEN|BRIGHT));
   1ad76:	83 ec 0c             	sub    $0xc,%esp
   1ad79:	6a 0a                	push   $0xa
   1ad7b:	e8 a9 63 ff ff       	call   11129 <Set_Current_Attr>
    Print("Welcome to GeekOS!\n");
   1ad80:	8d 83 0d 90 ff ff    	lea    -0x6ff3(%ebx),%eax
   1ad86:	89 04 24             	mov    %eax,(%esp)
   1ad89:	e8 4c 62 ff ff       	call   10fda <Print>
    Set_Current_Attr(ATTRIB(BLACK, GRAY));
   1ad8e:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
   1ad95:	e8 8f 63 ff ff       	call   11129 <Set_Current_Attr>
   1ad9a:	83 c4 10             	add    $0x10,%esp
    while(1);
   1ad9d:	eb fe                	jmp    1ad9d <Main+0xb9>
    else
	Print("Mounted /" ROOT_PREFIX " filesystem!\n");
   1ad9f:	83 ec 0c             	sub    $0xc,%esp
   1ada2:	8d 83 f5 8f ff ff    	lea    -0x700b(%ebx),%eax
   1ada8:	50                   	push   %eax
   1ada9:	e8 2c 62 ff ff       	call   10fda <Print>
   1adae:	83 c4 10             	add    $0x10,%esp
   1adb1:	eb c3                	jmp    1ad76 <Main+0x92>
   1adb3:	66 90                	xchg   %ax,%ax
   1adb5:	66 90                	xchg   %ax,%ax
   1adb7:	66 90                	xchg   %ax,%ax
   1adb9:	66 90                	xchg   %ax,%ax
   1adbb:	66 90                	xchg   %ax,%ax
   1adbd:	66 90                	xchg   %ax,%ax
   1adbf:	90                   	nop

0001adc0 <Load_IDTR>:
   1adc0:	8b 44 24 04          	mov    0x4(%esp),%eax
   1adc4:	0f 01 18             	lidtl  (%eax)
   1adc7:	c3                   	ret    

0001adc8 <Load_GDTR>:
   1adc8:	8b 44 24 04          	mov    0x4(%esp),%eax
   1adcc:	0f 01 10             	lgdtl  (%eax)
   1adcf:	66 b8 10 00          	mov    $0x10,%ax
   1add3:	8e d8                	mov    %eax,%ds
   1add5:	8e c0                	mov    %eax,%es
   1add7:	8e e0                	mov    %eax,%fs
   1add9:	8e e8                	mov    %eax,%gs
   1addb:	8e d0                	mov    %eax,%ss
   1addd:	ea e4 ad 01 00 08 00 	ljmp   $0x8,$0x1ade4

0001ade4 <Load_GDTR.here>:
   1ade4:	c3                   	ret    
   1ade5:	90                   	nop
   1ade6:	90                   	nop
   1ade7:	90                   	nop

0001ade8 <Load_LDTR>:
   1ade8:	8b 44 24 04          	mov    0x4(%esp),%eax
   1adec:	0f 00 d0             	lldt   %ax
   1adef:	c3                   	ret    

0001adf0 <Handle_Interrupt>:
   1adf0:	50                   	push   %eax
   1adf1:	53                   	push   %ebx
   1adf2:	51                   	push   %ecx
   1adf3:	52                   	push   %edx
   1adf4:	56                   	push   %esi
   1adf5:	57                   	push   %edi
   1adf6:	55                   	push   %ebp
   1adf7:	1e                   	push   %ds
   1adf8:	06                   	push   %es
   1adf9:	0f a0                	push   %fs
   1adfb:	0f a8                	push   %gs
   1adfd:	66 b8 10 00          	mov    $0x10,%ax
   1ae01:	8e d8                	mov    %eax,%ds
   1ae03:	8e c0                	mov    %eax,%es
   1ae05:	b8 80 73 02 00       	mov    $0x27380,%eax
   1ae0a:	8b 74 24 2c          	mov    0x2c(%esp),%esi
   1ae0e:	8b 1c b0             	mov    (%eax,%esi,4),%ebx
   1ae11:	54                   	push   %esp
   1ae12:	ff d3                	call   *%ebx
   1ae14:	81 c4 04 00 00 00    	add    $0x4,%esp
   1ae1a:	81 3d 8c 77 02 00 00 	cmpl   $0x0,0x2778c
   1ae21:	00 00 00 
   1ae24:	75 41                	jne    1ae67 <Handle_Interrupt.restore>
   1ae26:	81 3d 94 77 02 00 00 	cmpl   $0x0,0x27794
   1ae2d:	00 00 00 
   1ae30:	74 35                	je     1ae67 <Handle_Interrupt.restore>
   1ae32:	ff 35 90 77 02 00    	pushl  0x27790
   1ae38:	e8 86 9d ff ff       	call   14bc3 <Make_Runnable>
   1ae3d:	81 c4 04 00 00 00    	add    $0x4,%esp
   1ae43:	a1 90 77 02 00       	mov    0x27790,%eax
   1ae48:	89 20                	mov    %esp,(%eax)
   1ae4a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1ae51:	e8 1b a2 ff ff       	call   15071 <Get_Next_Runnable>
   1ae56:	a3 90 77 02 00       	mov    %eax,0x27790
   1ae5b:	8b 20                	mov    (%eax),%esp
   1ae5d:	c7 05 94 77 02 00 00 	movl   $0x0,0x27794
   1ae64:	00 00 00 

0001ae67 <Handle_Interrupt.restore>:
   1ae67:	54                   	push   %esp
   1ae68:	ff 35 90 77 02 00    	pushl  0x27790
   1ae6e:	e8 d6 b8 ff ff       	call   16749 <Switch_To_User_Context>
   1ae73:	81 c4 08 00 00 00    	add    $0x8,%esp
   1ae79:	0f a9                	pop    %gs
   1ae7b:	0f a1                	pop    %fs
   1ae7d:	07                   	pop    %es
   1ae7e:	1f                   	pop    %ds
   1ae7f:	5d                   	pop    %ebp
   1ae80:	5f                   	pop    %edi
   1ae81:	5e                   	pop    %esi
   1ae82:	5a                   	pop    %edx
   1ae83:	59                   	pop    %ecx
   1ae84:	5b                   	pop    %ebx
   1ae85:	58                   	pop    %eax
   1ae86:	81 c4 08 00 00 00    	add    $0x8,%esp
   1ae8c:	cf                   	iret   
   1ae8d:	90                   	nop
   1ae8e:	90                   	nop
   1ae8f:	90                   	nop

0001ae90 <Switch_To_Thread>:
   1ae90:	50                   	push   %eax
   1ae91:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ae95:	89 44 24 fc          	mov    %eax,-0x4(%esp)
   1ae99:	81 c4 08 00 00 00    	add    $0x8,%esp
   1ae9f:	9c                   	pushf  
   1aea0:	8b 44 24 fc          	mov    -0x4(%esp),%eax
   1aea4:	68 08 00 00 00       	push   $0x8
   1aea9:	81 ec 04 00 00 00    	sub    $0x4,%esp
   1aeaf:	68 00 00 00 00       	push   $0x0
   1aeb4:	68 00 00 00 00       	push   $0x0
   1aeb9:	50                   	push   %eax
   1aeba:	53                   	push   %ebx
   1aebb:	51                   	push   %ecx
   1aebc:	52                   	push   %edx
   1aebd:	56                   	push   %esi
   1aebe:	57                   	push   %edi
   1aebf:	55                   	push   %ebp
   1aec0:	1e                   	push   %ds
   1aec1:	06                   	push   %es
   1aec2:	0f a0                	push   %fs
   1aec4:	0f a8                	push   %gs
   1aec6:	a1 90 77 02 00       	mov    0x27790,%eax
   1aecb:	89 20                	mov    %esp,(%eax)
   1aecd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1aed4:	8b 44 24 40          	mov    0x40(%esp),%eax
   1aed8:	a3 90 77 02 00       	mov    %eax,0x27790
   1aedd:	8b 20                	mov    (%eax),%esp
   1aedf:	54                   	push   %esp
   1aee0:	ff 35 90 77 02 00    	pushl  0x27790
   1aee6:	e8 5e b8 ff ff       	call   16749 <Switch_To_User_Context>
   1aeeb:	81 c4 08 00 00 00    	add    $0x8,%esp
   1aef1:	0f a9                	pop    %gs
   1aef3:	0f a1                	pop    %fs
   1aef5:	07                   	pop    %es
   1aef6:	1f                   	pop    %ds
   1aef7:	5d                   	pop    %ebp
   1aef8:	5f                   	pop    %edi
   1aef9:	5e                   	pop    %esi
   1aefa:	5a                   	pop    %edx
   1aefb:	59                   	pop    %ecx
   1aefc:	5b                   	pop    %ebx
   1aefd:	58                   	pop    %eax
   1aefe:	81 c4 08 00 00 00    	add    $0x8,%esp
   1af04:	cf                   	iret   
   1af05:	90                   	nop
   1af06:	90                   	nop
   1af07:	90                   	nop
   1af08:	90                   	nop
   1af09:	90                   	nop
   1af0a:	90                   	nop
   1af0b:	90                   	nop
   1af0c:	90                   	nop
   1af0d:	90                   	nop
   1af0e:	90                   	nop
   1af0f:	90                   	nop

0001af10 <Get_Current_EFLAGS>:
   1af10:	9c                   	pushf  
   1af11:	58                   	pop    %eax
   1af12:	c3                   	ret    
   1af13:	90                   	nop
   1af14:	90                   	nop
   1af15:	90                   	nop
   1af16:	90                   	nop
   1af17:	90                   	nop

0001af18 <g_entryPointTableStart>:
   1af18:	68 00 00 00 00       	push   $0x0
   1af1d:	68 00 00 00 00       	push   $0x0
   1af22:	e9 c9 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af27:	90                   	nop

0001af28 <Before_No_Err>:
   1af28:	68 00 00 00 00       	push   $0x0
   1af2d:	68 01 00 00 00       	push   $0x1
   1af32:	e9 b9 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af37:	90                   	nop

0001af38 <After_No_Err>:
   1af38:	68 00 00 00 00       	push   $0x0
   1af3d:	68 02 00 00 00       	push   $0x2
   1af42:	e9 a9 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af47:	90                   	nop
   1af48:	68 00 00 00 00       	push   $0x0
   1af4d:	68 03 00 00 00       	push   $0x3
   1af52:	e9 99 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af57:	90                   	nop
   1af58:	68 00 00 00 00       	push   $0x0
   1af5d:	68 04 00 00 00       	push   $0x4
   1af62:	e9 89 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af67:	90                   	nop
   1af68:	68 00 00 00 00       	push   $0x0
   1af6d:	68 05 00 00 00       	push   $0x5
   1af72:	e9 79 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af77:	90                   	nop
   1af78:	68 00 00 00 00       	push   $0x0
   1af7d:	68 06 00 00 00       	push   $0x6
   1af82:	e9 69 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af87:	90                   	nop
   1af88:	68 00 00 00 00       	push   $0x0
   1af8d:	68 07 00 00 00       	push   $0x7
   1af92:	e9 59 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1af97:	90                   	nop

0001af98 <Before_Err>:
   1af98:	68 08 00 00 00       	push   $0x8
   1af9d:	e9 4e fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1afa2:	90                   	nop
   1afa3:	90                   	nop
   1afa4:	90                   	nop
   1afa5:	90                   	nop
   1afa6:	90                   	nop
   1afa7:	90                   	nop

0001afa8 <After_Err>:
   1afa8:	68 00 00 00 00       	push   $0x0
   1afad:	68 09 00 00 00       	push   $0x9
   1afb2:	e9 39 fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1afb7:	90                   	nop
   1afb8:	68 0a 00 00 00       	push   $0xa
   1afbd:	e9 2e fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1afc2:	90                   	nop
   1afc3:	90                   	nop
   1afc4:	90                   	nop
   1afc5:	90                   	nop
   1afc6:	90                   	nop
   1afc7:	90                   	nop
   1afc8:	68 0b 00 00 00       	push   $0xb
   1afcd:	e9 1e fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1afd2:	90                   	nop
   1afd3:	90                   	nop
   1afd4:	90                   	nop
   1afd5:	90                   	nop
   1afd6:	90                   	nop
   1afd7:	90                   	nop
   1afd8:	68 0c 00 00 00       	push   $0xc
   1afdd:	e9 0e fe ff ff       	jmp    1adf0 <Handle_Interrupt>
   1afe2:	90                   	nop
   1afe3:	90                   	nop
   1afe4:	90                   	nop
   1afe5:	90                   	nop
   1afe6:	90                   	nop
   1afe7:	90                   	nop
   1afe8:	68 0d 00 00 00       	push   $0xd
   1afed:	e9 fe fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1aff2:	90                   	nop
   1aff3:	90                   	nop
   1aff4:	90                   	nop
   1aff5:	90                   	nop
   1aff6:	90                   	nop
   1aff7:	90                   	nop
   1aff8:	68 0e 00 00 00       	push   $0xe
   1affd:	e9 ee fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b002:	90                   	nop
   1b003:	90                   	nop
   1b004:	90                   	nop
   1b005:	90                   	nop
   1b006:	90                   	nop
   1b007:	90                   	nop
   1b008:	68 00 00 00 00       	push   $0x0
   1b00d:	68 0f 00 00 00       	push   $0xf
   1b012:	e9 d9 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b017:	90                   	nop
   1b018:	68 00 00 00 00       	push   $0x0
   1b01d:	68 10 00 00 00       	push   $0x10
   1b022:	e9 c9 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b027:	90                   	nop
   1b028:	68 11 00 00 00       	push   $0x11
   1b02d:	e9 be fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b032:	90                   	nop
   1b033:	90                   	nop
   1b034:	90                   	nop
   1b035:	90                   	nop
   1b036:	90                   	nop
   1b037:	90                   	nop
   1b038:	68 00 00 00 00       	push   $0x0
   1b03d:	68 12 00 00 00       	push   $0x12
   1b042:	e9 a9 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b047:	90                   	nop
   1b048:	68 00 00 00 00       	push   $0x0
   1b04d:	68 13 00 00 00       	push   $0x13
   1b052:	e9 99 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b057:	90                   	nop
   1b058:	68 00 00 00 00       	push   $0x0
   1b05d:	68 14 00 00 00       	push   $0x14
   1b062:	e9 89 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b067:	90                   	nop
   1b068:	68 00 00 00 00       	push   $0x0
   1b06d:	68 15 00 00 00       	push   $0x15
   1b072:	e9 79 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b077:	90                   	nop
   1b078:	68 00 00 00 00       	push   $0x0
   1b07d:	68 16 00 00 00       	push   $0x16
   1b082:	e9 69 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b087:	90                   	nop
   1b088:	68 00 00 00 00       	push   $0x0
   1b08d:	68 17 00 00 00       	push   $0x17
   1b092:	e9 59 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b097:	90                   	nop
   1b098:	68 00 00 00 00       	push   $0x0
   1b09d:	68 18 00 00 00       	push   $0x18
   1b0a2:	e9 49 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0a7:	90                   	nop
   1b0a8:	68 00 00 00 00       	push   $0x0
   1b0ad:	68 19 00 00 00       	push   $0x19
   1b0b2:	e9 39 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0b7:	90                   	nop
   1b0b8:	68 00 00 00 00       	push   $0x0
   1b0bd:	68 1a 00 00 00       	push   $0x1a
   1b0c2:	e9 29 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0c7:	90                   	nop
   1b0c8:	68 00 00 00 00       	push   $0x0
   1b0cd:	68 1b 00 00 00       	push   $0x1b
   1b0d2:	e9 19 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0d7:	90                   	nop
   1b0d8:	68 00 00 00 00       	push   $0x0
   1b0dd:	68 1c 00 00 00       	push   $0x1c
   1b0e2:	e9 09 fd ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0e7:	90                   	nop
   1b0e8:	68 00 00 00 00       	push   $0x0
   1b0ed:	68 1d 00 00 00       	push   $0x1d
   1b0f2:	e9 f9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b0f7:	90                   	nop
   1b0f8:	68 00 00 00 00       	push   $0x0
   1b0fd:	68 1e 00 00 00       	push   $0x1e
   1b102:	e9 e9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b107:	90                   	nop
   1b108:	68 00 00 00 00       	push   $0x0
   1b10d:	68 1f 00 00 00       	push   $0x1f
   1b112:	e9 d9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b117:	90                   	nop
   1b118:	68 00 00 00 00       	push   $0x0
   1b11d:	68 20 00 00 00       	push   $0x20
   1b122:	e9 c9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b127:	90                   	nop
   1b128:	68 00 00 00 00       	push   $0x0
   1b12d:	68 21 00 00 00       	push   $0x21
   1b132:	e9 b9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b137:	90                   	nop
   1b138:	68 00 00 00 00       	push   $0x0
   1b13d:	68 22 00 00 00       	push   $0x22
   1b142:	e9 a9 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b147:	90                   	nop
   1b148:	68 00 00 00 00       	push   $0x0
   1b14d:	68 23 00 00 00       	push   $0x23
   1b152:	e9 99 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b157:	90                   	nop
   1b158:	68 00 00 00 00       	push   $0x0
   1b15d:	68 24 00 00 00       	push   $0x24
   1b162:	e9 89 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b167:	90                   	nop
   1b168:	68 00 00 00 00       	push   $0x0
   1b16d:	68 25 00 00 00       	push   $0x25
   1b172:	e9 79 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b177:	90                   	nop
   1b178:	68 00 00 00 00       	push   $0x0
   1b17d:	68 26 00 00 00       	push   $0x26
   1b182:	e9 69 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b187:	90                   	nop
   1b188:	68 00 00 00 00       	push   $0x0
   1b18d:	68 27 00 00 00       	push   $0x27
   1b192:	e9 59 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b197:	90                   	nop
   1b198:	68 00 00 00 00       	push   $0x0
   1b19d:	68 28 00 00 00       	push   $0x28
   1b1a2:	e9 49 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1a7:	90                   	nop
   1b1a8:	68 00 00 00 00       	push   $0x0
   1b1ad:	68 29 00 00 00       	push   $0x29
   1b1b2:	e9 39 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1b7:	90                   	nop
   1b1b8:	68 00 00 00 00       	push   $0x0
   1b1bd:	68 2a 00 00 00       	push   $0x2a
   1b1c2:	e9 29 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1c7:	90                   	nop
   1b1c8:	68 00 00 00 00       	push   $0x0
   1b1cd:	68 2b 00 00 00       	push   $0x2b
   1b1d2:	e9 19 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1d7:	90                   	nop
   1b1d8:	68 00 00 00 00       	push   $0x0
   1b1dd:	68 2c 00 00 00       	push   $0x2c
   1b1e2:	e9 09 fc ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1e7:	90                   	nop
   1b1e8:	68 00 00 00 00       	push   $0x0
   1b1ed:	68 2d 00 00 00       	push   $0x2d
   1b1f2:	e9 f9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b1f7:	90                   	nop
   1b1f8:	68 00 00 00 00       	push   $0x0
   1b1fd:	68 2e 00 00 00       	push   $0x2e
   1b202:	e9 e9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b207:	90                   	nop
   1b208:	68 00 00 00 00       	push   $0x0
   1b20d:	68 2f 00 00 00       	push   $0x2f
   1b212:	e9 d9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b217:	90                   	nop
   1b218:	68 00 00 00 00       	push   $0x0
   1b21d:	68 30 00 00 00       	push   $0x30
   1b222:	e9 c9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b227:	90                   	nop
   1b228:	68 00 00 00 00       	push   $0x0
   1b22d:	68 31 00 00 00       	push   $0x31
   1b232:	e9 b9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b237:	90                   	nop
   1b238:	68 00 00 00 00       	push   $0x0
   1b23d:	68 32 00 00 00       	push   $0x32
   1b242:	e9 a9 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b247:	90                   	nop
   1b248:	68 00 00 00 00       	push   $0x0
   1b24d:	68 33 00 00 00       	push   $0x33
   1b252:	e9 99 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b257:	90                   	nop
   1b258:	68 00 00 00 00       	push   $0x0
   1b25d:	68 34 00 00 00       	push   $0x34
   1b262:	e9 89 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b267:	90                   	nop
   1b268:	68 00 00 00 00       	push   $0x0
   1b26d:	68 35 00 00 00       	push   $0x35
   1b272:	e9 79 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b277:	90                   	nop
   1b278:	68 00 00 00 00       	push   $0x0
   1b27d:	68 36 00 00 00       	push   $0x36
   1b282:	e9 69 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b287:	90                   	nop
   1b288:	68 00 00 00 00       	push   $0x0
   1b28d:	68 37 00 00 00       	push   $0x37
   1b292:	e9 59 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b297:	90                   	nop
   1b298:	68 00 00 00 00       	push   $0x0
   1b29d:	68 38 00 00 00       	push   $0x38
   1b2a2:	e9 49 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2a7:	90                   	nop
   1b2a8:	68 00 00 00 00       	push   $0x0
   1b2ad:	68 39 00 00 00       	push   $0x39
   1b2b2:	e9 39 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2b7:	90                   	nop
   1b2b8:	68 00 00 00 00       	push   $0x0
   1b2bd:	68 3a 00 00 00       	push   $0x3a
   1b2c2:	e9 29 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2c7:	90                   	nop
   1b2c8:	68 00 00 00 00       	push   $0x0
   1b2cd:	68 3b 00 00 00       	push   $0x3b
   1b2d2:	e9 19 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2d7:	90                   	nop
   1b2d8:	68 00 00 00 00       	push   $0x0
   1b2dd:	68 3c 00 00 00       	push   $0x3c
   1b2e2:	e9 09 fb ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2e7:	90                   	nop
   1b2e8:	68 00 00 00 00       	push   $0x0
   1b2ed:	68 3d 00 00 00       	push   $0x3d
   1b2f2:	e9 f9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b2f7:	90                   	nop
   1b2f8:	68 00 00 00 00       	push   $0x0
   1b2fd:	68 3e 00 00 00       	push   $0x3e
   1b302:	e9 e9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b307:	90                   	nop
   1b308:	68 00 00 00 00       	push   $0x0
   1b30d:	68 3f 00 00 00       	push   $0x3f
   1b312:	e9 d9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b317:	90                   	nop
   1b318:	68 00 00 00 00       	push   $0x0
   1b31d:	68 40 00 00 00       	push   $0x40
   1b322:	e9 c9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b327:	90                   	nop
   1b328:	68 00 00 00 00       	push   $0x0
   1b32d:	68 41 00 00 00       	push   $0x41
   1b332:	e9 b9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b337:	90                   	nop
   1b338:	68 00 00 00 00       	push   $0x0
   1b33d:	68 42 00 00 00       	push   $0x42
   1b342:	e9 a9 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b347:	90                   	nop
   1b348:	68 00 00 00 00       	push   $0x0
   1b34d:	68 43 00 00 00       	push   $0x43
   1b352:	e9 99 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b357:	90                   	nop
   1b358:	68 00 00 00 00       	push   $0x0
   1b35d:	68 44 00 00 00       	push   $0x44
   1b362:	e9 89 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b367:	90                   	nop
   1b368:	68 00 00 00 00       	push   $0x0
   1b36d:	68 45 00 00 00       	push   $0x45
   1b372:	e9 79 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b377:	90                   	nop
   1b378:	68 00 00 00 00       	push   $0x0
   1b37d:	68 46 00 00 00       	push   $0x46
   1b382:	e9 69 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b387:	90                   	nop
   1b388:	68 00 00 00 00       	push   $0x0
   1b38d:	68 47 00 00 00       	push   $0x47
   1b392:	e9 59 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b397:	90                   	nop
   1b398:	68 00 00 00 00       	push   $0x0
   1b39d:	68 48 00 00 00       	push   $0x48
   1b3a2:	e9 49 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3a7:	90                   	nop
   1b3a8:	68 00 00 00 00       	push   $0x0
   1b3ad:	68 49 00 00 00       	push   $0x49
   1b3b2:	e9 39 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3b7:	90                   	nop
   1b3b8:	68 00 00 00 00       	push   $0x0
   1b3bd:	68 4a 00 00 00       	push   $0x4a
   1b3c2:	e9 29 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3c7:	90                   	nop
   1b3c8:	68 00 00 00 00       	push   $0x0
   1b3cd:	68 4b 00 00 00       	push   $0x4b
   1b3d2:	e9 19 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3d7:	90                   	nop
   1b3d8:	68 00 00 00 00       	push   $0x0
   1b3dd:	68 4c 00 00 00       	push   $0x4c
   1b3e2:	e9 09 fa ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3e7:	90                   	nop
   1b3e8:	68 00 00 00 00       	push   $0x0
   1b3ed:	68 4d 00 00 00       	push   $0x4d
   1b3f2:	e9 f9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b3f7:	90                   	nop
   1b3f8:	68 00 00 00 00       	push   $0x0
   1b3fd:	68 4e 00 00 00       	push   $0x4e
   1b402:	e9 e9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b407:	90                   	nop
   1b408:	68 00 00 00 00       	push   $0x0
   1b40d:	68 4f 00 00 00       	push   $0x4f
   1b412:	e9 d9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b417:	90                   	nop
   1b418:	68 00 00 00 00       	push   $0x0
   1b41d:	68 50 00 00 00       	push   $0x50
   1b422:	e9 c9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b427:	90                   	nop
   1b428:	68 00 00 00 00       	push   $0x0
   1b42d:	68 51 00 00 00       	push   $0x51
   1b432:	e9 b9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b437:	90                   	nop
   1b438:	68 00 00 00 00       	push   $0x0
   1b43d:	68 52 00 00 00       	push   $0x52
   1b442:	e9 a9 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b447:	90                   	nop
   1b448:	68 00 00 00 00       	push   $0x0
   1b44d:	68 53 00 00 00       	push   $0x53
   1b452:	e9 99 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b457:	90                   	nop
   1b458:	68 00 00 00 00       	push   $0x0
   1b45d:	68 54 00 00 00       	push   $0x54
   1b462:	e9 89 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b467:	90                   	nop
   1b468:	68 00 00 00 00       	push   $0x0
   1b46d:	68 55 00 00 00       	push   $0x55
   1b472:	e9 79 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b477:	90                   	nop
   1b478:	68 00 00 00 00       	push   $0x0
   1b47d:	68 56 00 00 00       	push   $0x56
   1b482:	e9 69 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b487:	90                   	nop
   1b488:	68 00 00 00 00       	push   $0x0
   1b48d:	68 57 00 00 00       	push   $0x57
   1b492:	e9 59 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b497:	90                   	nop
   1b498:	68 00 00 00 00       	push   $0x0
   1b49d:	68 58 00 00 00       	push   $0x58
   1b4a2:	e9 49 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4a7:	90                   	nop
   1b4a8:	68 00 00 00 00       	push   $0x0
   1b4ad:	68 59 00 00 00       	push   $0x59
   1b4b2:	e9 39 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4b7:	90                   	nop
   1b4b8:	68 00 00 00 00       	push   $0x0
   1b4bd:	68 5a 00 00 00       	push   $0x5a
   1b4c2:	e9 29 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4c7:	90                   	nop
   1b4c8:	68 00 00 00 00       	push   $0x0
   1b4cd:	68 5b 00 00 00       	push   $0x5b
   1b4d2:	e9 19 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4d7:	90                   	nop
   1b4d8:	68 00 00 00 00       	push   $0x0
   1b4dd:	68 5c 00 00 00       	push   $0x5c
   1b4e2:	e9 09 f9 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4e7:	90                   	nop
   1b4e8:	68 00 00 00 00       	push   $0x0
   1b4ed:	68 5d 00 00 00       	push   $0x5d
   1b4f2:	e9 f9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b4f7:	90                   	nop
   1b4f8:	68 00 00 00 00       	push   $0x0
   1b4fd:	68 5e 00 00 00       	push   $0x5e
   1b502:	e9 e9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b507:	90                   	nop
   1b508:	68 00 00 00 00       	push   $0x0
   1b50d:	68 5f 00 00 00       	push   $0x5f
   1b512:	e9 d9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b517:	90                   	nop
   1b518:	68 00 00 00 00       	push   $0x0
   1b51d:	68 60 00 00 00       	push   $0x60
   1b522:	e9 c9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b527:	90                   	nop
   1b528:	68 00 00 00 00       	push   $0x0
   1b52d:	68 61 00 00 00       	push   $0x61
   1b532:	e9 b9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b537:	90                   	nop
   1b538:	68 00 00 00 00       	push   $0x0
   1b53d:	68 62 00 00 00       	push   $0x62
   1b542:	e9 a9 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b547:	90                   	nop
   1b548:	68 00 00 00 00       	push   $0x0
   1b54d:	68 63 00 00 00       	push   $0x63
   1b552:	e9 99 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b557:	90                   	nop
   1b558:	68 00 00 00 00       	push   $0x0
   1b55d:	68 64 00 00 00       	push   $0x64
   1b562:	e9 89 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b567:	90                   	nop
   1b568:	68 00 00 00 00       	push   $0x0
   1b56d:	68 65 00 00 00       	push   $0x65
   1b572:	e9 79 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b577:	90                   	nop
   1b578:	68 00 00 00 00       	push   $0x0
   1b57d:	68 66 00 00 00       	push   $0x66
   1b582:	e9 69 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b587:	90                   	nop
   1b588:	68 00 00 00 00       	push   $0x0
   1b58d:	68 67 00 00 00       	push   $0x67
   1b592:	e9 59 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b597:	90                   	nop
   1b598:	68 00 00 00 00       	push   $0x0
   1b59d:	68 68 00 00 00       	push   $0x68
   1b5a2:	e9 49 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5a7:	90                   	nop
   1b5a8:	68 00 00 00 00       	push   $0x0
   1b5ad:	68 69 00 00 00       	push   $0x69
   1b5b2:	e9 39 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5b7:	90                   	nop
   1b5b8:	68 00 00 00 00       	push   $0x0
   1b5bd:	68 6a 00 00 00       	push   $0x6a
   1b5c2:	e9 29 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5c7:	90                   	nop
   1b5c8:	68 00 00 00 00       	push   $0x0
   1b5cd:	68 6b 00 00 00       	push   $0x6b
   1b5d2:	e9 19 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5d7:	90                   	nop
   1b5d8:	68 00 00 00 00       	push   $0x0
   1b5dd:	68 6c 00 00 00       	push   $0x6c
   1b5e2:	e9 09 f8 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5e7:	90                   	nop
   1b5e8:	68 00 00 00 00       	push   $0x0
   1b5ed:	68 6d 00 00 00       	push   $0x6d
   1b5f2:	e9 f9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b5f7:	90                   	nop
   1b5f8:	68 00 00 00 00       	push   $0x0
   1b5fd:	68 6e 00 00 00       	push   $0x6e
   1b602:	e9 e9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b607:	90                   	nop
   1b608:	68 00 00 00 00       	push   $0x0
   1b60d:	68 6f 00 00 00       	push   $0x6f
   1b612:	e9 d9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b617:	90                   	nop
   1b618:	68 00 00 00 00       	push   $0x0
   1b61d:	68 70 00 00 00       	push   $0x70
   1b622:	e9 c9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b627:	90                   	nop
   1b628:	68 00 00 00 00       	push   $0x0
   1b62d:	68 71 00 00 00       	push   $0x71
   1b632:	e9 b9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b637:	90                   	nop
   1b638:	68 00 00 00 00       	push   $0x0
   1b63d:	68 72 00 00 00       	push   $0x72
   1b642:	e9 a9 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b647:	90                   	nop
   1b648:	68 00 00 00 00       	push   $0x0
   1b64d:	68 73 00 00 00       	push   $0x73
   1b652:	e9 99 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b657:	90                   	nop
   1b658:	68 00 00 00 00       	push   $0x0
   1b65d:	68 74 00 00 00       	push   $0x74
   1b662:	e9 89 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b667:	90                   	nop
   1b668:	68 00 00 00 00       	push   $0x0
   1b66d:	68 75 00 00 00       	push   $0x75
   1b672:	e9 79 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b677:	90                   	nop
   1b678:	68 00 00 00 00       	push   $0x0
   1b67d:	68 76 00 00 00       	push   $0x76
   1b682:	e9 69 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b687:	90                   	nop
   1b688:	68 00 00 00 00       	push   $0x0
   1b68d:	68 77 00 00 00       	push   $0x77
   1b692:	e9 59 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b697:	90                   	nop
   1b698:	68 00 00 00 00       	push   $0x0
   1b69d:	68 78 00 00 00       	push   $0x78
   1b6a2:	e9 49 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6a7:	90                   	nop
   1b6a8:	68 00 00 00 00       	push   $0x0
   1b6ad:	68 79 00 00 00       	push   $0x79
   1b6b2:	e9 39 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6b7:	90                   	nop
   1b6b8:	68 00 00 00 00       	push   $0x0
   1b6bd:	68 7a 00 00 00       	push   $0x7a
   1b6c2:	e9 29 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6c7:	90                   	nop
   1b6c8:	68 00 00 00 00       	push   $0x0
   1b6cd:	68 7b 00 00 00       	push   $0x7b
   1b6d2:	e9 19 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6d7:	90                   	nop
   1b6d8:	68 00 00 00 00       	push   $0x0
   1b6dd:	68 7c 00 00 00       	push   $0x7c
   1b6e2:	e9 09 f7 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6e7:	90                   	nop
   1b6e8:	68 00 00 00 00       	push   $0x0
   1b6ed:	68 7d 00 00 00       	push   $0x7d
   1b6f2:	e9 f9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b6f7:	90                   	nop
   1b6f8:	68 00 00 00 00       	push   $0x0
   1b6fd:	68 7e 00 00 00       	push   $0x7e
   1b702:	e9 e9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b707:	90                   	nop
   1b708:	68 00 00 00 00       	push   $0x0
   1b70d:	68 7f 00 00 00       	push   $0x7f
   1b712:	e9 d9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b717:	90                   	nop
   1b718:	68 00 00 00 00       	push   $0x0
   1b71d:	68 80 00 00 00       	push   $0x80
   1b722:	e9 c9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b727:	90                   	nop
   1b728:	68 00 00 00 00       	push   $0x0
   1b72d:	68 81 00 00 00       	push   $0x81
   1b732:	e9 b9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b737:	90                   	nop
   1b738:	68 00 00 00 00       	push   $0x0
   1b73d:	68 82 00 00 00       	push   $0x82
   1b742:	e9 a9 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b747:	90                   	nop
   1b748:	68 00 00 00 00       	push   $0x0
   1b74d:	68 83 00 00 00       	push   $0x83
   1b752:	e9 99 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b757:	90                   	nop
   1b758:	68 00 00 00 00       	push   $0x0
   1b75d:	68 84 00 00 00       	push   $0x84
   1b762:	e9 89 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b767:	90                   	nop
   1b768:	68 00 00 00 00       	push   $0x0
   1b76d:	68 85 00 00 00       	push   $0x85
   1b772:	e9 79 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b777:	90                   	nop
   1b778:	68 00 00 00 00       	push   $0x0
   1b77d:	68 86 00 00 00       	push   $0x86
   1b782:	e9 69 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b787:	90                   	nop
   1b788:	68 00 00 00 00       	push   $0x0
   1b78d:	68 87 00 00 00       	push   $0x87
   1b792:	e9 59 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b797:	90                   	nop
   1b798:	68 00 00 00 00       	push   $0x0
   1b79d:	68 88 00 00 00       	push   $0x88
   1b7a2:	e9 49 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7a7:	90                   	nop
   1b7a8:	68 00 00 00 00       	push   $0x0
   1b7ad:	68 89 00 00 00       	push   $0x89
   1b7b2:	e9 39 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7b7:	90                   	nop
   1b7b8:	68 00 00 00 00       	push   $0x0
   1b7bd:	68 8a 00 00 00       	push   $0x8a
   1b7c2:	e9 29 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7c7:	90                   	nop
   1b7c8:	68 00 00 00 00       	push   $0x0
   1b7cd:	68 8b 00 00 00       	push   $0x8b
   1b7d2:	e9 19 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7d7:	90                   	nop
   1b7d8:	68 00 00 00 00       	push   $0x0
   1b7dd:	68 8c 00 00 00       	push   $0x8c
   1b7e2:	e9 09 f6 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7e7:	90                   	nop
   1b7e8:	68 00 00 00 00       	push   $0x0
   1b7ed:	68 8d 00 00 00       	push   $0x8d
   1b7f2:	e9 f9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b7f7:	90                   	nop
   1b7f8:	68 00 00 00 00       	push   $0x0
   1b7fd:	68 8e 00 00 00       	push   $0x8e
   1b802:	e9 e9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b807:	90                   	nop
   1b808:	68 00 00 00 00       	push   $0x0
   1b80d:	68 8f 00 00 00       	push   $0x8f
   1b812:	e9 d9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b817:	90                   	nop
   1b818:	68 00 00 00 00       	push   $0x0
   1b81d:	68 90 00 00 00       	push   $0x90
   1b822:	e9 c9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b827:	90                   	nop
   1b828:	68 00 00 00 00       	push   $0x0
   1b82d:	68 91 00 00 00       	push   $0x91
   1b832:	e9 b9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b837:	90                   	nop
   1b838:	68 00 00 00 00       	push   $0x0
   1b83d:	68 92 00 00 00       	push   $0x92
   1b842:	e9 a9 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b847:	90                   	nop
   1b848:	68 00 00 00 00       	push   $0x0
   1b84d:	68 93 00 00 00       	push   $0x93
   1b852:	e9 99 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b857:	90                   	nop
   1b858:	68 00 00 00 00       	push   $0x0
   1b85d:	68 94 00 00 00       	push   $0x94
   1b862:	e9 89 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b867:	90                   	nop
   1b868:	68 00 00 00 00       	push   $0x0
   1b86d:	68 95 00 00 00       	push   $0x95
   1b872:	e9 79 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b877:	90                   	nop
   1b878:	68 00 00 00 00       	push   $0x0
   1b87d:	68 96 00 00 00       	push   $0x96
   1b882:	e9 69 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b887:	90                   	nop
   1b888:	68 00 00 00 00       	push   $0x0
   1b88d:	68 97 00 00 00       	push   $0x97
   1b892:	e9 59 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b897:	90                   	nop
   1b898:	68 00 00 00 00       	push   $0x0
   1b89d:	68 98 00 00 00       	push   $0x98
   1b8a2:	e9 49 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8a7:	90                   	nop
   1b8a8:	68 00 00 00 00       	push   $0x0
   1b8ad:	68 99 00 00 00       	push   $0x99
   1b8b2:	e9 39 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8b7:	90                   	nop
   1b8b8:	68 00 00 00 00       	push   $0x0
   1b8bd:	68 9a 00 00 00       	push   $0x9a
   1b8c2:	e9 29 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8c7:	90                   	nop
   1b8c8:	68 00 00 00 00       	push   $0x0
   1b8cd:	68 9b 00 00 00       	push   $0x9b
   1b8d2:	e9 19 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8d7:	90                   	nop
   1b8d8:	68 00 00 00 00       	push   $0x0
   1b8dd:	68 9c 00 00 00       	push   $0x9c
   1b8e2:	e9 09 f5 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8e7:	90                   	nop
   1b8e8:	68 00 00 00 00       	push   $0x0
   1b8ed:	68 9d 00 00 00       	push   $0x9d
   1b8f2:	e9 f9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b8f7:	90                   	nop
   1b8f8:	68 00 00 00 00       	push   $0x0
   1b8fd:	68 9e 00 00 00       	push   $0x9e
   1b902:	e9 e9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b907:	90                   	nop
   1b908:	68 00 00 00 00       	push   $0x0
   1b90d:	68 9f 00 00 00       	push   $0x9f
   1b912:	e9 d9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b917:	90                   	nop
   1b918:	68 00 00 00 00       	push   $0x0
   1b91d:	68 a0 00 00 00       	push   $0xa0
   1b922:	e9 c9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b927:	90                   	nop
   1b928:	68 00 00 00 00       	push   $0x0
   1b92d:	68 a1 00 00 00       	push   $0xa1
   1b932:	e9 b9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b937:	90                   	nop
   1b938:	68 00 00 00 00       	push   $0x0
   1b93d:	68 a2 00 00 00       	push   $0xa2
   1b942:	e9 a9 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b947:	90                   	nop
   1b948:	68 00 00 00 00       	push   $0x0
   1b94d:	68 a3 00 00 00       	push   $0xa3
   1b952:	e9 99 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b957:	90                   	nop
   1b958:	68 00 00 00 00       	push   $0x0
   1b95d:	68 a4 00 00 00       	push   $0xa4
   1b962:	e9 89 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b967:	90                   	nop
   1b968:	68 00 00 00 00       	push   $0x0
   1b96d:	68 a5 00 00 00       	push   $0xa5
   1b972:	e9 79 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b977:	90                   	nop
   1b978:	68 00 00 00 00       	push   $0x0
   1b97d:	68 a6 00 00 00       	push   $0xa6
   1b982:	e9 69 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b987:	90                   	nop
   1b988:	68 00 00 00 00       	push   $0x0
   1b98d:	68 a7 00 00 00       	push   $0xa7
   1b992:	e9 59 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b997:	90                   	nop
   1b998:	68 00 00 00 00       	push   $0x0
   1b99d:	68 a8 00 00 00       	push   $0xa8
   1b9a2:	e9 49 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9a7:	90                   	nop
   1b9a8:	68 00 00 00 00       	push   $0x0
   1b9ad:	68 a9 00 00 00       	push   $0xa9
   1b9b2:	e9 39 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9b7:	90                   	nop
   1b9b8:	68 00 00 00 00       	push   $0x0
   1b9bd:	68 aa 00 00 00       	push   $0xaa
   1b9c2:	e9 29 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9c7:	90                   	nop
   1b9c8:	68 00 00 00 00       	push   $0x0
   1b9cd:	68 ab 00 00 00       	push   $0xab
   1b9d2:	e9 19 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9d7:	90                   	nop
   1b9d8:	68 00 00 00 00       	push   $0x0
   1b9dd:	68 ac 00 00 00       	push   $0xac
   1b9e2:	e9 09 f4 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9e7:	90                   	nop
   1b9e8:	68 00 00 00 00       	push   $0x0
   1b9ed:	68 ad 00 00 00       	push   $0xad
   1b9f2:	e9 f9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1b9f7:	90                   	nop
   1b9f8:	68 00 00 00 00       	push   $0x0
   1b9fd:	68 ae 00 00 00       	push   $0xae
   1ba02:	e9 e9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba07:	90                   	nop
   1ba08:	68 00 00 00 00       	push   $0x0
   1ba0d:	68 af 00 00 00       	push   $0xaf
   1ba12:	e9 d9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba17:	90                   	nop
   1ba18:	68 00 00 00 00       	push   $0x0
   1ba1d:	68 b0 00 00 00       	push   $0xb0
   1ba22:	e9 c9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba27:	90                   	nop
   1ba28:	68 00 00 00 00       	push   $0x0
   1ba2d:	68 b1 00 00 00       	push   $0xb1
   1ba32:	e9 b9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba37:	90                   	nop
   1ba38:	68 00 00 00 00       	push   $0x0
   1ba3d:	68 b2 00 00 00       	push   $0xb2
   1ba42:	e9 a9 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba47:	90                   	nop
   1ba48:	68 00 00 00 00       	push   $0x0
   1ba4d:	68 b3 00 00 00       	push   $0xb3
   1ba52:	e9 99 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba57:	90                   	nop
   1ba58:	68 00 00 00 00       	push   $0x0
   1ba5d:	68 b4 00 00 00       	push   $0xb4
   1ba62:	e9 89 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba67:	90                   	nop
   1ba68:	68 00 00 00 00       	push   $0x0
   1ba6d:	68 b5 00 00 00       	push   $0xb5
   1ba72:	e9 79 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba77:	90                   	nop
   1ba78:	68 00 00 00 00       	push   $0x0
   1ba7d:	68 b6 00 00 00       	push   $0xb6
   1ba82:	e9 69 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba87:	90                   	nop
   1ba88:	68 00 00 00 00       	push   $0x0
   1ba8d:	68 b7 00 00 00       	push   $0xb7
   1ba92:	e9 59 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1ba97:	90                   	nop
   1ba98:	68 00 00 00 00       	push   $0x0
   1ba9d:	68 b8 00 00 00       	push   $0xb8
   1baa2:	e9 49 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1baa7:	90                   	nop
   1baa8:	68 00 00 00 00       	push   $0x0
   1baad:	68 b9 00 00 00       	push   $0xb9
   1bab2:	e9 39 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bab7:	90                   	nop
   1bab8:	68 00 00 00 00       	push   $0x0
   1babd:	68 ba 00 00 00       	push   $0xba
   1bac2:	e9 29 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bac7:	90                   	nop
   1bac8:	68 00 00 00 00       	push   $0x0
   1bacd:	68 bb 00 00 00       	push   $0xbb
   1bad2:	e9 19 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bad7:	90                   	nop
   1bad8:	68 00 00 00 00       	push   $0x0
   1badd:	68 bc 00 00 00       	push   $0xbc
   1bae2:	e9 09 f3 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bae7:	90                   	nop
   1bae8:	68 00 00 00 00       	push   $0x0
   1baed:	68 bd 00 00 00       	push   $0xbd
   1baf2:	e9 f9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1baf7:	90                   	nop
   1baf8:	68 00 00 00 00       	push   $0x0
   1bafd:	68 be 00 00 00       	push   $0xbe
   1bb02:	e9 e9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb07:	90                   	nop
   1bb08:	68 00 00 00 00       	push   $0x0
   1bb0d:	68 bf 00 00 00       	push   $0xbf
   1bb12:	e9 d9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb17:	90                   	nop
   1bb18:	68 00 00 00 00       	push   $0x0
   1bb1d:	68 c0 00 00 00       	push   $0xc0
   1bb22:	e9 c9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb27:	90                   	nop
   1bb28:	68 00 00 00 00       	push   $0x0
   1bb2d:	68 c1 00 00 00       	push   $0xc1
   1bb32:	e9 b9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb37:	90                   	nop
   1bb38:	68 00 00 00 00       	push   $0x0
   1bb3d:	68 c2 00 00 00       	push   $0xc2
   1bb42:	e9 a9 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb47:	90                   	nop
   1bb48:	68 00 00 00 00       	push   $0x0
   1bb4d:	68 c3 00 00 00       	push   $0xc3
   1bb52:	e9 99 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb57:	90                   	nop
   1bb58:	68 00 00 00 00       	push   $0x0
   1bb5d:	68 c4 00 00 00       	push   $0xc4
   1bb62:	e9 89 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb67:	90                   	nop
   1bb68:	68 00 00 00 00       	push   $0x0
   1bb6d:	68 c5 00 00 00       	push   $0xc5
   1bb72:	e9 79 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb77:	90                   	nop
   1bb78:	68 00 00 00 00       	push   $0x0
   1bb7d:	68 c6 00 00 00       	push   $0xc6
   1bb82:	e9 69 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb87:	90                   	nop
   1bb88:	68 00 00 00 00       	push   $0x0
   1bb8d:	68 c7 00 00 00       	push   $0xc7
   1bb92:	e9 59 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bb97:	90                   	nop
   1bb98:	68 00 00 00 00       	push   $0x0
   1bb9d:	68 c8 00 00 00       	push   $0xc8
   1bba2:	e9 49 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bba7:	90                   	nop
   1bba8:	68 00 00 00 00       	push   $0x0
   1bbad:	68 c9 00 00 00       	push   $0xc9
   1bbb2:	e9 39 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bbb7:	90                   	nop
   1bbb8:	68 00 00 00 00       	push   $0x0
   1bbbd:	68 ca 00 00 00       	push   $0xca
   1bbc2:	e9 29 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bbc7:	90                   	nop
   1bbc8:	68 00 00 00 00       	push   $0x0
   1bbcd:	68 cb 00 00 00       	push   $0xcb
   1bbd2:	e9 19 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bbd7:	90                   	nop
   1bbd8:	68 00 00 00 00       	push   $0x0
   1bbdd:	68 cc 00 00 00       	push   $0xcc
   1bbe2:	e9 09 f2 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bbe7:	90                   	nop
   1bbe8:	68 00 00 00 00       	push   $0x0
   1bbed:	68 cd 00 00 00       	push   $0xcd
   1bbf2:	e9 f9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bbf7:	90                   	nop
   1bbf8:	68 00 00 00 00       	push   $0x0
   1bbfd:	68 ce 00 00 00       	push   $0xce
   1bc02:	e9 e9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc07:	90                   	nop
   1bc08:	68 00 00 00 00       	push   $0x0
   1bc0d:	68 cf 00 00 00       	push   $0xcf
   1bc12:	e9 d9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc17:	90                   	nop
   1bc18:	68 00 00 00 00       	push   $0x0
   1bc1d:	68 d0 00 00 00       	push   $0xd0
   1bc22:	e9 c9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc27:	90                   	nop
   1bc28:	68 00 00 00 00       	push   $0x0
   1bc2d:	68 d1 00 00 00       	push   $0xd1
   1bc32:	e9 b9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc37:	90                   	nop
   1bc38:	68 00 00 00 00       	push   $0x0
   1bc3d:	68 d2 00 00 00       	push   $0xd2
   1bc42:	e9 a9 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc47:	90                   	nop
   1bc48:	68 00 00 00 00       	push   $0x0
   1bc4d:	68 d3 00 00 00       	push   $0xd3
   1bc52:	e9 99 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc57:	90                   	nop
   1bc58:	68 00 00 00 00       	push   $0x0
   1bc5d:	68 d4 00 00 00       	push   $0xd4
   1bc62:	e9 89 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc67:	90                   	nop
   1bc68:	68 00 00 00 00       	push   $0x0
   1bc6d:	68 d5 00 00 00       	push   $0xd5
   1bc72:	e9 79 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc77:	90                   	nop
   1bc78:	68 00 00 00 00       	push   $0x0
   1bc7d:	68 d6 00 00 00       	push   $0xd6
   1bc82:	e9 69 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc87:	90                   	nop
   1bc88:	68 00 00 00 00       	push   $0x0
   1bc8d:	68 d7 00 00 00       	push   $0xd7
   1bc92:	e9 59 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bc97:	90                   	nop
   1bc98:	68 00 00 00 00       	push   $0x0
   1bc9d:	68 d8 00 00 00       	push   $0xd8
   1bca2:	e9 49 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bca7:	90                   	nop
   1bca8:	68 00 00 00 00       	push   $0x0
   1bcad:	68 d9 00 00 00       	push   $0xd9
   1bcb2:	e9 39 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bcb7:	90                   	nop
   1bcb8:	68 00 00 00 00       	push   $0x0
   1bcbd:	68 da 00 00 00       	push   $0xda
   1bcc2:	e9 29 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bcc7:	90                   	nop
   1bcc8:	68 00 00 00 00       	push   $0x0
   1bccd:	68 db 00 00 00       	push   $0xdb
   1bcd2:	e9 19 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bcd7:	90                   	nop
   1bcd8:	68 00 00 00 00       	push   $0x0
   1bcdd:	68 dc 00 00 00       	push   $0xdc
   1bce2:	e9 09 f1 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bce7:	90                   	nop
   1bce8:	68 00 00 00 00       	push   $0x0
   1bced:	68 dd 00 00 00       	push   $0xdd
   1bcf2:	e9 f9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bcf7:	90                   	nop
   1bcf8:	68 00 00 00 00       	push   $0x0
   1bcfd:	68 de 00 00 00       	push   $0xde
   1bd02:	e9 e9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd07:	90                   	nop
   1bd08:	68 00 00 00 00       	push   $0x0
   1bd0d:	68 df 00 00 00       	push   $0xdf
   1bd12:	e9 d9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd17:	90                   	nop
   1bd18:	68 00 00 00 00       	push   $0x0
   1bd1d:	68 e0 00 00 00       	push   $0xe0
   1bd22:	e9 c9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd27:	90                   	nop
   1bd28:	68 00 00 00 00       	push   $0x0
   1bd2d:	68 e1 00 00 00       	push   $0xe1
   1bd32:	e9 b9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd37:	90                   	nop
   1bd38:	68 00 00 00 00       	push   $0x0
   1bd3d:	68 e2 00 00 00       	push   $0xe2
   1bd42:	e9 a9 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd47:	90                   	nop
   1bd48:	68 00 00 00 00       	push   $0x0
   1bd4d:	68 e3 00 00 00       	push   $0xe3
   1bd52:	e9 99 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd57:	90                   	nop
   1bd58:	68 00 00 00 00       	push   $0x0
   1bd5d:	68 e4 00 00 00       	push   $0xe4
   1bd62:	e9 89 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd67:	90                   	nop
   1bd68:	68 00 00 00 00       	push   $0x0
   1bd6d:	68 e5 00 00 00       	push   $0xe5
   1bd72:	e9 79 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd77:	90                   	nop
   1bd78:	68 00 00 00 00       	push   $0x0
   1bd7d:	68 e6 00 00 00       	push   $0xe6
   1bd82:	e9 69 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd87:	90                   	nop
   1bd88:	68 00 00 00 00       	push   $0x0
   1bd8d:	68 e7 00 00 00       	push   $0xe7
   1bd92:	e9 59 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bd97:	90                   	nop
   1bd98:	68 00 00 00 00       	push   $0x0
   1bd9d:	68 e8 00 00 00       	push   $0xe8
   1bda2:	e9 49 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bda7:	90                   	nop
   1bda8:	68 00 00 00 00       	push   $0x0
   1bdad:	68 e9 00 00 00       	push   $0xe9
   1bdb2:	e9 39 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bdb7:	90                   	nop
   1bdb8:	68 00 00 00 00       	push   $0x0
   1bdbd:	68 ea 00 00 00       	push   $0xea
   1bdc2:	e9 29 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bdc7:	90                   	nop
   1bdc8:	68 00 00 00 00       	push   $0x0
   1bdcd:	68 eb 00 00 00       	push   $0xeb
   1bdd2:	e9 19 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bdd7:	90                   	nop
   1bdd8:	68 00 00 00 00       	push   $0x0
   1bddd:	68 ec 00 00 00       	push   $0xec
   1bde2:	e9 09 f0 ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bde7:	90                   	nop
   1bde8:	68 00 00 00 00       	push   $0x0
   1bded:	68 ed 00 00 00       	push   $0xed
   1bdf2:	e9 f9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bdf7:	90                   	nop
   1bdf8:	68 00 00 00 00       	push   $0x0
   1bdfd:	68 ee 00 00 00       	push   $0xee
   1be02:	e9 e9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be07:	90                   	nop
   1be08:	68 00 00 00 00       	push   $0x0
   1be0d:	68 ef 00 00 00       	push   $0xef
   1be12:	e9 d9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be17:	90                   	nop
   1be18:	68 00 00 00 00       	push   $0x0
   1be1d:	68 f0 00 00 00       	push   $0xf0
   1be22:	e9 c9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be27:	90                   	nop
   1be28:	68 00 00 00 00       	push   $0x0
   1be2d:	68 f1 00 00 00       	push   $0xf1
   1be32:	e9 b9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be37:	90                   	nop
   1be38:	68 00 00 00 00       	push   $0x0
   1be3d:	68 f2 00 00 00       	push   $0xf2
   1be42:	e9 a9 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be47:	90                   	nop
   1be48:	68 00 00 00 00       	push   $0x0
   1be4d:	68 f3 00 00 00       	push   $0xf3
   1be52:	e9 99 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be57:	90                   	nop
   1be58:	68 00 00 00 00       	push   $0x0
   1be5d:	68 f4 00 00 00       	push   $0xf4
   1be62:	e9 89 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be67:	90                   	nop
   1be68:	68 00 00 00 00       	push   $0x0
   1be6d:	68 f5 00 00 00       	push   $0xf5
   1be72:	e9 79 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be77:	90                   	nop
   1be78:	68 00 00 00 00       	push   $0x0
   1be7d:	68 f6 00 00 00       	push   $0xf6
   1be82:	e9 69 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be87:	90                   	nop
   1be88:	68 00 00 00 00       	push   $0x0
   1be8d:	68 f7 00 00 00       	push   $0xf7
   1be92:	e9 59 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1be97:	90                   	nop
   1be98:	68 00 00 00 00       	push   $0x0
   1be9d:	68 f8 00 00 00       	push   $0xf8
   1bea2:	e9 49 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bea7:	90                   	nop
   1bea8:	68 00 00 00 00       	push   $0x0
   1bead:	68 f9 00 00 00       	push   $0xf9
   1beb2:	e9 39 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1beb7:	90                   	nop
   1beb8:	68 00 00 00 00       	push   $0x0
   1bebd:	68 fa 00 00 00       	push   $0xfa
   1bec2:	e9 29 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bec7:	90                   	nop
   1bec8:	68 00 00 00 00       	push   $0x0
   1becd:	68 fb 00 00 00       	push   $0xfb
   1bed2:	e9 19 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bed7:	90                   	nop
   1bed8:	68 00 00 00 00       	push   $0x0
   1bedd:	68 fc 00 00 00       	push   $0xfc
   1bee2:	e9 09 ef ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bee7:	90                   	nop
   1bee8:	68 00 00 00 00       	push   $0x0
   1beed:	68 fd 00 00 00       	push   $0xfd
   1bef2:	e9 f9 ee ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bef7:	90                   	nop
   1bef8:	68 00 00 00 00       	push   $0x0
   1befd:	68 fe 00 00 00       	push   $0xfe
   1bf02:	e9 e9 ee ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bf07:	90                   	nop
   1bf08:	68 00 00 00 00       	push   $0x0
   1bf0d:	68 ff 00 00 00       	push   $0xff
   1bf12:	e9 d9 ee ff ff       	jmp    1adf0 <Handle_Interrupt>
   1bf17:	90                   	nop

0001bf18 <Format_Output>:
   1bf18:	55                   	push   %ebp
   1bf19:	57                   	push   %edi
   1bf1a:	56                   	push   %esi
   1bf1b:	53                   	push   %ebx
   1bf1c:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
   1bf22:	e8 ac 45 ff ff       	call   104d3 <__x86.get_pc_thunk.si>
   1bf27:	81 c6 d9 a0 00 00    	add    $0xa0d9,%esi
   1bf2d:	8b 94 24 a4 00 00 00 	mov    0xa4(%esp),%edx
   1bf34:	0f b6 02             	movzbl (%edx),%eax
   1bf37:	84 c0                	test   %al,%al
   1bf39:	0f 84 bd 0a 00 00    	je     1c9fc <.L98+0x1c>
   1bf3f:	8d 6a 01             	lea    0x1(%edx),%ebp
   1bf42:	bb 00 00 00 00       	mov    $0x0,%ebx
   1bf47:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   1bf4e:	00 
   1bf4f:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   1bf56:	ff 
   1bf57:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1bf5e:	00 
   1bf5f:	bf 00 00 00 00       	mov    $0x0,%edi
   1bf64:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   1bf6b:	00 
   1bf6c:	8d 8e 44 90 ff ff    	lea    -0x6fbc(%esi),%ecx
   1bf72:	89 4c 24 24          	mov    %ecx,0x24(%esp)
   1bf76:	8d 8e 04 92 ff ff    	lea    -0x6dfc(%esi),%ecx
   1bf7c:	89 4c 24 20          	mov    %ecx,0x20(%esp)
   1bf80:	eb 32                	jmp    1bfb4 <.L9+0x32>

0001bf82 <.L9>:
   1bf82:	3c 25                	cmp    $0x25,%al
   1bf84:	0f 84 27 0a 00 00    	je     1c9b1 <.L25+0x31>
   1bf8a:	83 ec 08             	sub    $0x8,%esp
   1bf8d:	0f be c0             	movsbl %al,%eax
   1bf90:	50                   	push   %eax
   1bf91:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1bf98:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1bf9f:	ff 10                	call   *(%eax)
   1bfa1:	83 c4 10             	add    $0x10,%esp
   1bfa4:	89 ea                	mov    %ebp,%edx
   1bfa6:	8d 6a 01             	lea    0x1(%edx),%ebp
   1bfa9:	0f b6 02             	movzbl (%edx),%eax
   1bfac:	84 c0                	test   %al,%al
   1bfae:	0f 84 48 0a 00 00    	je     1c9fc <.L98+0x1c>
   1bfb4:	83 fb 04             	cmp    $0x4,%ebx
   1bfb7:	0f 87 ed 09 00 00    	ja     1c9aa <.L25+0x2a>
   1bfbd:	89 f1                	mov    %esi,%ecx
   1bfbf:	03 8c 9e 4c 90 ff ff 	add    -0x6fb4(%esi,%ebx,4),%ecx
   1bfc6:	ff e1                	jmp    *%ecx

0001bfc8 <.L8>:
   1bfc8:	83 e8 20             	sub    $0x20,%eax
   1bfcb:	3c 10                	cmp    $0x10,%al
   1bfcd:	0f 87 03 0a 00 00    	ja     1c9d6 <.L94>
   1bfd3:	0f b6 c0             	movzbl %al,%eax
   1bfd6:	89 f1                	mov    %esi,%ecx
   1bfd8:	03 8c 86 60 90 ff ff 	add    -0x6fa0(%esi,%eax,4),%ecx
   1bfdf:	ff e1                	jmp    *%ecx

0001bfe1 <.L12>:
   1bfe1:	83 4c 24 0c 02       	orl    $0x2,0xc(%esp)
   1bfe6:	89 ea                	mov    %ebp,%edx
   1bfe8:	eb bc                	jmp    1bfa6 <.L9+0x24>

0001bfea <.L13>:
   1bfea:	83 4c 24 0c 04       	orl    $0x4,0xc(%esp)
   1bfef:	89 ea                	mov    %ebp,%edx
   1bff1:	eb b3                	jmp    1bfa6 <.L9+0x24>

0001bff3 <.L14>:
   1bff3:	83 4c 24 0c 08       	orl    $0x8,0xc(%esp)
   1bff8:	89 ea                	mov    %ebp,%edx
   1bffa:	eb aa                	jmp    1bfa6 <.L9+0x24>

0001bffc <.L16>:
   1bffc:	83 4c 24 0c 10       	orl    $0x10,0xc(%esp)
   1c001:	89 ea                	mov    %ebp,%edx
   1c003:	eb a1                	jmp    1bfa6 <.L9+0x24>

0001c005 <.L15>:
   1c005:	83 4c 24 0c 20       	orl    $0x20,0xc(%esp)
   1c00a:	89 ea                	mov    %ebp,%edx
   1c00c:	eb 98                	jmp    1bfa6 <.L9+0x24>

0001c00e <.L10>:
   1c00e:	83 4c 24 0c 01       	orl    $0x1,0xc(%esp)
   1c013:	89 ea                	mov    %ebp,%edx
   1c015:	eb 8f                	jmp    1bfa6 <.L9+0x24>

0001c017 <.L7>:
   1c017:	8d 48 d0             	lea    -0x30(%eax),%ecx
   1c01a:	80 f9 09             	cmp    $0x9,%cl
   1c01d:	77 19                	ja     1c038 <.L7+0x21>
   1c01f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1c023:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
   1c026:	0f be c0             	movsbl %al,%eax
   1c029:	8d 44 50 d0          	lea    -0x30(%eax,%edx,2),%eax
   1c02d:	89 44 24 10          	mov    %eax,0x10(%esp)
   1c031:	89 ea                	mov    %ebp,%edx
   1c033:	e9 6e ff ff ff       	jmp    1bfa6 <.L9+0x24>
   1c038:	3c 2a                	cmp    $0x2a,%al
   1c03a:	74 23                	je     1c05f <.L7+0x48>
   1c03c:	3c 2e                	cmp    $0x2e,%al
   1c03e:	0f 95 c3             	setne  %bl
   1c041:	0f b6 db             	movzbl %bl,%ebx
   1c044:	83 c3 03             	add    $0x3,%ebx
   1c047:	3c 2e                	cmp    $0x2e,%al
   1c049:	0f 44 d5             	cmove  %ebp,%edx
   1c04c:	b8 00 00 00 00       	mov    $0x0,%eax
   1c051:	0f 45 44 24 08       	cmovne 0x8(%esp),%eax
   1c056:	89 44 24 08          	mov    %eax,0x8(%esp)
   1c05a:	e9 47 ff ff ff       	jmp    1bfa6 <.L9+0x24>
   1c05f:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c066:	83 c0 04             	add    $0x4,%eax
   1c069:	8b 94 24 a8 00 00 00 	mov    0xa8(%esp),%edx
   1c070:	8b 0a                	mov    (%edx),%ecx
   1c072:	89 4c 24 10          	mov    %ecx,0x10(%esp)
   1c076:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c07d:	89 ea                	mov    %ebp,%edx
   1c07f:	85 c9                	test   %ecx,%ecx
   1c081:	0f 89 1f ff ff ff    	jns    1bfa6 <.L9+0x24>
   1c087:	f7 d9                	neg    %ecx
   1c089:	89 4c 24 10          	mov    %ecx,0x10(%esp)
   1c08d:	83 4c 24 0c 02       	orl    $0x2,0xc(%esp)
   1c092:	e9 0f ff ff ff       	jmp    1bfa6 <.L9+0x24>

0001c097 <.L6>:
   1c097:	8d 48 d0             	lea    -0x30(%eax),%ecx
   1c09a:	80 f9 09             	cmp    $0x9,%cl
   1c09d:	77 19                	ja     1c0b8 <.L6+0x21>
   1c09f:	8b 54 24 08          	mov    0x8(%esp),%edx
   1c0a3:	8d 14 92             	lea    (%edx,%edx,4),%edx
   1c0a6:	0f be c0             	movsbl %al,%eax
   1c0a9:	8d 44 50 d0          	lea    -0x30(%eax,%edx,2),%eax
   1c0ad:	89 44 24 08          	mov    %eax,0x8(%esp)
   1c0b1:	89 ea                	mov    %ebp,%edx
   1c0b3:	e9 ee fe ff ff       	jmp    1bfa6 <.L9+0x24>
   1c0b8:	3c 2a                	cmp    $0x2a,%al
   1c0ba:	74 0a                	je     1c0c6 <.L6+0x2f>
   1c0bc:	bb 04 00 00 00       	mov    $0x4,%ebx
   1c0c1:	e9 e0 fe ff ff       	jmp    1bfa6 <.L9+0x24>
   1c0c6:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c0cd:	83 38 00             	cmpl   $0x0,(%eax)
   1c0d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1c0d5:	8b 94 24 a8 00 00 00 	mov    0xa8(%esp),%edx
   1c0dc:	0f 49 02             	cmovns (%edx),%eax
   1c0df:	89 44 24 08          	mov    %eax,0x8(%esp)
   1c0e3:	8d 42 04             	lea    0x4(%edx),%eax
   1c0e6:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c0ed:	89 ea                	mov    %ebp,%edx
   1c0ef:	e9 b2 fe ff ff       	jmp    1bfa6 <.L9+0x24>

0001c0f4 <.L4>:
   1c0f4:	8d 50 b4             	lea    -0x4c(%eax),%edx
   1c0f7:	80 fa 2e             	cmp    $0x2e,%dl
   1c0fa:	77 2c                	ja     1c128 <.L20>
   1c0fc:	0f b6 d2             	movzbl %dl,%edx
   1c0ff:	89 f1                	mov    %esi,%ecx
   1c101:	03 8c 96 a4 90 ff ff 	add    -0x6f5c(%esi,%edx,4),%ecx
   1c108:	ff e1                	jmp    *%ecx

0001c10a <.L24>:
   1c10a:	83 ef 01             	sub    $0x1,%edi
   1c10d:	89 ea                	mov    %ebp,%edx
   1c10f:	e9 92 fe ff ff       	jmp    1bfa6 <.L9+0x24>

0001c114 <.L23>:
   1c114:	83 c7 01             	add    $0x1,%edi
   1c117:	89 ea                	mov    %ebp,%edx
   1c119:	e9 88 fe ff ff       	jmp    1bfa6 <.L9+0x24>

0001c11e <.L22>:
   1c11e:	83 c7 02             	add    $0x2,%edi
   1c121:	89 ea                	mov    %ebp,%edx
   1c123:	e9 7e fe ff ff       	jmp    1bfa6 <.L9+0x24>

0001c128 <.L20>:
   1c128:	85 ff                	test   %edi,%edi
   1c12a:	ba 01 00 00 00       	mov    $0x1,%edx
   1c12f:	0f 4e d7             	cmovle %edi,%edx
   1c132:	83 fa fe             	cmp    $0xfffffffe,%edx
   1c135:	b9 fe ff ff ff       	mov    $0xfffffffe,%ecx
   1c13a:	0f 4d ca             	cmovge %edx,%ecx
   1c13d:	89 4c 24 3c          	mov    %ecx,0x3c(%esp)
   1c141:	8d 50 b0             	lea    -0x50(%eax),%edx
   1c144:	80 fa 28             	cmp    $0x28,%dl
   1c147:	0f 87 33 08 00 00    	ja     1c980 <.L25>
   1c14d:	0f b6 d2             	movzbl %dl,%edx
   1c150:	89 f3                	mov    %esi,%ebx
   1c152:	03 9c 96 60 91 ff ff 	add    -0x6ea0(%esi,%edx,4),%ebx
   1c159:	ff e3                	jmp    *%ebx

0001c15b <.L26>:
   1c15b:	c7 44 24 18 10 00 00 	movl   $0x10,0x18(%esp)
   1c162:	00 
   1c163:	e9 11 02 00 00       	jmp    1c379 <.L28+0x8>

0001c168 <.L36>:
   1c168:	81 4c 24 0c 80 00 00 	orl    $0x80,0xc(%esp)
   1c16f:	00 

0001c170 <.L30>:
   1c170:	83 4c 24 0c 20       	orl    $0x20,0xc(%esp)
   1c175:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c17c:	8b 00                	mov    (%eax),%eax
   1c17e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c182:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c189:	8d 40 04             	lea    0x4(%eax),%eax
   1c18c:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c193:	c7 44 24 18 10 00 00 	movl   $0x10,0x18(%esp)
   1c19a:	00 
   1c19b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
   1c1a2:	00 
   1c1a3:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   1c1a7:	89 f8                	mov    %edi,%eax
   1c1a9:	25 80 00 00 00       	and    $0x80,%eax
   1c1ae:	89 44 24 48          	mov    %eax,0x48(%esp)
   1c1b2:	8d 86 18 92 ff ff    	lea    -0x6de8(%esi),%eax
   1c1b8:	0f 44 44 24 20       	cmove  0x20(%esp),%eax
   1c1bd:	89 44 24 28          	mov    %eax,0x28(%esp)
   1c1c1:	f7 c7 40 00 00 00    	test   $0x40,%edi
   1c1c7:	74 0c                	je     1c1d5 <.L30+0x65>
   1c1c9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1c1cd:	85 c0                	test   %eax,%eax
   1c1cf:	0f 88 63 02 00 00    	js     1c438 <.L99+0x74>
   1c1d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1c1d9:	85 c0                	test   %eax,%eax
   1c1db:	0f 84 6a 02 00 00    	je     1c44b <.L99+0x87>
   1c1e1:	89 44 24 38          	mov    %eax,0x38(%esp)
   1c1e5:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   1c1ec:	00 
   1c1ed:	8b 44 24 38          	mov    0x38(%esp),%eax
   1c1f1:	b9 00 00 00 00       	mov    $0x0,%ecx
   1c1f6:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   1c1fa:	89 c7                	mov    %eax,%edi
   1c1fc:	ba 00 00 00 00       	mov    $0x0,%edx
   1c201:	f7 f3                	div    %ebx
   1c203:	83 c1 01             	add    $0x1,%ecx
   1c206:	39 fb                	cmp    %edi,%ebx
   1c208:	76 f0                	jbe    1c1fa <.L30+0x8a>
   1c20a:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c20e:	c1 e8 05             	shr    $0x5,%eax
   1c211:	89 c3                	mov    %eax,%ebx
   1c213:	83 e3 01             	and    $0x1,%ebx
   1c216:	88 5c 24 34          	mov    %bl,0x34(%esp)
   1c21a:	83 7c 24 18 08       	cmpl   $0x8,0x18(%esp)
   1c21f:	0f 94 c2             	sete   %dl
   1c222:	84 c2                	test   %al,%dl
   1c224:	74 09                	je     1c22f <.L30+0xbf>
   1c226:	8d 59 01             	lea    0x1(%ecx),%ebx
   1c229:	39 4c 24 08          	cmp    %ecx,0x8(%esp)
   1c22d:	7e 04                	jle    1c233 <.L30+0xc3>
   1c22f:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1c233:	39 cb                	cmp    %ecx,%ebx
   1c235:	7f 0d                	jg     1c244 <.L30+0xd4>
   1c237:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
   1c23c:	bb 01 00 00 00       	mov    $0x1,%ebx
   1c241:	0f 45 d9             	cmovne %ecx,%ebx
   1c244:	f6 44 24 0c 08       	testb  $0x8,0xc(%esp)
   1c249:	0f 84 20 02 00 00    	je     1c46f <.L99+0xab>
   1c24f:	83 7c 24 18 10       	cmpl   $0x10,0x18(%esp)
   1c254:	0f 84 0b 02 00 00    	je     1c465 <.L99+0xa1>
   1c25a:	8d 4b ff             	lea    -0x1(%ebx),%ecx
   1c25d:	ba 56 55 55 55       	mov    $0x55555556,%edx
   1c262:	89 c8                	mov    %ecx,%eax
   1c264:	f7 ea                	imul   %edx
   1c266:	c1 f9 1f             	sar    $0x1f,%ecx
   1c269:	29 ca                	sub    %ecx,%edx
   1c26b:	8d 3c 13             	lea    (%ebx,%edx,1),%edi
   1c26e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c272:	83 e0 14             	and    $0x14,%eax
   1c275:	0b 44 24 14          	or     0x14(%esp),%eax
   1c279:	0f 85 a6 02 00 00    	jne    1c525 <.L99+0x161>
   1c27f:	83 7c 24 18 10       	cmpl   $0x10,0x18(%esp)
   1c284:	0f 94 c0             	sete   %al
   1c287:	22 44 24 34          	and    0x34(%esp),%al
   1c28b:	88 44 24 40          	mov    %al,0x40(%esp)
   1c28f:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
   1c293:	c7 44 24 30 03 00 00 	movl   $0x3,0x30(%esp)
   1c29a:	00 
   1c29b:	e9 18 02 00 00       	jmp    1c4b8 <.L99+0xf4>

0001c2a0 <.L33>:
   1c2a0:	83 4c 24 0c 40       	orl    $0x40,0xc(%esp)
   1c2a5:	85 ff                	test   %edi,%edi
   1c2a7:	74 72                	je     1c31b <.L33+0x7b>
   1c2a9:	0f 8f 97 00 00 00    	jg     1c346 <.L33+0xa6>
   1c2af:	83 ff ff             	cmp    $0xffffffff,%edi
   1c2b2:	7c 3b                	jl     1c2ef <.L33+0x4f>
   1c2b4:	75 2c                	jne    1c2e2 <.L33+0x42>
   1c2b6:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c2bd:	0f bf 00             	movswl (%eax),%eax
   1c2c0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c2c4:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c2cb:	8d 40 04             	lea    0x4(%eax),%eax
   1c2ce:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c2d5:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c2dc:	00 
   1c2dd:	e9 c1 fe ff ff       	jmp    1c1a3 <.L30+0x33>
   1c2e2:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c2e9:	00 
   1c2ea:	e9 b4 fe ff ff       	jmp    1c1a3 <.L30+0x33>
   1c2ef:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c2f6:	0f be 00             	movsbl (%eax),%eax
   1c2f9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c2fd:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c304:	8d 40 04             	lea    0x4(%eax),%eax
   1c307:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c30e:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c315:	00 
   1c316:	e9 88 fe ff ff       	jmp    1c1a3 <.L30+0x33>
   1c31b:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c322:	8b 00                	mov    (%eax),%eax
   1c324:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c328:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c32f:	8d 40 04             	lea    0x4(%eax),%eax
   1c332:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c339:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c340:	00 
   1c341:	e9 5d fe ff ff       	jmp    1c1a3 <.L30+0x33>
   1c346:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c34d:	8b 00                	mov    (%eax),%eax
   1c34f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c353:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c35a:	8d 40 04             	lea    0x4(%eax),%eax
   1c35d:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c364:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c36b:	00 
   1c36c:	e9 32 fe ff ff       	jmp    1c1a3 <.L30+0x33>

0001c371 <.L28>:
   1c371:	c7 44 24 18 0a 00 00 	movl   $0xa,0x18(%esp)
   1c378:	00 
   1c379:	85 ff                	test   %edi,%edi
   1c37b:	74 75                	je     1c3f2 <.L99+0x2e>
   1c37d:	0f 8f 92 00 00 00    	jg     1c415 <.L99+0x51>
   1c383:	83 ff ff             	cmp    $0xffffffff,%edi
   1c386:	7c 46                	jl     1c3ce <.L99+0xa>
   1c388:	0f 85 15 fe ff ff    	jne    1c1a3 <.L30+0x33>
   1c38e:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c395:	0f b7 00             	movzwl (%eax),%eax
   1c398:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c39c:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c3a3:	8d 40 04             	lea    0x4(%eax),%eax
   1c3a6:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c3ad:	e9 f1 fd ff ff       	jmp    1c1a3 <.L30+0x33>

0001c3b2 <.L35>:
   1c3b2:	81 4c 24 0c 80 00 00 	orl    $0x80,0xc(%esp)
   1c3b9:	00 
   1c3ba:	c7 44 24 18 10 00 00 	movl   $0x10,0x18(%esp)
   1c3c1:	00 
   1c3c2:	eb b5                	jmp    1c379 <.L28+0x8>

0001c3c4 <.L99>:
   1c3c4:	c7 44 24 18 08 00 00 	movl   $0x8,0x18(%esp)
   1c3cb:	00 
   1c3cc:	eb ab                	jmp    1c379 <.L28+0x8>
   1c3ce:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c3d5:	0f b6 00             	movzbl (%eax),%eax
   1c3d8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c3dc:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c3e3:	8d 40 04             	lea    0x4(%eax),%eax
   1c3e6:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c3ed:	e9 b1 fd ff ff       	jmp    1c1a3 <.L30+0x33>
   1c3f2:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c3f9:	8b 00                	mov    (%eax),%eax
   1c3fb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c3ff:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c406:	8d 40 04             	lea    0x4(%eax),%eax
   1c409:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c410:	e9 8e fd ff ff       	jmp    1c1a3 <.L30+0x33>
   1c415:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c41c:	8b 00                	mov    (%eax),%eax
   1c41e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1c422:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c429:	8d 40 04             	lea    0x4(%eax),%eax
   1c42c:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c433:	e9 6b fd ff ff       	jmp    1c1a3 <.L30+0x33>
   1c438:	f7 d8                	neg    %eax
   1c43a:	89 44 24 38          	mov    %eax,0x38(%esp)
   1c43e:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
   1c445:	00 
   1c446:	e9 a2 fd ff ff       	jmp    1c1ed <.L30+0x7d>
   1c44b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1c44f:	89 44 24 38          	mov    %eax,0x38(%esp)
   1c453:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   1c45a:	00 
   1c45b:	b9 00 00 00 00       	mov    $0x0,%ecx
   1c460:	e9 a5 fd ff ff       	jmp    1c20a <.L30+0x9a>
   1c465:	c7 44 24 30 04 00 00 	movl   $0x4,0x30(%esp)
   1c46c:	00 
   1c46d:	eb 04                	jmp    1c473 <.L99+0xaf>
   1c46f:	89 5c 24 30          	mov    %ebx,0x30(%esp)
   1c473:	8d 43 ff             	lea    -0x1(%ebx),%eax
   1c476:	99                   	cltd   
   1c477:	f7 7c 24 30          	idivl  0x30(%esp)
   1c47b:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
   1c47e:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c482:	83 e0 14             	and    $0x14,%eax
   1c485:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
   1c489:	0b 44 24 14          	or     0x14(%esp),%eax
   1c48d:	74 07                	je     1c496 <.L99+0xd2>
   1c48f:	8d 47 01             	lea    0x1(%edi),%eax
   1c492:	89 44 24 2c          	mov    %eax,0x2c(%esp)
   1c496:	83 7c 24 18 10       	cmpl   $0x10,0x18(%esp)
   1c49b:	0f 94 c0             	sete   %al
   1c49e:	22 44 24 34          	and    0x34(%esp),%al
   1c4a2:	89 c1                	mov    %eax,%ecx
   1c4a4:	88 44 24 40          	mov    %al,0x40(%esp)
   1c4a8:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
   1c4ac:	8d 43 02             	lea    0x2(%ebx),%eax
   1c4af:	84 c9                	test   %cl,%cl
   1c4b1:	0f 44 c3             	cmove  %ebx,%eax
   1c4b4:	89 44 24 2c          	mov    %eax,0x2c(%esp)
   1c4b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c4bc:	83 e0 03             	and    $0x3,%eax
   1c4bf:	89 44 24 44          	mov    %eax,0x44(%esp)
   1c4c3:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   1c4c7:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1c4cb:	39 da                	cmp    %ebx,%edx
   1c4cd:	7d 04                	jge    1c4d3 <.L99+0x10f>
   1c4cf:	85 c0                	test   %eax,%eax
   1c4d1:	74 5f                	je     1c532 <.L99+0x16e>
   1c4d3:	8b 44 24 10          	mov    0x10(%esp),%eax
   1c4d7:	89 44 24 34          	mov    %eax,0x34(%esp)
   1c4db:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1c4e0:	0f 84 9b 00 00 00    	je     1c581 <.L99+0x1bd>
   1c4e6:	83 ec 08             	sub    $0x8,%esp
   1c4e9:	6a 2d                	push   $0x2d
   1c4eb:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c4f2:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c4f9:	ff 10                	call   *(%eax)
   1c4fb:	83 c4 10             	add    $0x10,%esp
   1c4fe:	80 7c 24 40 00       	cmpb   $0x0,0x40(%esp)
   1c503:	0f 85 c4 00 00 00    	jne    1c5cd <.L99+0x209>
   1c509:	3b 7c 24 34          	cmp    0x34(%esp),%edi
   1c50d:	7d 0b                	jge    1c51a <.L99+0x156>
   1c50f:	83 7c 24 44 01       	cmpl   $0x1,0x44(%esp)
   1c514:	0f 84 f1 00 00 00    	je     1c60b <.L99+0x247>
   1c51a:	83 ff 2b             	cmp    $0x2b,%edi
   1c51d:	0f 8e 2c 01 00 00    	jle    1c64f <.L99+0x28b>
   1c523:	eb fe                	jmp    1c523 <.L99+0x15f>
   1c525:	c7 44 24 30 03 00 00 	movl   $0x3,0x30(%esp)
   1c52c:	00 
   1c52d:	e9 5d ff ff ff       	jmp    1c48f <.L99+0xcb>
   1c532:	89 6c 24 34          	mov    %ebp,0x34(%esp)
   1c536:	89 d5                	mov    %edx,%ebp
   1c538:	89 7c 24 4c          	mov    %edi,0x4c(%esp)
   1c53c:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
   1c543:	83 ec 08             	sub    $0x8,%esp
   1c546:	6a 20                	push   $0x20
   1c548:	57                   	push   %edi
   1c549:	ff 17                	call   *(%edi)
   1c54b:	83 eb 01             	sub    $0x1,%ebx
   1c54e:	83 c4 10             	add    $0x10,%esp
   1c551:	39 dd                	cmp    %ebx,%ebp
   1c553:	7c ee                	jl     1c543 <.L99+0x17f>
   1c555:	8b 6c 24 34          	mov    0x34(%esp),%ebp
   1c559:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
   1c55d:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1c561:	8d 51 ff             	lea    -0x1(%ecx),%edx
   1c564:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
   1c568:	89 d8                	mov    %ebx,%eax
   1c56a:	29 d0                	sub    %edx,%eax
   1c56c:	39 cb                	cmp    %ecx,%ebx
   1c56e:	b9 00 00 00 00       	mov    $0x0,%ecx
   1c573:	0f 4d c1             	cmovge %ecx,%eax
   1c576:	01 d0                	add    %edx,%eax
   1c578:	89 44 24 34          	mov    %eax,0x34(%esp)
   1c57c:	e9 5a ff ff ff       	jmp    1c4db <.L99+0x117>
   1c581:	f6 44 24 0c 04       	testb  $0x4,0xc(%esp)
   1c586:	74 1d                	je     1c5a5 <.L99+0x1e1>
   1c588:	83 ec 08             	sub    $0x8,%esp
   1c58b:	6a 2b                	push   $0x2b
   1c58d:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c594:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c59b:	ff 10                	call   *(%eax)
   1c59d:	83 c4 10             	add    $0x10,%esp
   1c5a0:	e9 59 ff ff ff       	jmp    1c4fe <.L99+0x13a>
   1c5a5:	f6 44 24 0c 10       	testb  $0x10,0xc(%esp)
   1c5aa:	0f 84 4e ff ff ff    	je     1c4fe <.L99+0x13a>
   1c5b0:	83 ec 08             	sub    $0x8,%esp
   1c5b3:	6a 20                	push   $0x20
   1c5b5:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c5bc:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c5c3:	ff 10                	call   *(%eax)
   1c5c5:	83 c4 10             	add    $0x10,%esp
   1c5c8:	e9 31 ff ff ff       	jmp    1c4fe <.L99+0x13a>
   1c5cd:	83 ec 08             	sub    $0x8,%esp
   1c5d0:	6a 30                	push   $0x30
   1c5d2:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c5d9:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c5e0:	ff 10                	call   *(%eax)
   1c5e2:	83 c4 08             	add    $0x8,%esp
   1c5e5:	83 7c 24 50 01       	cmpl   $0x1,0x50(%esp)
   1c5ea:	19 c0                	sbb    %eax,%eax
   1c5ec:	83 e0 20             	and    $0x20,%eax
   1c5ef:	83 c0 58             	add    $0x58,%eax
   1c5f2:	50                   	push   %eax
   1c5f3:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c5fa:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c601:	ff 10                	call   *(%eax)
   1c603:	83 c4 10             	add    $0x10,%esp
   1c606:	e9 fe fe ff ff       	jmp    1c509 <.L99+0x145>
   1c60b:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1c60f:	8b 5c 24 34          	mov    0x34(%esp),%ebx
   1c613:	39 d8                	cmp    %ebx,%eax
   1c615:	0f 8d ff fe ff ff    	jge    1c51a <.L99+0x156>
   1c61b:	89 6c 24 14          	mov    %ebp,0x14(%esp)
   1c61f:	89 c5                	mov    %eax,%ebp
   1c621:	89 7c 24 40          	mov    %edi,0x40(%esp)
   1c625:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
   1c62c:	83 ec 08             	sub    $0x8,%esp
   1c62f:	6a 30                	push   $0x30
   1c631:	57                   	push   %edi
   1c632:	ff 17                	call   *(%edi)
   1c634:	83 eb 01             	sub    $0x1,%ebx
   1c637:	83 c4 10             	add    $0x10,%esp
   1c63a:	39 dd                	cmp    %ebx,%ebp
   1c63c:	75 ee                	jne    1c62c <.L99+0x268>
   1c63e:	8b 6c 24 14          	mov    0x14(%esp),%ebp
   1c642:	89 5c 24 34          	mov    %ebx,0x34(%esp)
   1c646:	8b 7c 24 40          	mov    0x40(%esp),%edi
   1c64a:	e9 cb fe ff ff       	jmp    1c51a <.L99+0x156>
   1c64f:	89 7c 24 40          	mov    %edi,0x40(%esp)
   1c653:	8d 5c 3c 54          	lea    0x54(%esp,%edi,1),%ebx
   1c657:	85 ff                	test   %edi,%edi
   1c659:	7e 5d                	jle    1c6b8 <.L99+0x2f4>
   1c65b:	8b 54 24 30          	mov    0x30(%esp),%edx
   1c65f:	8b 44 24 38          	mov    0x38(%esp),%eax
   1c663:	89 6c 24 38          	mov    %ebp,0x38(%esp)
   1c667:	89 54 24 14          	mov    %edx,0x14(%esp)
   1c66b:	eb 34                	jmp    1c6a1 <.L99+0x2dd>
   1c66d:	8d 4b ff             	lea    -0x1(%ebx),%ecx
   1c670:	83 ef 01             	sub    $0x1,%edi
   1c673:	c6 43 ff 5f          	movb   $0x5f,-0x1(%ebx)
   1c677:	8b 5c 24 30          	mov    0x30(%esp),%ebx
   1c67b:	83 eb 01             	sub    $0x1,%ebx
   1c67e:	89 5c 24 14          	mov    %ebx,0x14(%esp)
   1c682:	8d 59 ff             	lea    -0x1(%ecx),%ebx
   1c685:	83 ef 01             	sub    $0x1,%edi
   1c688:	ba 00 00 00 00       	mov    $0x0,%edx
   1c68d:	f7 74 24 18          	divl   0x18(%esp)
   1c691:	8b 6c 24 28          	mov    0x28(%esp),%ebp
   1c695:	0f b6 54 15 00       	movzbl 0x0(%ebp,%edx,1),%edx
   1c69a:	88 51 ff             	mov    %dl,-0x1(%ecx)
   1c69d:	85 ff                	test   %edi,%edi
   1c69f:	7e 13                	jle    1c6b4 <.L99+0x2f0>
   1c6a1:	8b 54 24 14          	mov    0x14(%esp),%edx
   1c6a5:	85 d2                	test   %edx,%edx
   1c6a7:	74 c4                	je     1c66d <.L99+0x2a9>
   1c6a9:	83 ea 01             	sub    $0x1,%edx
   1c6ac:	89 54 24 14          	mov    %edx,0x14(%esp)
   1c6b0:	89 d9                	mov    %ebx,%ecx
   1c6b2:	eb ce                	jmp    1c682 <.L99+0x2be>
   1c6b4:	8b 6c 24 38          	mov    0x38(%esp),%ebp
   1c6b8:	8b 44 24 40          	mov    0x40(%esp),%eax
   1c6bc:	85 c0                	test   %eax,%eax
   1c6be:	74 2c                	je     1c6ec <.L99+0x328>
   1c6c0:	8d 5c 24 54          	lea    0x54(%esp),%ebx
   1c6c4:	01 d8                	add    %ebx,%eax
   1c6c6:	89 c7                	mov    %eax,%edi
   1c6c8:	89 6c 24 14          	mov    %ebp,0x14(%esp)
   1c6cc:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
   1c6d3:	83 ec 08             	sub    $0x8,%esp
   1c6d6:	0f be 03             	movsbl (%ebx),%eax
   1c6d9:	50                   	push   %eax
   1c6da:	55                   	push   %ebp
   1c6db:	ff 55 00             	call   *0x0(%ebp)
   1c6de:	83 c3 01             	add    $0x1,%ebx
   1c6e1:	83 c4 10             	add    $0x10,%esp
   1c6e4:	39 fb                	cmp    %edi,%ebx
   1c6e6:	75 eb                	jne    1c6d3 <.L99+0x30f>
   1c6e8:	8b 6c 24 14          	mov    0x14(%esp),%ebp
   1c6ec:	f6 44 24 0c 02       	testb  $0x2,0xc(%esp)
   1c6f1:	74 2f                	je     1c722 <.L99+0x35e>
   1c6f3:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1c6f7:	8b 5c 24 34          	mov    0x34(%esp),%ebx
   1c6fb:	39 d8                	cmp    %ebx,%eax
   1c6fd:	7d 23                	jge    1c722 <.L99+0x35e>
   1c6ff:	89 6c 24 14          	mov    %ebp,0x14(%esp)
   1c703:	89 c5                	mov    %eax,%ebp
   1c705:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
   1c70c:	83 ec 08             	sub    $0x8,%esp
   1c70f:	6a 20                	push   $0x20
   1c711:	57                   	push   %edi
   1c712:	ff 17                	call   *(%edi)
   1c714:	83 eb 01             	sub    $0x1,%ebx
   1c717:	83 c4 10             	add    $0x10,%esp
   1c71a:	39 dd                	cmp    %ebx,%ebp
   1c71c:	7c ee                	jl     1c70c <.L99+0x348>
   1c71e:	8b 6c 24 14          	mov    0x14(%esp),%ebp
   1c722:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c726:	89 ea                	mov    %ebp,%edx
   1c728:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c72d:	e9 74 f8 ff ff       	jmp    1bfa6 <.L9+0x24>

0001c732 <.L34>:
   1c732:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c739:	8b 00                	mov    (%eax),%eax
   1c73b:	88 44 24 7f          	mov    %al,0x7f(%esp)
   1c73f:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c746:	8d 40 04             	lea    0x4(%eax),%eax
   1c749:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c750:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
   1c757:	00 
   1c758:	8d 5c 24 7f          	lea    0x7f(%esp),%ebx
   1c75c:	8b 7c 24 08          	mov    0x8(%esp),%edi
   1c760:	83 ff ff             	cmp    $0xffffffff,%edi
   1c763:	74 12                	je     1c777 <.L34+0x45>
   1c765:	8b 54 24 14          	mov    0x14(%esp),%edx
   1c769:	39 fa                	cmp    %edi,%edx
   1c76b:	0f 9f c0             	setg   %al
   1c76e:	84 c0                	test   %al,%al
   1c770:	0f 45 d7             	cmovne %edi,%edx
   1c773:	89 54 24 14          	mov    %edx,0x14(%esp)
   1c777:	8b 7c 24 10          	mov    0x10(%esp),%edi
   1c77b:	39 7c 24 14          	cmp    %edi,0x14(%esp)
   1c77f:	7d 0b                	jge    1c78c <.L34+0x5a>
   1c781:	f6 44 24 0c 02       	testb  $0x2,0xc(%esp)
   1c786:	0f 84 cd 00 00 00    	je     1c859 <.L29+0x3f>
   1c78c:	8b 44 24 14          	mov    0x14(%esp),%eax
   1c790:	85 c0                	test   %eax,%eax
   1c792:	74 28                	je     1c7bc <.L34+0x8a>
   1c794:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
   1c797:	89 6c 24 18          	mov    %ebp,0x18(%esp)
   1c79b:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
   1c7a2:	83 c3 01             	add    $0x1,%ebx
   1c7a5:	83 ec 08             	sub    $0x8,%esp
   1c7a8:	0f be 43 ff          	movsbl -0x1(%ebx),%eax
   1c7ac:	50                   	push   %eax
   1c7ad:	55                   	push   %ebp
   1c7ae:	ff 55 00             	call   *0x0(%ebp)
   1c7b1:	83 c4 10             	add    $0x10,%esp
   1c7b4:	39 fb                	cmp    %edi,%ebx
   1c7b6:	75 ea                	jne    1c7a2 <.L34+0x70>
   1c7b8:	8b 6c 24 18          	mov    0x18(%esp),%ebp
   1c7bc:	8b 7c 24 14          	mov    0x14(%esp),%edi
   1c7c0:	39 7c 24 10          	cmp    %edi,0x10(%esp)
   1c7c4:	0f 8e 22 02 00 00    	jle    1c9ec <.L98+0xc>
   1c7ca:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c7ce:	89 ea                	mov    %ebp,%edx
   1c7d0:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   1c7d4:	83 e3 02             	and    $0x2,%ebx
   1c7d7:	0f 84 c9 f7 ff ff    	je     1bfa6 <.L9+0x24>
   1c7dd:	89 6c 24 18          	mov    %ebp,0x18(%esp)
   1c7e1:	8b 6c 24 14          	mov    0x14(%esp),%ebp
   1c7e5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1c7e9:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
   1c7f0:	83 ec 08             	sub    $0x8,%esp
   1c7f3:	6a 20                	push   $0x20
   1c7f5:	57                   	push   %edi
   1c7f6:	ff 17                	call   *(%edi)
   1c7f8:	83 eb 01             	sub    $0x1,%ebx
   1c7fb:	83 c4 10             	add    $0x10,%esp
   1c7fe:	39 dd                	cmp    %ebx,%ebp
   1c800:	75 ee                	jne    1c7f0 <.L34+0xbe>
   1c802:	8b 6c 24 18          	mov    0x18(%esp),%ebp
   1c806:	89 5c 24 10          	mov    %ebx,0x10(%esp)
   1c80a:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c80e:	89 ea                	mov    %ebp,%edx
   1c810:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c815:	e9 8c f7 ff ff       	jmp    1bfa6 <.L9+0x24>

0001c81a <.L29>:
   1c81a:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c821:	8b 18                	mov    (%eax),%ebx
   1c823:	85 db                	test   %ebx,%ebx
   1c825:	0f 44 5c 24 24       	cmove  0x24(%esp),%ebx
   1c82a:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1c82f:	b8 00 00 00 00       	mov    $0x0,%eax
   1c834:	89 df                	mov    %ebx,%edi
   1c836:	f2 ae                	repnz scas %es:(%edi),%al
   1c838:	89 c8                	mov    %ecx,%eax
   1c83a:	f7 d0                	not    %eax
   1c83c:	83 e8 01             	sub    $0x1,%eax
   1c83f:	89 44 24 14          	mov    %eax,0x14(%esp)
   1c843:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c84a:	8d 40 04             	lea    0x4(%eax),%eax
   1c84d:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c854:	e9 03 ff ff ff       	jmp    1c75c <.L34+0x2a>
   1c859:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1c85d:	83 e0 01             	and    $0x1,%eax
   1c860:	83 f8 01             	cmp    $0x1,%eax
   1c863:	19 c0                	sbb    %eax,%eax
   1c865:	83 e0 f0             	and    $0xfffffff0,%eax
   1c868:	83 c0 30             	add    $0x30,%eax
   1c86b:	0f be f8             	movsbl %al,%edi
   1c86e:	89 6c 24 18          	mov    %ebp,0x18(%esp)
   1c872:	89 5c 24 28          	mov    %ebx,0x28(%esp)
   1c876:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1c87a:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
   1c881:	83 ec 08             	sub    $0x8,%esp
   1c884:	57                   	push   %edi
   1c885:	55                   	push   %ebp
   1c886:	ff 55 00             	call   *0x0(%ebp)
   1c889:	83 eb 01             	sub    $0x1,%ebx
   1c88c:	83 c4 10             	add    $0x10,%esp
   1c88f:	39 5c 24 14          	cmp    %ebx,0x14(%esp)
   1c893:	75 ec                	jne    1c881 <.L29+0x67>
   1c895:	8b 6c 24 18          	mov    0x18(%esp),%ebp
   1c899:	89 5c 24 10          	mov    %ebx,0x10(%esp)
   1c89d:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   1c8a1:	e9 e6 fe ff ff       	jmp    1c78c <.L34+0x5a>

0001c8a6 <.L32>:
   1c8a6:	85 ff                	test   %edi,%edi
   1c8a8:	74 79                	je     1c923 <.L32+0x7d>
   1c8aa:	0f 8f 9f 00 00 00    	jg     1c94f <.L32+0xa9>
   1c8b0:	83 ff ff             	cmp    $0xffffffff,%edi
   1c8b3:	7c 40                	jl     1c8f5 <.L32+0x4f>
   1c8b5:	83 ff ff             	cmp    $0xffffffff,%edi
   1c8b8:	75 2b                	jne    1c8e5 <.L32+0x3f>
   1c8ba:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c8c1:	8b 00                	mov    (%eax),%eax
   1c8c3:	66 c7 00 00 00       	movw   $0x0,(%eax)
   1c8c8:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c8cf:	8d 40 04             	lea    0x4(%eax),%eax
   1c8d2:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c8d9:	89 ea                	mov    %ebp,%edx
   1c8db:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c8e0:	e9 c1 f6 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c8e5:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c8e9:	89 ea                	mov    %ebp,%edx
   1c8eb:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c8f0:	e9 b1 f6 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c8f5:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c8fc:	8b 00                	mov    (%eax),%eax
   1c8fe:	c6 00 00             	movb   $0x0,(%eax)
   1c901:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c908:	8d 40 04             	lea    0x4(%eax),%eax
   1c90b:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c912:	89 ea                	mov    %ebp,%edx
   1c914:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c919:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
   1c91e:	e9 83 f6 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c923:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c92a:	8b 00                	mov    (%eax),%eax
   1c92c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c932:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c939:	8d 40 04             	lea    0x4(%eax),%eax
   1c93c:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c943:	89 ea                	mov    %ebp,%edx
   1c945:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c94a:	e9 57 f6 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c94f:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c956:	8b 00                	mov    (%eax),%eax
   1c958:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1c95e:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
   1c965:	8d 40 04             	lea    0x4(%eax),%eax
   1c968:	89 84 24 a8 00 00 00 	mov    %eax,0xa8(%esp)
   1c96f:	89 ea                	mov    %ebp,%edx
   1c971:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c976:	bf 01 00 00 00       	mov    $0x1,%edi
   1c97b:	e9 26 f6 ff ff       	jmp    1bfa6 <.L9+0x24>

0001c980 <.L25>:
   1c980:	83 ec 08             	sub    $0x8,%esp
   1c983:	0f be c0             	movsbl %al,%eax
   1c986:	50                   	push   %eax
   1c987:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1c98e:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1c995:	ff 10                	call   *(%eax)
   1c997:	83 c4 10             	add    $0x10,%esp
   1c99a:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c99e:	89 ea                	mov    %ebp,%edx
   1c9a0:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c9a5:	e9 fc f5 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c9aa:	89 ea                	mov    %ebp,%edx
   1c9ac:	e9 f5 f5 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c9b1:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
   1c9b5:	89 ea                	mov    %ebp,%edx
   1c9b7:	bb 01 00 00 00       	mov    $0x1,%ebx
   1c9bc:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
   1c9c3:	ff 
   1c9c4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1c9cb:	00 
   1c9cc:	bf 00 00 00 00       	mov    $0x0,%edi
   1c9d1:	e9 d0 f5 ff ff       	jmp    1bfa6 <.L9+0x24>

0001c9d6 <.L94>:
   1c9d6:	bb 02 00 00 00       	mov    $0x2,%ebx
   1c9db:	e9 c6 f5 ff ff       	jmp    1bfa6 <.L9+0x24>

0001c9e0 <.L98>:
   1c9e0:	89 ea                	mov    %ebp,%edx
   1c9e2:	bf 01 00 00 00       	mov    $0x1,%edi
   1c9e7:	e9 ba f5 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c9ec:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1c9f0:	89 ea                	mov    %ebp,%edx
   1c9f2:	bb 00 00 00 00       	mov    $0x0,%ebx
   1c9f7:	e9 aa f5 ff ff       	jmp    1bfa6 <.L9+0x24>
   1c9fc:	83 ec 0c             	sub    $0xc,%esp
   1c9ff:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
   1ca06:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
   1ca0d:	ff 50 04             	call   *0x4(%eax)
   1ca10:	b8 00 00 00 00       	mov    $0x0,%eax
   1ca15:	81 c4 9c 00 00 00    	add    $0x9c,%esp
   1ca1b:	5b                   	pop    %ebx
   1ca1c:	5e                   	pop    %esi
   1ca1d:	5f                   	pop    %edi
   1ca1e:	5d                   	pop    %ebp
   1ca1f:	c3                   	ret    

0001ca20 <String_Emit>:
   1ca20:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ca24:	8b 50 10             	mov    0x10(%eax),%edx
   1ca27:	39 50 0c             	cmp    %edx,0xc(%eax)
   1ca2a:	73 0f                	jae    1ca3b <String_Emit+0x1b>
   1ca2c:	8b 50 08             	mov    0x8(%eax),%edx
   1ca2f:	8d 4a 01             	lea    0x1(%edx),%ecx
   1ca32:	89 48 08             	mov    %ecx,0x8(%eax)
   1ca35:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1ca39:	88 0a                	mov    %cl,(%edx)
   1ca3b:	83 40 0c 01          	addl   $0x1,0xc(%eax)
   1ca3f:	c3                   	ret    

0001ca40 <String_Finish>:
   1ca40:	8b 44 24 04          	mov    0x4(%esp),%eax
   1ca44:	8b 50 10             	mov    0x10(%eax),%edx
   1ca47:	39 50 0c             	cmp    %edx,0xc(%eax)
   1ca4a:	73 07                	jae    1ca53 <String_Finish+0x13>
   1ca4c:	8b 40 08             	mov    0x8(%eax),%eax
   1ca4f:	c6 00 00             	movb   $0x0,(%eax)
   1ca52:	c3                   	ret    
   1ca53:	8b 40 08             	mov    0x8(%eax),%eax
   1ca56:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
   1ca5a:	c3                   	ret    

0001ca5b <memset>:
   1ca5b:	53                   	push   %ebx
   1ca5c:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1ca60:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1ca64:	8b 54 24 10          	mov    0x10(%esp),%edx
   1ca68:	85 d2                	test   %edx,%edx
   1ca6a:	74 0e                	je     1ca7a <memset+0x1f>
   1ca6c:	01 da                	add    %ebx,%edx
   1ca6e:	89 d8                	mov    %ebx,%eax
   1ca70:	83 c0 01             	add    $0x1,%eax
   1ca73:	88 48 ff             	mov    %cl,-0x1(%eax)
   1ca76:	39 c2                	cmp    %eax,%edx
   1ca78:	75 f6                	jne    1ca70 <memset+0x15>
   1ca7a:	89 d8                	mov    %ebx,%eax
   1ca7c:	5b                   	pop    %ebx
   1ca7d:	c3                   	ret    

0001ca7e <memcpy>:
   1ca7e:	56                   	push   %esi
   1ca7f:	53                   	push   %ebx
   1ca80:	8b 74 24 0c          	mov    0xc(%esp),%esi
   1ca84:	8b 54 24 10          	mov    0x10(%esp),%edx
   1ca88:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   1ca8c:	85 db                	test   %ebx,%ebx
   1ca8e:	74 15                	je     1caa5 <memcpy+0x27>
   1ca90:	01 f3                	add    %esi,%ebx
   1ca92:	89 f0                	mov    %esi,%eax
   1ca94:	83 c2 01             	add    $0x1,%edx
   1ca97:	83 c0 01             	add    $0x1,%eax
   1ca9a:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
   1ca9e:	88 48 ff             	mov    %cl,-0x1(%eax)
   1caa1:	39 c3                	cmp    %eax,%ebx
   1caa3:	75 ef                	jne    1ca94 <memcpy+0x16>
   1caa5:	89 f0                	mov    %esi,%eax
   1caa7:	5b                   	pop    %ebx
   1caa8:	5e                   	pop    %esi
   1caa9:	c3                   	ret    

0001caaa <memcmp>:
   1caaa:	56                   	push   %esi
   1caab:	53                   	push   %ebx
   1caac:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   1cab0:	8b 74 24 10          	mov    0x10(%esp),%esi
   1cab4:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1cab9:	74 17                	je     1cad2 <memcmp+0x28>
   1cabb:	ba 00 00 00 00       	mov    $0x0,%edx
   1cac0:	0f be 04 13          	movsbl (%ebx,%edx,1),%eax
   1cac4:	0f be 0c 16          	movsbl (%esi,%edx,1),%ecx
   1cac8:	83 c2 01             	add    $0x1,%edx
   1cacb:	29 c8                	sub    %ecx,%eax
   1cacd:	74 f1                	je     1cac0 <memcmp+0x16>
   1cacf:	5b                   	pop    %ebx
   1cad0:	5e                   	pop    %esi
   1cad1:	c3                   	ret    
   1cad2:	b8 00 00 00 00       	mov    $0x0,%eax
   1cad7:	eb f6                	jmp    1cacf <memcmp+0x25>

0001cad9 <strlen>:
   1cad9:	8b 54 24 04          	mov    0x4(%esp),%edx
   1cadd:	80 3a 00             	cmpb   $0x0,(%edx)
   1cae0:	74 0f                	je     1caf1 <strlen+0x18>
   1cae2:	b8 00 00 00 00       	mov    $0x0,%eax
   1cae7:	83 c0 01             	add    $0x1,%eax
   1caea:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
   1caee:	75 f7                	jne    1cae7 <strlen+0xe>
   1caf0:	c3                   	ret    
   1caf1:	b8 00 00 00 00       	mov    $0x0,%eax
   1caf6:	c3                   	ret    

0001caf7 <strnlen>:
   1caf7:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   1cafb:	8b 54 24 08          	mov    0x8(%esp),%edx
   1caff:	b8 00 00 00 00       	mov    $0x0,%eax
   1cb04:	85 d2                	test   %edx,%edx
   1cb06:	74 0e                	je     1cb16 <strnlen+0x1f>
   1cb08:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
   1cb0c:	74 07                	je     1cb15 <strnlen+0x1e>
   1cb0e:	83 c0 01             	add    $0x1,%eax
   1cb11:	39 c2                	cmp    %eax,%edx
   1cb13:	75 f3                	jne    1cb08 <strnlen+0x11>
   1cb15:	c3                   	ret    
   1cb16:	89 d0                	mov    %edx,%eax
   1cb18:	c3                   	ret    

0001cb19 <strcmp>:
   1cb19:	55                   	push   %ebp
   1cb1a:	57                   	push   %edi
   1cb1b:	56                   	push   %esi
   1cb1c:	53                   	push   %ebx
   1cb1d:	8b 74 24 18          	mov    0x18(%esp),%esi
   1cb21:	8b 44 24 14          	mov    0x14(%esp),%eax
   1cb25:	0f b6 08             	movzbl (%eax),%ecx
   1cb28:	0f b6 16             	movzbl (%esi),%edx
   1cb2b:	0f be c1             	movsbl %cl,%eax
   1cb2e:	0f be fa             	movsbl %dl,%edi
   1cb31:	29 f8                	sub    %edi,%eax
   1cb33:	84 c9                	test   %cl,%cl
   1cb35:	0f 94 c1             	sete   %cl
   1cb38:	84 d2                	test   %dl,%dl
   1cb3a:	0f 94 c2             	sete   %dl
   1cb3d:	08 d1                	or     %dl,%cl
   1cb3f:	75 36                	jne    1cb77 <strcmp+0x5e>
   1cb41:	ba 01 00 00 00       	mov    $0x1,%edx
   1cb46:	85 c0                	test   %eax,%eax
   1cb48:	75 2d                	jne    1cb77 <strcmp+0x5e>
   1cb4a:	8b 44 24 14          	mov    0x14(%esp),%eax
   1cb4e:	0f b6 3c 10          	movzbl (%eax,%edx,1),%edi
   1cb52:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
   1cb56:	89 f8                	mov    %edi,%eax
   1cb58:	0f be c0             	movsbl %al,%eax
   1cb5b:	0f be e9             	movsbl %cl,%ebp
   1cb5e:	29 e8                	sub    %ebp,%eax
   1cb60:	83 c2 01             	add    $0x1,%edx
   1cb63:	89 fb                	mov    %edi,%ebx
   1cb65:	84 db                	test   %bl,%bl
   1cb67:	0f 94 c3             	sete   %bl
   1cb6a:	84 c9                	test   %cl,%cl
   1cb6c:	0f 94 c1             	sete   %cl
   1cb6f:	08 cb                	or     %cl,%bl
   1cb71:	75 04                	jne    1cb77 <strcmp+0x5e>
   1cb73:	85 c0                	test   %eax,%eax
   1cb75:	74 d3                	je     1cb4a <strcmp+0x31>
   1cb77:	5b                   	pop    %ebx
   1cb78:	5e                   	pop    %esi
   1cb79:	5f                   	pop    %edi
   1cb7a:	5d                   	pop    %ebp
   1cb7b:	c3                   	ret    

0001cb7c <strncmp>:
   1cb7c:	55                   	push   %ebp
   1cb7d:	57                   	push   %edi
   1cb7e:	56                   	push   %esi
   1cb7f:	53                   	push   %ebx
   1cb80:	8b 54 24 14          	mov    0x14(%esp),%edx
   1cb84:	8b 74 24 18          	mov    0x18(%esp),%esi
   1cb88:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
   1cb8c:	85 ff                	test   %edi,%edi
   1cb8e:	74 31                	je     1cbc1 <strncmp+0x45>
   1cb90:	01 d7                	add    %edx,%edi
   1cb92:	0f b6 1a             	movzbl (%edx),%ebx
   1cb95:	0f b6 0e             	movzbl (%esi),%ecx
   1cb98:	0f be c3             	movsbl %bl,%eax
   1cb9b:	0f be e9             	movsbl %cl,%ebp
   1cb9e:	29 e8                	sub    %ebp,%eax
   1cba0:	84 db                	test   %bl,%bl
   1cba2:	0f 94 c3             	sete   %bl
   1cba5:	84 c9                	test   %cl,%cl
   1cba7:	0f 94 c1             	sete   %cl
   1cbaa:	08 cb                	or     %cl,%bl
   1cbac:	75 0e                	jne    1cbbc <strncmp+0x40>
   1cbae:	85 c0                	test   %eax,%eax
   1cbb0:	75 0a                	jne    1cbbc <strncmp+0x40>
   1cbb2:	83 c2 01             	add    $0x1,%edx
   1cbb5:	83 c6 01             	add    $0x1,%esi
   1cbb8:	39 d7                	cmp    %edx,%edi
   1cbba:	75 d6                	jne    1cb92 <strncmp+0x16>
   1cbbc:	5b                   	pop    %ebx
   1cbbd:	5e                   	pop    %esi
   1cbbe:	5f                   	pop    %edi
   1cbbf:	5d                   	pop    %ebp
   1cbc0:	c3                   	ret    
   1cbc1:	b8 00 00 00 00       	mov    $0x0,%eax
   1cbc6:	eb f4                	jmp    1cbbc <strncmp+0x40>

0001cbc8 <strcat>:
   1cbc8:	53                   	push   %ebx
   1cbc9:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1cbcd:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1cbd1:	80 3b 00             	cmpb   $0x0,(%ebx)
   1cbd4:	74 28                	je     1cbfe <strcat+0x36>
   1cbd6:	89 d8                	mov    %ebx,%eax
   1cbd8:	83 c0 01             	add    $0x1,%eax
   1cbdb:	80 38 00             	cmpb   $0x0,(%eax)
   1cbde:	75 f8                	jne    1cbd8 <strcat+0x10>
   1cbe0:	0f b6 11             	movzbl (%ecx),%edx
   1cbe3:	84 d2                	test   %dl,%dl
   1cbe5:	74 10                	je     1cbf7 <strcat+0x2f>
   1cbe7:	83 c1 01             	add    $0x1,%ecx
   1cbea:	83 c0 01             	add    $0x1,%eax
   1cbed:	88 50 ff             	mov    %dl,-0x1(%eax)
   1cbf0:	0f b6 11             	movzbl (%ecx),%edx
   1cbf3:	84 d2                	test   %dl,%dl
   1cbf5:	75 f0                	jne    1cbe7 <strcat+0x1f>
   1cbf7:	c6 00 00             	movb   $0x0,(%eax)
   1cbfa:	89 d8                	mov    %ebx,%eax
   1cbfc:	5b                   	pop    %ebx
   1cbfd:	c3                   	ret    
   1cbfe:	89 d8                	mov    %ebx,%eax
   1cc00:	eb de                	jmp    1cbe0 <strcat+0x18>

0001cc02 <strcpy>:
   1cc02:	53                   	push   %ebx
   1cc03:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   1cc07:	8b 54 24 0c          	mov    0xc(%esp),%edx
   1cc0b:	0f b6 02             	movzbl (%edx),%eax
   1cc0e:	84 c0                	test   %al,%al
   1cc10:	74 19                	je     1cc2b <strcpy+0x29>
   1cc12:	89 d9                	mov    %ebx,%ecx
   1cc14:	83 c2 01             	add    $0x1,%edx
   1cc17:	83 c1 01             	add    $0x1,%ecx
   1cc1a:	88 41 ff             	mov    %al,-0x1(%ecx)
   1cc1d:	0f b6 02             	movzbl (%edx),%eax
   1cc20:	84 c0                	test   %al,%al
   1cc22:	75 f0                	jne    1cc14 <strcpy+0x12>
   1cc24:	c6 01 00             	movb   $0x0,(%ecx)
   1cc27:	89 d8                	mov    %ebx,%eax
   1cc29:	5b                   	pop    %ebx
   1cc2a:	c3                   	ret    
   1cc2b:	89 d9                	mov    %ebx,%ecx
   1cc2d:	eb f5                	jmp    1cc24 <strcpy+0x22>

0001cc2f <strncpy>:
   1cc2f:	56                   	push   %esi
   1cc30:	53                   	push   %ebx
   1cc31:	8b 74 24 0c          	mov    0xc(%esp),%esi
   1cc35:	8b 54 24 10          	mov    0x10(%esp),%edx
   1cc39:	8b 44 24 14          	mov    0x14(%esp),%eax
   1cc3d:	0f b6 0a             	movzbl (%edx),%ecx
   1cc40:	85 c0                	test   %eax,%eax
   1cc42:	74 27                	je     1cc6b <strncpy+0x3c>
   1cc44:	84 c9                	test   %cl,%cl
   1cc46:	74 23                	je     1cc6b <strncpy+0x3c>
   1cc48:	89 f3                	mov    %esi,%ebx
   1cc4a:	83 c2 01             	add    $0x1,%edx
   1cc4d:	83 c3 01             	add    $0x1,%ebx
   1cc50:	88 4b ff             	mov    %cl,-0x1(%ebx)
   1cc53:	0f b6 0a             	movzbl (%edx),%ecx
   1cc56:	83 e8 01             	sub    $0x1,%eax
   1cc59:	74 04                	je     1cc5f <strncpy+0x30>
   1cc5b:	84 c9                	test   %cl,%cl
   1cc5d:	75 eb                	jne    1cc4a <strncpy+0x1b>
   1cc5f:	85 c0                	test   %eax,%eax
   1cc61:	74 03                	je     1cc66 <strncpy+0x37>
   1cc63:	c6 03 00             	movb   $0x0,(%ebx)
   1cc66:	89 f0                	mov    %esi,%eax
   1cc68:	5b                   	pop    %ebx
   1cc69:	5e                   	pop    %esi
   1cc6a:	c3                   	ret    
   1cc6b:	89 f3                	mov    %esi,%ebx
   1cc6d:	eb f0                	jmp    1cc5f <strncpy+0x30>

0001cc6f <strdup>:
   1cc6f:	57                   	push   %edi
   1cc70:	56                   	push   %esi
   1cc71:	53                   	push   %ebx
   1cc72:	e8 9b 35 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1cc77:	81 c3 89 93 00 00    	add    $0x9389,%ebx
   1cc7d:	8b 74 24 10          	mov    0x10(%esp),%esi
   1cc81:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1cc86:	b8 00 00 00 00       	mov    $0x0,%eax
   1cc8b:	89 f7                	mov    %esi,%edi
   1cc8d:	f2 ae                	repnz scas %es:(%edi),%al
   1cc8f:	f7 d1                	not    %ecx
   1cc91:	83 ec 0c             	sub    $0xc,%esp
   1cc94:	51                   	push   %ecx
   1cc95:	e8 12 6f ff ff       	call   13bac <Malloc>
   1cc9a:	89 c3                	mov    %eax,%ebx
   1cc9c:	83 c4 08             	add    $0x8,%esp
   1cc9f:	56                   	push   %esi
   1cca0:	50                   	push   %eax
   1cca1:	e8 5c ff ff ff       	call   1cc02 <strcpy>
   1cca6:	83 c4 10             	add    $0x10,%esp
   1cca9:	89 d8                	mov    %ebx,%eax
   1ccab:	5b                   	pop    %ebx
   1ccac:	5e                   	pop    %esi
   1ccad:	5f                   	pop    %edi
   1ccae:	c3                   	ret    

0001ccaf <atoi>:
   1ccaf:	53                   	push   %ebx
   1ccb0:	8b 54 24 08          	mov    0x8(%esp),%edx
   1ccb4:	0f b6 02             	movzbl (%edx),%eax
   1ccb7:	8d 48 d0             	lea    -0x30(%eax),%ecx
   1ccba:	80 f9 09             	cmp    $0x9,%cl
   1ccbd:	77 21                	ja     1cce0 <atoi+0x31>
   1ccbf:	b9 00 00 00 00       	mov    $0x0,%ecx
   1ccc4:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
   1ccc7:	0f be c0             	movsbl %al,%eax
   1ccca:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
   1ccce:	83 c2 01             	add    $0x1,%edx
   1ccd1:	0f b6 02             	movzbl (%edx),%eax
   1ccd4:	8d 58 d0             	lea    -0x30(%eax),%ebx
   1ccd7:	80 fb 09             	cmp    $0x9,%bl
   1ccda:	76 e8                	jbe    1ccc4 <atoi+0x15>
   1ccdc:	89 c8                	mov    %ecx,%eax
   1ccde:	5b                   	pop    %ebx
   1ccdf:	c3                   	ret    
   1cce0:	b9 00 00 00 00       	mov    $0x0,%ecx
   1cce5:	eb f5                	jmp    1ccdc <atoi+0x2d>

0001cce7 <strchr>:
   1cce7:	8b 44 24 04          	mov    0x4(%esp),%eax
   1cceb:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1ccef:	0f b6 10             	movzbl (%eax),%edx
   1ccf2:	84 d2                	test   %dl,%dl
   1ccf4:	74 17                	je     1cd0d <strchr+0x26>
   1ccf6:	0f be d2             	movsbl %dl,%edx
   1ccf9:	39 ca                	cmp    %ecx,%edx
   1ccfb:	74 15                	je     1cd12 <strchr+0x2b>
   1ccfd:	83 c0 01             	add    $0x1,%eax
   1cd00:	0f b6 10             	movzbl (%eax),%edx
   1cd03:	84 d2                	test   %dl,%dl
   1cd05:	75 ef                	jne    1ccf6 <strchr+0xf>
   1cd07:	b8 00 00 00 00       	mov    $0x0,%eax
   1cd0c:	c3                   	ret    
   1cd0d:	b8 00 00 00 00       	mov    $0x0,%eax
   1cd12:	c3                   	ret    

0001cd13 <strrchr>:
   1cd13:	57                   	push   %edi
   1cd14:	56                   	push   %esi
   1cd15:	53                   	push   %ebx
   1cd16:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1cd1a:	8b 74 24 14          	mov    0x14(%esp),%esi
   1cd1e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1cd23:	b8 00 00 00 00       	mov    $0x0,%eax
   1cd28:	89 df                	mov    %ebx,%edi
   1cd2a:	f2 ae                	repnz scas %es:(%edi),%al
   1cd2c:	f7 d1                	not    %ecx
   1cd2e:	8d 44 0b ff          	lea    -0x1(%ebx,%ecx,1),%eax
   1cd32:	39 d8                	cmp    %ebx,%eax
   1cd34:	76 0c                	jbe    1cd42 <strrchr+0x2f>
   1cd36:	83 e8 01             	sub    $0x1,%eax
   1cd39:	0f be 10             	movsbl (%eax),%edx
   1cd3c:	39 f2                	cmp    %esi,%edx
   1cd3e:	75 f2                	jne    1cd32 <strrchr+0x1f>
   1cd40:	eb 05                	jmp    1cd47 <strrchr+0x34>
   1cd42:	b8 00 00 00 00       	mov    $0x0,%eax
   1cd47:	5b                   	pop    %ebx
   1cd48:	5e                   	pop    %esi
   1cd49:	5f                   	pop    %edi
   1cd4a:	c3                   	ret    

0001cd4b <strpbrk>:
   1cd4b:	57                   	push   %edi
   1cd4c:	56                   	push   %esi
   1cd4d:	53                   	push   %ebx
   1cd4e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
   1cd52:	8b 74 24 14          	mov    0x14(%esp),%esi
   1cd56:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   1cd5b:	b8 00 00 00 00       	mov    $0x0,%eax
   1cd60:	89 f7                	mov    %esi,%edi
   1cd62:	f2 ae                	repnz scas %es:(%edi),%al
   1cd64:	f7 d1                	not    %ecx
   1cd66:	8d 79 ff             	lea    -0x1(%ecx),%edi
   1cd69:	0f b6 13             	movzbl (%ebx),%edx
   1cd6c:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
   1cd6f:	84 d2                	test   %dl,%dl
   1cd71:	74 22                	je     1cd95 <strpbrk+0x4a>
   1cd73:	89 f0                	mov    %esi,%eax
   1cd75:	85 ff                	test   %edi,%edi
   1cd77:	74 0b                	je     1cd84 <strpbrk+0x39>
   1cd79:	38 10                	cmp    %dl,(%eax)
   1cd7b:	74 1d                	je     1cd9a <strpbrk+0x4f>
   1cd7d:	83 c0 01             	add    $0x1,%eax
   1cd80:	39 c8                	cmp    %ecx,%eax
   1cd82:	75 f5                	jne    1cd79 <strpbrk+0x2e>
   1cd84:	83 c3 01             	add    $0x1,%ebx
   1cd87:	0f b6 13             	movzbl (%ebx),%edx
   1cd8a:	84 d2                	test   %dl,%dl
   1cd8c:	75 e5                	jne    1cd73 <strpbrk+0x28>
   1cd8e:	bb 00 00 00 00       	mov    $0x0,%ebx
   1cd93:	eb 05                	jmp    1cd9a <strpbrk+0x4f>
   1cd95:	bb 00 00 00 00       	mov    $0x0,%ebx
   1cd9a:	89 d8                	mov    %ebx,%eax
   1cd9c:	5b                   	pop    %ebx
   1cd9d:	5e                   	pop    %esi
   1cd9e:	5f                   	pop    %edi
   1cd9f:	c3                   	ret    

0001cda0 <snprintf>:
   1cda0:	53                   	push   %ebx
   1cda1:	83 ec 28             	sub    $0x28,%esp
   1cda4:	e8 69 34 ff ff       	call   10212 <__x86.get_pc_thunk.bx>
   1cda9:	81 c3 57 92 00 00    	add    $0x9257,%ebx
   1cdaf:	8d 83 20 6a ff ff    	lea    -0x95e0(%ebx),%eax
   1cdb5:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1cdb9:	8d 83 40 6a ff ff    	lea    -0x95c0(%ebx),%eax
   1cdbf:	89 44 24 10          	mov    %eax,0x10(%esp)
   1cdc3:	8b 44 24 30          	mov    0x30(%esp),%eax
   1cdc7:	89 44 24 14          	mov    %eax,0x14(%esp)
   1cdcb:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   1cdd2:	00 
   1cdd3:	8b 44 24 34          	mov    0x34(%esp),%eax
   1cdd7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   1cddb:	8d 44 24 3c          	lea    0x3c(%esp),%eax
   1cddf:	83 ec 04             	sub    $0x4,%esp
   1cde2:	50                   	push   %eax
   1cde3:	ff 74 24 40          	pushl  0x40(%esp)
   1cde7:	8d 44 24 18          	lea    0x18(%esp),%eax
   1cdeb:	50                   	push   %eax
   1cdec:	e8 27 f1 ff ff       	call   1bf18 <Format_Output>
   1cdf1:	83 c4 38             	add    $0x38,%esp
   1cdf4:	5b                   	pop    %ebx
   1cdf5:	c3                   	ret    

0001cdf6 <memmove>:
   1cdf6:	57                   	push   %edi
   1cdf7:	56                   	push   %esi
   1cdf8:	53                   	push   %ebx
   1cdf9:	e8 90 5d ff ff       	call   12b8e <__x86.get_pc_thunk.di>
   1cdfe:	81 c7 02 92 00 00    	add    $0x9202,%edi
   1ce04:	8b 74 24 10          	mov    0x10(%esp),%esi
   1ce08:	8b 44 24 14          	mov    0x14(%esp),%eax
   1ce0c:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   1ce10:	85 db                	test   %ebx,%ebx
   1ce12:	74 31                	je     1ce45 <memmove+0x4f>
   1ce14:	8d 14 1e             	lea    (%esi,%ebx,1),%edx
   1ce17:	39 c2                	cmp    %eax,%edx
   1ce19:	76 1a                	jbe    1ce35 <memmove+0x3f>
   1ce1b:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
   1ce1e:	39 f1                	cmp    %esi,%ecx
   1ce20:	76 13                	jbe    1ce35 <memmove+0x3f>
   1ce22:	39 c6                	cmp    %eax,%esi
   1ce24:	73 25                	jae    1ce4b <memmove+0x55>
   1ce26:	83 c0 01             	add    $0x1,%eax
   1ce29:	83 c6 01             	add    $0x1,%esi
   1ce2c:	0f b6 50 ff          	movzbl -0x1(%eax),%edx
   1ce30:	88 56 ff             	mov    %dl,-0x1(%esi)
   1ce33:	eb f1                	jmp    1ce26 <memmove+0x30>
   1ce35:	83 ec 04             	sub    $0x4,%esp
   1ce38:	53                   	push   %ebx
   1ce39:	50                   	push   %eax
   1ce3a:	56                   	push   %esi
   1ce3b:	89 fb                	mov    %edi,%ebx
   1ce3d:	e8 3c fc ff ff       	call   1ca7e <memcpy>
   1ce42:	83 c4 10             	add    $0x10,%esp
   1ce45:	89 f0                	mov    %esi,%eax
   1ce47:	5b                   	pop    %ebx
   1ce48:	5e                   	pop    %esi
   1ce49:	5f                   	pop    %edi
   1ce4a:	c3                   	ret    
   1ce4b:	76 f8                	jbe    1ce45 <memmove+0x4f>
   1ce4d:	83 e9 01             	sub    $0x1,%ecx
   1ce50:	83 ea 01             	sub    $0x1,%edx
   1ce53:	0f b6 01             	movzbl (%ecx),%eax
   1ce56:	88 02                	mov    %al,(%edx)
   1ce58:	eb f3                	jmp    1ce4d <memmove+0x57>
